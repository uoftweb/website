var __defineProperty = Object.defineProperty;
var __hasOwnProperty = Object.prototype.hasOwnProperty;
var __commonJS = (callback, module2) => () => {
  if (!module2) {
    module2 = {exports: {}};
    callback(module2.exports, module2);
  }
  return module2.exports;
};
var __markAsModule = (target) => {
  return __defineProperty(target, "__esModule", {value: true});
};
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defineProperty(target, name, {get: all[name], enumerable: true});
};
var __exportStar = (target, module2) => {
  __markAsModule(target);
  if (typeof module2 === "object" || typeof module2 === "function") {
    for (let key in module2)
      if (!__hasOwnProperty.call(target, key) && key !== "default")
        __defineProperty(target, key, {get: () => module2[key], enumerable: true});
  }
  return target;
};
var __toModule = (module2) => {
  if (module2 && module2.__esModule)
    return module2;
  return __exportStar(__defineProperty({}, "default", {value: module2, enumerable: true}), module2);
};

// ../../node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/windows.js
var require_windows = __commonJS((exports2, module2) => {
  module2.exports = isexe;
  isexe.sync = sync;
  var fs3 = require("fs");
  function checkPathExt(path9, options) {
    var pathext = options.pathExt !== void 0 ? options.pathExt : process.env.PATHEXT;
    if (!pathext) {
      return true;
    }
    pathext = pathext.split(";");
    if (pathext.indexOf("") !== -1) {
      return true;
    }
    for (var i = 0; i < pathext.length; i++) {
      var p = pathext[i].toLowerCase();
      if (p && path9.substr(-p.length).toLowerCase() === p) {
        return true;
      }
    }
    return false;
  }
  function checkStat(stat2, path9, options) {
    if (!stat2.isSymbolicLink() && !stat2.isFile()) {
      return false;
    }
    return checkPathExt(path9, options);
  }
  function isexe(path9, options, cb) {
    fs3.stat(path9, function(er, stat2) {
      cb(er, er ? false : checkStat(stat2, path9, options));
    });
  }
  function sync(path9, options) {
    return checkStat(fs3.statSync(path9), path9, options);
  }
});

// ../../node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/mode.js
var require_mode = __commonJS((exports2, module2) => {
  module2.exports = isexe;
  isexe.sync = sync;
  var fs3 = require("fs");
  function isexe(path9, options, cb) {
    fs3.stat(path9, function(er, stat2) {
      cb(er, er ? false : checkStat(stat2, options));
    });
  }
  function sync(path9, options) {
    return checkStat(fs3.statSync(path9), options);
  }
  function checkStat(stat2, options) {
    return stat2.isFile() && checkMode(stat2, options);
  }
  function checkMode(stat2, options) {
    var mod = stat2.mode;
    var uid = stat2.uid;
    var gid = stat2.gid;
    var myUid = options.uid !== void 0 ? options.uid : process.getuid && process.getuid();
    var myGid = options.gid !== void 0 ? options.gid : process.getgid && process.getgid();
    var u = parseInt("100", 8);
    var g = parseInt("010", 8);
    var o = parseInt("001", 8);
    var ug = u | g;
    var ret = mod & o || mod & g && gid === myGid || mod & u && uid === myUid || mod & ug && myUid === 0;
    return ret;
  }
});

// ../../node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/index.js
var require_isexe = __commonJS((exports2, module2) => {
  var fs3 = require("fs");
  var core;
  if (process.platform === "win32" || global.TESTING_WINDOWS) {
    core = require_windows();
  } else {
    core = require_mode();
  }
  module2.exports = isexe;
  isexe.sync = sync;
  function isexe(path9, options, cb) {
    if (typeof options === "function") {
      cb = options;
      options = {};
    }
    if (!cb) {
      if (typeof Promise !== "function") {
        throw new TypeError("callback not provided");
      }
      return new Promise(function(resolve, reject) {
        isexe(path9, options || {}, function(er, is) {
          if (er) {
            reject(er);
          } else {
            resolve(is);
          }
        });
      });
    }
    core(path9, options || {}, function(er, is) {
      if (er) {
        if (er.code === "EACCES" || options && options.ignoreErrors) {
          er = null;
          is = false;
        }
      }
      cb(er, is);
    });
  }
  function sync(path9, options) {
    try {
      return core.sync(path9, options || {});
    } catch (er) {
      if (options && options.ignoreErrors || er.code === "EACCES") {
        return false;
      } else {
        throw er;
      }
    }
  }
});

// ../../node_modules/.pnpm/which@2.0.2/node_modules/which/which.js
var require_which = __commonJS((exports2, module2) => {
  const isWindows = process.platform === "win32" || process.env.OSTYPE === "cygwin" || process.env.OSTYPE === "msys";
  const path9 = require("path");
  const COLON = isWindows ? ";" : ":";
  const isexe = require_isexe();
  const getNotFoundError = (cmd) => Object.assign(new Error(`not found: ${cmd}`), {code: "ENOENT"});
  const getPathInfo = (cmd, opt) => {
    const colon = opt.colon || COLON;
    const pathEnv = cmd.match(/\//) || isWindows && cmd.match(/\\/) ? [""] : [
      ...isWindows ? [process.cwd()] : [],
      ...(opt.path || process.env.PATH || "").split(colon)
    ];
    const pathExtExe = isWindows ? opt.pathExt || process.env.PATHEXT || ".EXE;.CMD;.BAT;.COM" : "";
    const pathExt = isWindows ? pathExtExe.split(colon) : [""];
    if (isWindows) {
      if (cmd.indexOf(".") !== -1 && pathExt[0] !== "")
        pathExt.unshift("");
    }
    return {
      pathEnv,
      pathExt,
      pathExtExe
    };
  };
  const which = (cmd, opt, cb) => {
    if (typeof opt === "function") {
      cb = opt;
      opt = {};
    }
    if (!opt)
      opt = {};
    const {pathEnv, pathExt, pathExtExe} = getPathInfo(cmd, opt);
    const found = [];
    const step = (i) => new Promise((resolve, reject) => {
      if (i === pathEnv.length)
        return opt.all && found.length ? resolve(found) : reject(getNotFoundError(cmd));
      const ppRaw = pathEnv[i];
      const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
      const pCmd = path9.join(pathPart, cmd);
      const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
      resolve(subStep(p, i, 0));
    });
    const subStep = (p, i, ii) => new Promise((resolve, reject) => {
      if (ii === pathExt.length)
        return resolve(step(i + 1));
      const ext = pathExt[ii];
      isexe(p + ext, {pathExt: pathExtExe}, (er, is) => {
        if (!er && is) {
          if (opt.all)
            found.push(p + ext);
          else
            return resolve(p + ext);
        }
        return resolve(subStep(p, i, ii + 1));
      });
    });
    return cb ? step(0).then((res) => cb(null, res), cb) : step(0);
  };
  const whichSync = (cmd, opt) => {
    opt = opt || {};
    const {pathEnv, pathExt, pathExtExe} = getPathInfo(cmd, opt);
    const found = [];
    for (let i = 0; i < pathEnv.length; i++) {
      const ppRaw = pathEnv[i];
      const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
      const pCmd = path9.join(pathPart, cmd);
      const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
      for (let j = 0; j < pathExt.length; j++) {
        const cur = p + pathExt[j];
        try {
          const is = isexe.sync(cur, {pathExt: pathExtExe});
          if (is) {
            if (opt.all)
              found.push(cur);
            else
              return cur;
          }
        } catch (ex) {
        }
      }
    }
    if (opt.all && found.length)
      return found;
    if (opt.nothrow)
      return null;
    throw getNotFoundError(cmd);
  };
  module2.exports = which;
  which.sync = whichSync;
});

// ../../node_modules/.pnpm/path-key@3.1.1/node_modules/path-key/index.js
var require_path_key = __commonJS((exports2, module2) => {
  "use strict";
  const pathKey = (options = {}) => {
    const environment = options.env || process.env;
    const platform = options.platform || process.platform;
    if (platform !== "win32") {
      return "PATH";
    }
    return Object.keys(environment).reverse().find((key) => key.toUpperCase() === "PATH") || "Path";
  };
  module2.exports = pathKey;
  module2.exports.default = pathKey;
});

// ../../node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/lib/util/resolveCommand.js
var require_resolveCommand = __commonJS((exports2, module2) => {
  "use strict";
  const path9 = require("path");
  const which = require_which();
  const getPathKey = require_path_key();
  function resolveCommandAttempt(parsed, withoutPathExt) {
    const env = parsed.options.env || process.env;
    const cwd = process.cwd();
    const hasCustomCwd = parsed.options.cwd != null;
    const shouldSwitchCwd = hasCustomCwd && process.chdir !== void 0 && !process.chdir.disabled;
    if (shouldSwitchCwd) {
      try {
        process.chdir(parsed.options.cwd);
      } catch (err) {
      }
    }
    let resolved;
    try {
      resolved = which.sync(parsed.command, {
        path: env[getPathKey({env})],
        pathExt: withoutPathExt ? path9.delimiter : void 0
      });
    } catch (e) {
    } finally {
      if (shouldSwitchCwd) {
        process.chdir(cwd);
      }
    }
    if (resolved) {
      resolved = path9.resolve(hasCustomCwd ? parsed.options.cwd : "", resolved);
    }
    return resolved;
  }
  function resolveCommand(parsed) {
    return resolveCommandAttempt(parsed) || resolveCommandAttempt(parsed, true);
  }
  module2.exports = resolveCommand;
});

// ../../node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/lib/util/escape.js
var require_escape = __commonJS((exports2, module2) => {
  "use strict";
  const metaCharsRegExp = /([()\][%!^"`<>&|;, *?])/g;
  function escapeCommand(arg) {
    arg = arg.replace(metaCharsRegExp, "^$1");
    return arg;
  }
  function escapeArgument(arg, doubleEscapeMetaChars) {
    arg = `${arg}`;
    arg = arg.replace(/(\\*)"/g, '$1$1\\"');
    arg = arg.replace(/(\\*)$/, "$1$1");
    arg = `"${arg}"`;
    arg = arg.replace(metaCharsRegExp, "^$1");
    if (doubleEscapeMetaChars) {
      arg = arg.replace(metaCharsRegExp, "^$1");
    }
    return arg;
  }
  module2.exports.command = escapeCommand;
  module2.exports.argument = escapeArgument;
});

// ../../node_modules/.pnpm/shebang-regex@3.0.0/node_modules/shebang-regex/index.js
var require_shebang_regex = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = /^#!(.*)/;
});

// ../../node_modules/.pnpm/shebang-command@2.0.0/node_modules/shebang-command/index.js
var require_shebang_command = __commonJS((exports2, module2) => {
  "use strict";
  const shebangRegex = require_shebang_regex();
  module2.exports = (string = "") => {
    const match = string.match(shebangRegex);
    if (!match) {
      return null;
    }
    const [path9, argument] = match[0].replace(/#! ?/, "").split(" ");
    const binary = path9.split("/").pop();
    if (binary === "env") {
      return argument;
    }
    return argument ? `${binary} ${argument}` : binary;
  };
});

// ../../node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/lib/util/readShebang.js
var require_readShebang = __commonJS((exports2, module2) => {
  "use strict";
  const fs3 = require("fs");
  const shebangCommand = require_shebang_command();
  function readShebang(command) {
    const size = 150;
    const buffer = Buffer.alloc(size);
    let fd;
    try {
      fd = fs3.openSync(command, "r");
      fs3.readSync(fd, buffer, 0, size, 0);
      fs3.closeSync(fd);
    } catch (e) {
    }
    return shebangCommand(buffer.toString());
  }
  module2.exports = readShebang;
});

// ../../node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/lib/parse.js
var require_parse = __commonJS((exports2, module2) => {
  "use strict";
  const path9 = require("path");
  const resolveCommand = require_resolveCommand();
  const escape = require_escape();
  const readShebang = require_readShebang();
  const isWin = process.platform === "win32";
  const isExecutableRegExp = /\.(?:com|exe)$/i;
  const isCmdShimRegExp = /node_modules[\\/].bin[\\/][^\\/]+\.cmd$/i;
  function detectShebang(parsed) {
    parsed.file = resolveCommand(parsed);
    const shebang = parsed.file && readShebang(parsed.file);
    if (shebang) {
      parsed.args.unshift(parsed.file);
      parsed.command = shebang;
      return resolveCommand(parsed);
    }
    return parsed.file;
  }
  function parseNonShell(parsed) {
    if (!isWin) {
      return parsed;
    }
    const commandFile = detectShebang(parsed);
    const needsShell = !isExecutableRegExp.test(commandFile);
    if (parsed.options.forceShell || needsShell) {
      const needsDoubleEscapeMetaChars = isCmdShimRegExp.test(commandFile);
      parsed.command = path9.normalize(parsed.command);
      parsed.command = escape.command(parsed.command);
      parsed.args = parsed.args.map((arg) => escape.argument(arg, needsDoubleEscapeMetaChars));
      const shellCommand = [parsed.command].concat(parsed.args).join(" ");
      parsed.args = ["/d", "/s", "/c", `"${shellCommand}"`];
      parsed.command = process.env.comspec || "cmd.exe";
      parsed.options.windowsVerbatimArguments = true;
    }
    return parsed;
  }
  function parse(command, args, options) {
    if (args && !Array.isArray(args)) {
      options = args;
      args = null;
    }
    args = args ? args.slice(0) : [];
    options = Object.assign({}, options);
    const parsed = {
      command,
      args,
      options,
      file: void 0,
      original: {
        command,
        args
      }
    };
    return options.shell ? parsed : parseNonShell(parsed);
  }
  module2.exports = parse;
});

// ../../node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/lib/enoent.js
var require_enoent = __commonJS((exports2, module2) => {
  "use strict";
  const isWin = process.platform === "win32";
  function notFoundError(original, syscall) {
    return Object.assign(new Error(`${syscall} ${original.command} ENOENT`), {
      code: "ENOENT",
      errno: "ENOENT",
      syscall: `${syscall} ${original.command}`,
      path: original.command,
      spawnargs: original.args
    });
  }
  function hookChildProcess(cp, parsed) {
    if (!isWin) {
      return;
    }
    const originalEmit = cp.emit;
    cp.emit = function(name, arg1) {
      if (name === "exit") {
        const err = verifyENOENT(arg1, parsed, "spawn");
        if (err) {
          return originalEmit.call(cp, "error", err);
        }
      }
      return originalEmit.apply(cp, arguments);
    };
  }
  function verifyENOENT(status, parsed) {
    if (isWin && status === 1 && !parsed.file) {
      return notFoundError(parsed.original, "spawn");
    }
    return null;
  }
  function verifyENOENTSync(status, parsed) {
    if (isWin && status === 1 && !parsed.file) {
      return notFoundError(parsed.original, "spawnSync");
    }
    return null;
  }
  module2.exports = {
    hookChildProcess,
    verifyENOENT,
    verifyENOENTSync,
    notFoundError
  };
});

// ../../node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/index.js
var require_cross_spawn = __commonJS((exports2, module2) => {
  "use strict";
  const cp = require("child_process");
  const parse = require_parse();
  const enoent = require_enoent();
  function spawn(command, args, options) {
    const parsed = parse(command, args, options);
    const spawned = cp.spawn(parsed.command, parsed.args, parsed.options);
    enoent.hookChildProcess(spawned, parsed);
    return spawned;
  }
  function spawnSync(command, args, options) {
    const parsed = parse(command, args, options);
    const result = cp.spawnSync(parsed.command, parsed.args, parsed.options);
    result.error = result.error || enoent.verifyENOENTSync(result.status, parsed);
    return result;
  }
  module2.exports = spawn;
  module2.exports.spawn = spawn;
  module2.exports.sync = spawnSync;
  module2.exports._parse = parse;
  module2.exports._enoent = enoent;
});

// ../generator-helper/dist/byline.js
var require_byline = __commonJS((exports2, module2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.createLineStream = void 0;
  const stream = require("stream");
  const util2 = require("util");
  function byline(readStream, options) {
    return module2.exports.createStream(readStream, options);
  }
  exports2.default = byline;
  module2.exports.createStream = function(readStream, options) {
    if (readStream) {
      return createLineStream(readStream, options);
    } else {
      return new LineStream(options);
    }
  };
  function createLineStream(readStream, options) {
    if (!readStream) {
      throw new Error("expected readStream");
    }
    if (!readStream.readable) {
      throw new Error("readStream must be readable");
    }
    const ls = new LineStream(options);
    readStream.pipe(ls);
    return ls;
  }
  exports2.createLineStream = createLineStream;
  module2.exports.LineStream = LineStream;
  function LineStream(options) {
    stream.Transform.call(this, options);
    options = options || {};
    this._readableState.objectMode = true;
    this._lineBuffer = [];
    this._keepEmptyLines = options.keepEmptyLines || false;
    this._lastChunkEndedWithCR = false;
    this.on("pipe", function(src) {
      if (!this.encoding) {
        if (src instanceof stream.Readable) {
          this.encoding = src._readableState.encoding;
        }
      }
    });
  }
  util2.inherits(LineStream, stream.Transform);
  LineStream.prototype._transform = function(chunk, encoding, done) {
    encoding = encoding || "utf8";
    if (Buffer.isBuffer(chunk)) {
      if (encoding == "buffer") {
        chunk = chunk.toString();
        encoding = "utf8";
      } else {
        chunk = chunk.toString(encoding);
      }
    }
    this._chunkEncoding = encoding;
    const lines = chunk.split(/\r\n|\r|\n/g);
    if (this._lastChunkEndedWithCR && chunk[0] == "\n") {
      lines.shift();
    }
    if (this._lineBuffer.length > 0) {
      this._lineBuffer[this._lineBuffer.length - 1] += lines[0];
      lines.shift();
    }
    this._lastChunkEndedWithCR = chunk[chunk.length - 1] == "\r";
    this._lineBuffer = this._lineBuffer.concat(lines);
    this._pushBuffer(encoding, 1, done);
  };
  LineStream.prototype._pushBuffer = function(encoding, keep, done) {
    while (this._lineBuffer.length > keep) {
      const line = this._lineBuffer.shift();
      if (this._keepEmptyLines || line.length > 0) {
        if (!this.push(this._reencode(line, encoding))) {
          const self = this;
          setImmediate(function() {
            self._pushBuffer(encoding, keep, done);
          });
          return;
        }
      }
    }
    done();
  };
  LineStream.prototype._flush = function(done) {
    this._pushBuffer(this._chunkEncoding, 0, done);
  };
  LineStream.prototype._reencode = function(line, chunkEncoding) {
    if (this.encoding && this.encoding != chunkEncoding) {
      return Buffer.from(line, chunkEncoding).toString(this.encoding);
    } else if (this.encoding) {
      return line;
    } else {
      return Buffer.from(line, chunkEncoding);
    }
  };
});

// ../../node_modules/.pnpm/color-name@1.1.4/node_modules/color-name/index.js
var require_color_name = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    aliceblue: [240, 248, 255],
    antiquewhite: [250, 235, 215],
    aqua: [0, 255, 255],
    aquamarine: [127, 255, 212],
    azure: [240, 255, 255],
    beige: [245, 245, 220],
    bisque: [255, 228, 196],
    black: [0, 0, 0],
    blanchedalmond: [255, 235, 205],
    blue: [0, 0, 255],
    blueviolet: [138, 43, 226],
    brown: [165, 42, 42],
    burlywood: [222, 184, 135],
    cadetblue: [95, 158, 160],
    chartreuse: [127, 255, 0],
    chocolate: [210, 105, 30],
    coral: [255, 127, 80],
    cornflowerblue: [100, 149, 237],
    cornsilk: [255, 248, 220],
    crimson: [220, 20, 60],
    cyan: [0, 255, 255],
    darkblue: [0, 0, 139],
    darkcyan: [0, 139, 139],
    darkgoldenrod: [184, 134, 11],
    darkgray: [169, 169, 169],
    darkgreen: [0, 100, 0],
    darkgrey: [169, 169, 169],
    darkkhaki: [189, 183, 107],
    darkmagenta: [139, 0, 139],
    darkolivegreen: [85, 107, 47],
    darkorange: [255, 140, 0],
    darkorchid: [153, 50, 204],
    darkred: [139, 0, 0],
    darksalmon: [233, 150, 122],
    darkseagreen: [143, 188, 143],
    darkslateblue: [72, 61, 139],
    darkslategray: [47, 79, 79],
    darkslategrey: [47, 79, 79],
    darkturquoise: [0, 206, 209],
    darkviolet: [148, 0, 211],
    deeppink: [255, 20, 147],
    deepskyblue: [0, 191, 255],
    dimgray: [105, 105, 105],
    dimgrey: [105, 105, 105],
    dodgerblue: [30, 144, 255],
    firebrick: [178, 34, 34],
    floralwhite: [255, 250, 240],
    forestgreen: [34, 139, 34],
    fuchsia: [255, 0, 255],
    gainsboro: [220, 220, 220],
    ghostwhite: [248, 248, 255],
    gold: [255, 215, 0],
    goldenrod: [218, 165, 32],
    gray: [128, 128, 128],
    green: [0, 128, 0],
    greenyellow: [173, 255, 47],
    grey: [128, 128, 128],
    honeydew: [240, 255, 240],
    hotpink: [255, 105, 180],
    indianred: [205, 92, 92],
    indigo: [75, 0, 130],
    ivory: [255, 255, 240],
    khaki: [240, 230, 140],
    lavender: [230, 230, 250],
    lavenderblush: [255, 240, 245],
    lawngreen: [124, 252, 0],
    lemonchiffon: [255, 250, 205],
    lightblue: [173, 216, 230],
    lightcoral: [240, 128, 128],
    lightcyan: [224, 255, 255],
    lightgoldenrodyellow: [250, 250, 210],
    lightgray: [211, 211, 211],
    lightgreen: [144, 238, 144],
    lightgrey: [211, 211, 211],
    lightpink: [255, 182, 193],
    lightsalmon: [255, 160, 122],
    lightseagreen: [32, 178, 170],
    lightskyblue: [135, 206, 250],
    lightslategray: [119, 136, 153],
    lightslategrey: [119, 136, 153],
    lightsteelblue: [176, 196, 222],
    lightyellow: [255, 255, 224],
    lime: [0, 255, 0],
    limegreen: [50, 205, 50],
    linen: [250, 240, 230],
    magenta: [255, 0, 255],
    maroon: [128, 0, 0],
    mediumaquamarine: [102, 205, 170],
    mediumblue: [0, 0, 205],
    mediumorchid: [186, 85, 211],
    mediumpurple: [147, 112, 219],
    mediumseagreen: [60, 179, 113],
    mediumslateblue: [123, 104, 238],
    mediumspringgreen: [0, 250, 154],
    mediumturquoise: [72, 209, 204],
    mediumvioletred: [199, 21, 133],
    midnightblue: [25, 25, 112],
    mintcream: [245, 255, 250],
    mistyrose: [255, 228, 225],
    moccasin: [255, 228, 181],
    navajowhite: [255, 222, 173],
    navy: [0, 0, 128],
    oldlace: [253, 245, 230],
    olive: [128, 128, 0],
    olivedrab: [107, 142, 35],
    orange: [255, 165, 0],
    orangered: [255, 69, 0],
    orchid: [218, 112, 214],
    palegoldenrod: [238, 232, 170],
    palegreen: [152, 251, 152],
    paleturquoise: [175, 238, 238],
    palevioletred: [219, 112, 147],
    papayawhip: [255, 239, 213],
    peachpuff: [255, 218, 185],
    peru: [205, 133, 63],
    pink: [255, 192, 203],
    plum: [221, 160, 221],
    powderblue: [176, 224, 230],
    purple: [128, 0, 128],
    rebeccapurple: [102, 51, 153],
    red: [255, 0, 0],
    rosybrown: [188, 143, 143],
    royalblue: [65, 105, 225],
    saddlebrown: [139, 69, 19],
    salmon: [250, 128, 114],
    sandybrown: [244, 164, 96],
    seagreen: [46, 139, 87],
    seashell: [255, 245, 238],
    sienna: [160, 82, 45],
    silver: [192, 192, 192],
    skyblue: [135, 206, 235],
    slateblue: [106, 90, 205],
    slategray: [112, 128, 144],
    slategrey: [112, 128, 144],
    snow: [255, 250, 250],
    springgreen: [0, 255, 127],
    steelblue: [70, 130, 180],
    tan: [210, 180, 140],
    teal: [0, 128, 128],
    thistle: [216, 191, 216],
    tomato: [255, 99, 71],
    turquoise: [64, 224, 208],
    violet: [238, 130, 238],
    wheat: [245, 222, 179],
    white: [255, 255, 255],
    whitesmoke: [245, 245, 245],
    yellow: [255, 255, 0],
    yellowgreen: [154, 205, 50]
  };
});

// ../../node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/conversions.js
var require_conversions = __commonJS((exports2, module2) => {
  const cssKeywords = require_color_name();
  const reverseKeywords = {};
  for (const key of Object.keys(cssKeywords)) {
    reverseKeywords[cssKeywords[key]] = key;
  }
  const convert = {
    rgb: {channels: 3, labels: "rgb"},
    hsl: {channels: 3, labels: "hsl"},
    hsv: {channels: 3, labels: "hsv"},
    hwb: {channels: 3, labels: "hwb"},
    cmyk: {channels: 4, labels: "cmyk"},
    xyz: {channels: 3, labels: "xyz"},
    lab: {channels: 3, labels: "lab"},
    lch: {channels: 3, labels: "lch"},
    hex: {channels: 1, labels: ["hex"]},
    keyword: {channels: 1, labels: ["keyword"]},
    ansi16: {channels: 1, labels: ["ansi16"]},
    ansi256: {channels: 1, labels: ["ansi256"]},
    hcg: {channels: 3, labels: ["h", "c", "g"]},
    apple: {channels: 3, labels: ["r16", "g16", "b16"]},
    gray: {channels: 1, labels: ["gray"]}
  };
  module2.exports = convert;
  for (const model of Object.keys(convert)) {
    if (!("channels" in convert[model])) {
      throw new Error("missing channels property: " + model);
    }
    if (!("labels" in convert[model])) {
      throw new Error("missing channel labels property: " + model);
    }
    if (convert[model].labels.length !== convert[model].channels) {
      throw new Error("channel and label counts mismatch: " + model);
    }
    const {channels, labels} = convert[model];
    delete convert[model].channels;
    delete convert[model].labels;
    Object.defineProperty(convert[model], "channels", {value: channels});
    Object.defineProperty(convert[model], "labels", {value: labels});
  }
  convert.rgb.hsl = function(rgb) {
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const min = Math.min(r, g, b);
    const max = Math.max(r, g, b);
    const delta = max - min;
    let h;
    let s;
    if (max === min) {
      h = 0;
    } else if (r === max) {
      h = (g - b) / delta;
    } else if (g === max) {
      h = 2 + (b - r) / delta;
    } else if (b === max) {
      h = 4 + (r - g) / delta;
    }
    h = Math.min(h * 60, 360);
    if (h < 0) {
      h += 360;
    }
    const l = (min + max) / 2;
    if (max === min) {
      s = 0;
    } else if (l <= 0.5) {
      s = delta / (max + min);
    } else {
      s = delta / (2 - max - min);
    }
    return [h, s * 100, l * 100];
  };
  convert.rgb.hsv = function(rgb) {
    let rdif;
    let gdif;
    let bdif;
    let h;
    let s;
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const v = Math.max(r, g, b);
    const diff = v - Math.min(r, g, b);
    const diffc = function(c) {
      return (v - c) / 6 / diff + 1 / 2;
    };
    if (diff === 0) {
      h = 0;
      s = 0;
    } else {
      s = diff / v;
      rdif = diffc(r);
      gdif = diffc(g);
      bdif = diffc(b);
      if (r === v) {
        h = bdif - gdif;
      } else if (g === v) {
        h = 1 / 3 + rdif - bdif;
      } else if (b === v) {
        h = 2 / 3 + gdif - rdif;
      }
      if (h < 0) {
        h += 1;
      } else if (h > 1) {
        h -= 1;
      }
    }
    return [
      h * 360,
      s * 100,
      v * 100
    ];
  };
  convert.rgb.hwb = function(rgb) {
    const r = rgb[0];
    const g = rgb[1];
    let b = rgb[2];
    const h = convert.rgb.hsl(rgb)[0];
    const w = 1 / 255 * Math.min(r, Math.min(g, b));
    b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
    return [h, w * 100, b * 100];
  };
  convert.rgb.cmyk = function(rgb) {
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const k = Math.min(1 - r, 1 - g, 1 - b);
    const c = (1 - r - k) / (1 - k) || 0;
    const m = (1 - g - k) / (1 - k) || 0;
    const y = (1 - b - k) / (1 - k) || 0;
    return [c * 100, m * 100, y * 100, k * 100];
  };
  function comparativeDistance(x, y) {
    return (x[0] - y[0]) ** 2 + (x[1] - y[1]) ** 2 + (x[2] - y[2]) ** 2;
  }
  convert.rgb.keyword = function(rgb) {
    const reversed = reverseKeywords[rgb];
    if (reversed) {
      return reversed;
    }
    let currentClosestDistance = Infinity;
    let currentClosestKeyword;
    for (const keyword of Object.keys(cssKeywords)) {
      const value = cssKeywords[keyword];
      const distance = comparativeDistance(rgb, value);
      if (distance < currentClosestDistance) {
        currentClosestDistance = distance;
        currentClosestKeyword = keyword;
      }
    }
    return currentClosestKeyword;
  };
  convert.keyword.rgb = function(keyword) {
    return cssKeywords[keyword];
  };
  convert.rgb.xyz = function(rgb) {
    let r = rgb[0] / 255;
    let g = rgb[1] / 255;
    let b = rgb[2] / 255;
    r = r > 0.04045 ? ((r + 0.055) / 1.055) ** 2.4 : r / 12.92;
    g = g > 0.04045 ? ((g + 0.055) / 1.055) ** 2.4 : g / 12.92;
    b = b > 0.04045 ? ((b + 0.055) / 1.055) ** 2.4 : b / 12.92;
    const x = r * 0.4124 + g * 0.3576 + b * 0.1805;
    const y = r * 0.2126 + g * 0.7152 + b * 0.0722;
    const z = r * 0.0193 + g * 0.1192 + b * 0.9505;
    return [x * 100, y * 100, z * 100];
  };
  convert.rgb.lab = function(rgb) {
    const xyz = convert.rgb.xyz(rgb);
    let x = xyz[0];
    let y = xyz[1];
    let z = xyz[2];
    x /= 95.047;
    y /= 100;
    z /= 108.883;
    x = x > 8856e-6 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
    y = y > 8856e-6 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
    z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
    const l = 116 * y - 16;
    const a = 500 * (x - y);
    const b = 200 * (y - z);
    return [l, a, b];
  };
  convert.hsl.rgb = function(hsl) {
    const h = hsl[0] / 360;
    const s = hsl[1] / 100;
    const l = hsl[2] / 100;
    let t2;
    let t3;
    let val;
    if (s === 0) {
      val = l * 255;
      return [val, val, val];
    }
    if (l < 0.5) {
      t2 = l * (1 + s);
    } else {
      t2 = l + s - l * s;
    }
    const t1 = 2 * l - t2;
    const rgb = [0, 0, 0];
    for (let i = 0; i < 3; i++) {
      t3 = h + 1 / 3 * -(i - 1);
      if (t3 < 0) {
        t3++;
      }
      if (t3 > 1) {
        t3--;
      }
      if (6 * t3 < 1) {
        val = t1 + (t2 - t1) * 6 * t3;
      } else if (2 * t3 < 1) {
        val = t2;
      } else if (3 * t3 < 2) {
        val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
      } else {
        val = t1;
      }
      rgb[i] = val * 255;
    }
    return rgb;
  };
  convert.hsl.hsv = function(hsl) {
    const h = hsl[0];
    let s = hsl[1] / 100;
    let l = hsl[2] / 100;
    let smin = s;
    const lmin = Math.max(l, 0.01);
    l *= 2;
    s *= l <= 1 ? l : 2 - l;
    smin *= lmin <= 1 ? lmin : 2 - lmin;
    const v = (l + s) / 2;
    const sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
    return [h, sv * 100, v * 100];
  };
  convert.hsv.rgb = function(hsv) {
    const h = hsv[0] / 60;
    const s = hsv[1] / 100;
    let v = hsv[2] / 100;
    const hi = Math.floor(h) % 6;
    const f = h - Math.floor(h);
    const p = 255 * v * (1 - s);
    const q = 255 * v * (1 - s * f);
    const t = 255 * v * (1 - s * (1 - f));
    v *= 255;
    switch (hi) {
      case 0:
        return [v, t, p];
      case 1:
        return [q, v, p];
      case 2:
        return [p, v, t];
      case 3:
        return [p, q, v];
      case 4:
        return [t, p, v];
      case 5:
        return [v, p, q];
    }
  };
  convert.hsv.hsl = function(hsv) {
    const h = hsv[0];
    const s = hsv[1] / 100;
    const v = hsv[2] / 100;
    const vmin = Math.max(v, 0.01);
    let sl;
    let l;
    l = (2 - s) * v;
    const lmin = (2 - s) * vmin;
    sl = s * vmin;
    sl /= lmin <= 1 ? lmin : 2 - lmin;
    sl = sl || 0;
    l /= 2;
    return [h, sl * 100, l * 100];
  };
  convert.hwb.rgb = function(hwb) {
    const h = hwb[0] / 360;
    let wh = hwb[1] / 100;
    let bl = hwb[2] / 100;
    const ratio = wh + bl;
    let f;
    if (ratio > 1) {
      wh /= ratio;
      bl /= ratio;
    }
    const i = Math.floor(6 * h);
    const v = 1 - bl;
    f = 6 * h - i;
    if ((i & 1) !== 0) {
      f = 1 - f;
    }
    const n = wh + f * (v - wh);
    let r;
    let g;
    let b;
    switch (i) {
      default:
      case 6:
      case 0:
        r = v;
        g = n;
        b = wh;
        break;
      case 1:
        r = n;
        g = v;
        b = wh;
        break;
      case 2:
        r = wh;
        g = v;
        b = n;
        break;
      case 3:
        r = wh;
        g = n;
        b = v;
        break;
      case 4:
        r = n;
        g = wh;
        b = v;
        break;
      case 5:
        r = v;
        g = wh;
        b = n;
        break;
    }
    return [r * 255, g * 255, b * 255];
  };
  convert.cmyk.rgb = function(cmyk) {
    const c = cmyk[0] / 100;
    const m = cmyk[1] / 100;
    const y = cmyk[2] / 100;
    const k = cmyk[3] / 100;
    const r = 1 - Math.min(1, c * (1 - k) + k);
    const g = 1 - Math.min(1, m * (1 - k) + k);
    const b = 1 - Math.min(1, y * (1 - k) + k);
    return [r * 255, g * 255, b * 255];
  };
  convert.xyz.rgb = function(xyz) {
    const x = xyz[0] / 100;
    const y = xyz[1] / 100;
    const z = xyz[2] / 100;
    let r;
    let g;
    let b;
    r = x * 3.2406 + y * -1.5372 + z * -0.4986;
    g = x * -0.9689 + y * 1.8758 + z * 0.0415;
    b = x * 0.0557 + y * -0.204 + z * 1.057;
    r = r > 31308e-7 ? 1.055 * r ** (1 / 2.4) - 0.055 : r * 12.92;
    g = g > 31308e-7 ? 1.055 * g ** (1 / 2.4) - 0.055 : g * 12.92;
    b = b > 31308e-7 ? 1.055 * b ** (1 / 2.4) - 0.055 : b * 12.92;
    r = Math.min(Math.max(0, r), 1);
    g = Math.min(Math.max(0, g), 1);
    b = Math.min(Math.max(0, b), 1);
    return [r * 255, g * 255, b * 255];
  };
  convert.xyz.lab = function(xyz) {
    let x = xyz[0];
    let y = xyz[1];
    let z = xyz[2];
    x /= 95.047;
    y /= 100;
    z /= 108.883;
    x = x > 8856e-6 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
    y = y > 8856e-6 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
    z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
    const l = 116 * y - 16;
    const a = 500 * (x - y);
    const b = 200 * (y - z);
    return [l, a, b];
  };
  convert.lab.xyz = function(lab) {
    const l = lab[0];
    const a = lab[1];
    const b = lab[2];
    let x;
    let y;
    let z;
    y = (l + 16) / 116;
    x = a / 500 + y;
    z = y - b / 200;
    const y2 = y ** 3;
    const x2 = x ** 3;
    const z2 = z ** 3;
    y = y2 > 8856e-6 ? y2 : (y - 16 / 116) / 7.787;
    x = x2 > 8856e-6 ? x2 : (x - 16 / 116) / 7.787;
    z = z2 > 8856e-6 ? z2 : (z - 16 / 116) / 7.787;
    x *= 95.047;
    y *= 100;
    z *= 108.883;
    return [x, y, z];
  };
  convert.lab.lch = function(lab) {
    const l = lab[0];
    const a = lab[1];
    const b = lab[2];
    let h;
    const hr = Math.atan2(b, a);
    h = hr * 360 / 2 / Math.PI;
    if (h < 0) {
      h += 360;
    }
    const c = Math.sqrt(a * a + b * b);
    return [l, c, h];
  };
  convert.lch.lab = function(lch) {
    const l = lch[0];
    const c = lch[1];
    const h = lch[2];
    const hr = h / 360 * 2 * Math.PI;
    const a = c * Math.cos(hr);
    const b = c * Math.sin(hr);
    return [l, a, b];
  };
  convert.rgb.ansi16 = function(args, saturation = null) {
    const [r, g, b] = args;
    let value = saturation === null ? convert.rgb.hsv(args)[2] : saturation;
    value = Math.round(value / 50);
    if (value === 0) {
      return 30;
    }
    let ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
    if (value === 2) {
      ansi += 60;
    }
    return ansi;
  };
  convert.hsv.ansi16 = function(args) {
    return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
  };
  convert.rgb.ansi256 = function(args) {
    const r = args[0];
    const g = args[1];
    const b = args[2];
    if (r === g && g === b) {
      if (r < 8) {
        return 16;
      }
      if (r > 248) {
        return 231;
      }
      return Math.round((r - 8) / 247 * 24) + 232;
    }
    const ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
    return ansi;
  };
  convert.ansi16.rgb = function(args) {
    let color = args % 10;
    if (color === 0 || color === 7) {
      if (args > 50) {
        color += 3.5;
      }
      color = color / 10.5 * 255;
      return [color, color, color];
    }
    const mult = (~~(args > 50) + 1) * 0.5;
    const r = (color & 1) * mult * 255;
    const g = (color >> 1 & 1) * mult * 255;
    const b = (color >> 2 & 1) * mult * 255;
    return [r, g, b];
  };
  convert.ansi256.rgb = function(args) {
    if (args >= 232) {
      const c = (args - 232) * 10 + 8;
      return [c, c, c];
    }
    args -= 16;
    let rem;
    const r = Math.floor(args / 36) / 5 * 255;
    const g = Math.floor((rem = args % 36) / 6) / 5 * 255;
    const b = rem % 6 / 5 * 255;
    return [r, g, b];
  };
  convert.rgb.hex = function(args) {
    const integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
    const string = integer.toString(16).toUpperCase();
    return "000000".substring(string.length) + string;
  };
  convert.hex.rgb = function(args) {
    const match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
    if (!match) {
      return [0, 0, 0];
    }
    let colorString = match[0];
    if (match[0].length === 3) {
      colorString = colorString.split("").map((char) => {
        return char + char;
      }).join("");
    }
    const integer = parseInt(colorString, 16);
    const r = integer >> 16 & 255;
    const g = integer >> 8 & 255;
    const b = integer & 255;
    return [r, g, b];
  };
  convert.rgb.hcg = function(rgb) {
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const max = Math.max(Math.max(r, g), b);
    const min = Math.min(Math.min(r, g), b);
    const chroma = max - min;
    let grayscale;
    let hue;
    if (chroma < 1) {
      grayscale = min / (1 - chroma);
    } else {
      grayscale = 0;
    }
    if (chroma <= 0) {
      hue = 0;
    } else if (max === r) {
      hue = (g - b) / chroma % 6;
    } else if (max === g) {
      hue = 2 + (b - r) / chroma;
    } else {
      hue = 4 + (r - g) / chroma;
    }
    hue /= 6;
    hue %= 1;
    return [hue * 360, chroma * 100, grayscale * 100];
  };
  convert.hsl.hcg = function(hsl) {
    const s = hsl[1] / 100;
    const l = hsl[2] / 100;
    const c = l < 0.5 ? 2 * s * l : 2 * s * (1 - l);
    let f = 0;
    if (c < 1) {
      f = (l - 0.5 * c) / (1 - c);
    }
    return [hsl[0], c * 100, f * 100];
  };
  convert.hsv.hcg = function(hsv) {
    const s = hsv[1] / 100;
    const v = hsv[2] / 100;
    const c = s * v;
    let f = 0;
    if (c < 1) {
      f = (v - c) / (1 - c);
    }
    return [hsv[0], c * 100, f * 100];
  };
  convert.hcg.rgb = function(hcg) {
    const h = hcg[0] / 360;
    const c = hcg[1] / 100;
    const g = hcg[2] / 100;
    if (c === 0) {
      return [g * 255, g * 255, g * 255];
    }
    const pure = [0, 0, 0];
    const hi = h % 1 * 6;
    const v = hi % 1;
    const w = 1 - v;
    let mg = 0;
    switch (Math.floor(hi)) {
      case 0:
        pure[0] = 1;
        pure[1] = v;
        pure[2] = 0;
        break;
      case 1:
        pure[0] = w;
        pure[1] = 1;
        pure[2] = 0;
        break;
      case 2:
        pure[0] = 0;
        pure[1] = 1;
        pure[2] = v;
        break;
      case 3:
        pure[0] = 0;
        pure[1] = w;
        pure[2] = 1;
        break;
      case 4:
        pure[0] = v;
        pure[1] = 0;
        pure[2] = 1;
        break;
      default:
        pure[0] = 1;
        pure[1] = 0;
        pure[2] = w;
    }
    mg = (1 - c) * g;
    return [
      (c * pure[0] + mg) * 255,
      (c * pure[1] + mg) * 255,
      (c * pure[2] + mg) * 255
    ];
  };
  convert.hcg.hsv = function(hcg) {
    const c = hcg[1] / 100;
    const g = hcg[2] / 100;
    const v = c + g * (1 - c);
    let f = 0;
    if (v > 0) {
      f = c / v;
    }
    return [hcg[0], f * 100, v * 100];
  };
  convert.hcg.hsl = function(hcg) {
    const c = hcg[1] / 100;
    const g = hcg[2] / 100;
    const l = g * (1 - c) + 0.5 * c;
    let s = 0;
    if (l > 0 && l < 0.5) {
      s = c / (2 * l);
    } else if (l >= 0.5 && l < 1) {
      s = c / (2 * (1 - l));
    }
    return [hcg[0], s * 100, l * 100];
  };
  convert.hcg.hwb = function(hcg) {
    const c = hcg[1] / 100;
    const g = hcg[2] / 100;
    const v = c + g * (1 - c);
    return [hcg[0], (v - c) * 100, (1 - v) * 100];
  };
  convert.hwb.hcg = function(hwb) {
    const w = hwb[1] / 100;
    const b = hwb[2] / 100;
    const v = 1 - b;
    const c = v - w;
    let g = 0;
    if (c < 1) {
      g = (v - c) / (1 - c);
    }
    return [hwb[0], c * 100, g * 100];
  };
  convert.apple.rgb = function(apple) {
    return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
  };
  convert.rgb.apple = function(rgb) {
    return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
  };
  convert.gray.rgb = function(args) {
    return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
  };
  convert.gray.hsl = function(args) {
    return [0, 0, args[0]];
  };
  convert.gray.hsv = convert.gray.hsl;
  convert.gray.hwb = function(gray) {
    return [0, 100, gray[0]];
  };
  convert.gray.cmyk = function(gray) {
    return [0, 0, 0, gray[0]];
  };
  convert.gray.lab = function(gray) {
    return [gray[0], 0, 0];
  };
  convert.gray.hex = function(gray) {
    const val = Math.round(gray[0] / 100 * 255) & 255;
    const integer = (val << 16) + (val << 8) + val;
    const string = integer.toString(16).toUpperCase();
    return "000000".substring(string.length) + string;
  };
  convert.rgb.gray = function(rgb) {
    const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
    return [val / 255 * 100];
  };
});

// ../../node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/route.js
var require_route = __commonJS((exports2, module2) => {
  const conversions = require_conversions();
  function buildGraph() {
    const graph = {};
    const models = Object.keys(conversions);
    for (let len = models.length, i = 0; i < len; i++) {
      graph[models[i]] = {
        distance: -1,
        parent: null
      };
    }
    return graph;
  }
  function deriveBFS(fromModel) {
    const graph = buildGraph();
    const queue = [fromModel];
    graph[fromModel].distance = 0;
    while (queue.length) {
      const current = queue.pop();
      const adjacents = Object.keys(conversions[current]);
      for (let len = adjacents.length, i = 0; i < len; i++) {
        const adjacent = adjacents[i];
        const node = graph[adjacent];
        if (node.distance === -1) {
          node.distance = graph[current].distance + 1;
          node.parent = current;
          queue.unshift(adjacent);
        }
      }
    }
    return graph;
  }
  function link(from, to) {
    return function(args) {
      return to(from(args));
    };
  }
  function wrapConversion(toModel, graph) {
    const path9 = [graph[toModel].parent, toModel];
    let fn = conversions[graph[toModel].parent][toModel];
    let cur = graph[toModel].parent;
    while (graph[cur].parent) {
      path9.unshift(graph[cur].parent);
      fn = link(conversions[graph[cur].parent][cur], fn);
      cur = graph[cur].parent;
    }
    fn.conversion = path9;
    return fn;
  }
  module2.exports = function(fromModel) {
    const graph = deriveBFS(fromModel);
    const conversion = {};
    const models = Object.keys(graph);
    for (let len = models.length, i = 0; i < len; i++) {
      const toModel = models[i];
      const node = graph[toModel];
      if (node.parent === null) {
        continue;
      }
      conversion[toModel] = wrapConversion(toModel, graph);
    }
    return conversion;
  };
});

// ../../node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/index.js
var require_color_convert = __commonJS((exports2, module2) => {
  const conversions = require_conversions();
  const route = require_route();
  const convert = {};
  const models = Object.keys(conversions);
  function wrapRaw(fn) {
    const wrappedFn = function(...args) {
      const arg0 = args[0];
      if (arg0 === void 0 || arg0 === null) {
        return arg0;
      }
      if (arg0.length > 1) {
        args = arg0;
      }
      return fn(args);
    };
    if ("conversion" in fn) {
      wrappedFn.conversion = fn.conversion;
    }
    return wrappedFn;
  }
  function wrapRounded(fn) {
    const wrappedFn = function(...args) {
      const arg0 = args[0];
      if (arg0 === void 0 || arg0 === null) {
        return arg0;
      }
      if (arg0.length > 1) {
        args = arg0;
      }
      const result = fn(args);
      if (typeof result === "object") {
        for (let len = result.length, i = 0; i < len; i++) {
          result[i] = Math.round(result[i]);
        }
      }
      return result;
    };
    if ("conversion" in fn) {
      wrappedFn.conversion = fn.conversion;
    }
    return wrappedFn;
  }
  models.forEach((fromModel) => {
    convert[fromModel] = {};
    Object.defineProperty(convert[fromModel], "channels", {value: conversions[fromModel].channels});
    Object.defineProperty(convert[fromModel], "labels", {value: conversions[fromModel].labels});
    const routes = route(fromModel);
    const routeModels = Object.keys(routes);
    routeModels.forEach((toModel) => {
      const fn = routes[toModel];
      convert[fromModel][toModel] = wrapRounded(fn);
      convert[fromModel][toModel].raw = wrapRaw(fn);
    });
  });
  module2.exports = convert;
});

// ../../node_modules/.pnpm/ansi-styles@4.2.1/node_modules/ansi-styles/index.js
var require_ansi_styles = __commonJS((exports2, module2) => {
  "use strict";
  const wrapAnsi16 = (fn, offset) => (...args) => {
    const code = fn(...args);
    return `[${code + offset}m`;
  };
  const wrapAnsi256 = (fn, offset) => (...args) => {
    const code = fn(...args);
    return `[${38 + offset};5;${code}m`;
  };
  const wrapAnsi16m = (fn, offset) => (...args) => {
    const rgb = fn(...args);
    return `[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
  };
  const ansi2ansi = (n) => n;
  const rgb2rgb = (r, g, b) => [r, g, b];
  const setLazyProperty = (object, property, get) => {
    Object.defineProperty(object, property, {
      get: () => {
        const value = get();
        Object.defineProperty(object, property, {
          value,
          enumerable: true,
          configurable: true
        });
        return value;
      },
      enumerable: true,
      configurable: true
    });
  };
  let colorConvert;
  const makeDynamicStyles = (wrap, targetSpace, identity, isBackground) => {
    if (colorConvert === void 0) {
      colorConvert = require_color_convert();
    }
    const offset = isBackground ? 10 : 0;
    const styles = {};
    for (const [sourceSpace, suite] of Object.entries(colorConvert)) {
      const name = sourceSpace === "ansi16" ? "ansi" : sourceSpace;
      if (sourceSpace === targetSpace) {
        styles[name] = wrap(identity, offset);
      } else if (typeof suite === "object") {
        styles[name] = wrap(suite[targetSpace], offset);
      }
    }
    return styles;
  };
  function assembleStyles() {
    const codes = new Map();
    const styles = {
      modifier: {
        reset: [0, 0],
        bold: [1, 22],
        dim: [2, 22],
        italic: [3, 23],
        underline: [4, 24],
        inverse: [7, 27],
        hidden: [8, 28],
        strikethrough: [9, 29]
      },
      color: {
        black: [30, 39],
        red: [31, 39],
        green: [32, 39],
        yellow: [33, 39],
        blue: [34, 39],
        magenta: [35, 39],
        cyan: [36, 39],
        white: [37, 39],
        blackBright: [90, 39],
        redBright: [91, 39],
        greenBright: [92, 39],
        yellowBright: [93, 39],
        blueBright: [94, 39],
        magentaBright: [95, 39],
        cyanBright: [96, 39],
        whiteBright: [97, 39]
      },
      bgColor: {
        bgBlack: [40, 49],
        bgRed: [41, 49],
        bgGreen: [42, 49],
        bgYellow: [43, 49],
        bgBlue: [44, 49],
        bgMagenta: [45, 49],
        bgCyan: [46, 49],
        bgWhite: [47, 49],
        bgBlackBright: [100, 49],
        bgRedBright: [101, 49],
        bgGreenBright: [102, 49],
        bgYellowBright: [103, 49],
        bgBlueBright: [104, 49],
        bgMagentaBright: [105, 49],
        bgCyanBright: [106, 49],
        bgWhiteBright: [107, 49]
      }
    };
    styles.color.gray = styles.color.blackBright;
    styles.bgColor.bgGray = styles.bgColor.bgBlackBright;
    styles.color.grey = styles.color.blackBright;
    styles.bgColor.bgGrey = styles.bgColor.bgBlackBright;
    for (const [groupName, group] of Object.entries(styles)) {
      for (const [styleName, style] of Object.entries(group)) {
        styles[styleName] = {
          open: `[${style[0]}m`,
          close: `[${style[1]}m`
        };
        group[styleName] = styles[styleName];
        codes.set(style[0], style[1]);
      }
      Object.defineProperty(styles, groupName, {
        value: group,
        enumerable: false
      });
    }
    Object.defineProperty(styles, "codes", {
      value: codes,
      enumerable: false
    });
    styles.color.close = "[39m";
    styles.bgColor.close = "[49m";
    setLazyProperty(styles.color, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, false));
    setLazyProperty(styles.color, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, false));
    setLazyProperty(styles.color, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, false));
    setLazyProperty(styles.bgColor, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, true));
    setLazyProperty(styles.bgColor, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, true));
    setLazyProperty(styles.bgColor, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, true));
    return styles;
  }
  Object.defineProperty(module2, "exports", {
    enumerable: true,
    get: assembleStyles
  });
});

// ../../node_modules/.pnpm/has-flag@4.0.0/node_modules/has-flag/index.js
var require_has_flag = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = (flag, argv = process.argv) => {
    const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
    const position = argv.indexOf(prefix + flag);
    const terminatorPosition = argv.indexOf("--");
    return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
  };
});

// ../../node_modules/.pnpm/supports-color@7.1.0/node_modules/supports-color/index.js
var require_supports_color = __commonJS((exports2, module2) => {
  "use strict";
  const os = require("os");
  const tty = require("tty");
  const hasFlag = require_has_flag();
  const {env} = process;
  let forceColor;
  if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
    forceColor = 0;
  } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
    forceColor = 1;
  }
  if ("FORCE_COLOR" in env) {
    if (env.FORCE_COLOR === "true") {
      forceColor = 1;
    } else if (env.FORCE_COLOR === "false") {
      forceColor = 0;
    } else {
      forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
    }
  }
  function translateLevel(level) {
    if (level === 0) {
      return false;
    }
    return {
      level,
      hasBasic: true,
      has256: level >= 2,
      has16m: level >= 3
    };
  }
  function supportsColor(haveStream, streamIsTTY) {
    if (forceColor === 0) {
      return 0;
    }
    if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
      return 3;
    }
    if (hasFlag("color=256")) {
      return 2;
    }
    if (haveStream && !streamIsTTY && forceColor === void 0) {
      return 0;
    }
    const min = forceColor || 0;
    if (env.TERM === "dumb") {
      return min;
    }
    if (process.platform === "win32") {
      const osRelease = os.release().split(".");
      if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
        return Number(osRelease[2]) >= 14931 ? 3 : 2;
      }
      return 1;
    }
    if ("CI" in env) {
      if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some((sign) => sign in env) || env.CI_NAME === "codeship") {
        return 1;
      }
      return min;
    }
    if ("TEAMCITY_VERSION" in env) {
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
    }
    if ("GITHUB_ACTIONS" in env) {
      return 1;
    }
    if (env.COLORTERM === "truecolor") {
      return 3;
    }
    if ("TERM_PROGRAM" in env) {
      const version = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
      switch (env.TERM_PROGRAM) {
        case "iTerm.app":
          return version >= 3 ? 3 : 2;
        case "Apple_Terminal":
          return 2;
      }
    }
    if (/-256(color)?$/i.test(env.TERM)) {
      return 2;
    }
    if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
      return 1;
    }
    if ("COLORTERM" in env) {
      return 1;
    }
    return min;
  }
  function getSupportLevel(stream) {
    const level = supportsColor(stream, stream && stream.isTTY);
    return translateLevel(level);
  }
  module2.exports = {
    supportsColor: getSupportLevel,
    stdout: translateLevel(supportsColor(true, tty.isatty(1))),
    stderr: translateLevel(supportsColor(true, tty.isatty(2)))
  };
});

// ../../node_modules/.pnpm/chalk@4.1.0/node_modules/chalk/source/util.js
var require_util = __commonJS((exports2, module2) => {
  "use strict";
  const stringReplaceAll = (string, substring, replacer) => {
    let index = string.indexOf(substring);
    if (index === -1) {
      return string;
    }
    const substringLength = substring.length;
    let endIndex = 0;
    let returnValue = "";
    do {
      returnValue += string.substr(endIndex, index - endIndex) + substring + replacer;
      endIndex = index + substringLength;
      index = string.indexOf(substring, endIndex);
    } while (index !== -1);
    returnValue += string.substr(endIndex);
    return returnValue;
  };
  const stringEncaseCRLFWithFirstIndex = (string, prefix, postfix, index) => {
    let endIndex = 0;
    let returnValue = "";
    do {
      const gotCR = string[index - 1] === "\r";
      returnValue += string.substr(endIndex, (gotCR ? index - 1 : index) - endIndex) + prefix + (gotCR ? "\r\n" : "\n") + postfix;
      endIndex = index + 1;
      index = string.indexOf("\n", endIndex);
    } while (index !== -1);
    returnValue += string.substr(endIndex);
    return returnValue;
  };
  module2.exports = {
    stringReplaceAll,
    stringEncaseCRLFWithFirstIndex
  };
});

// ../../node_modules/.pnpm/chalk@4.1.0/node_modules/chalk/source/templates.js
var require_templates = __commonJS((exports2, module2) => {
  "use strict";
  const TEMPLATE_REGEX = /(?:\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
  const STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
  const STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
  const ESCAPE_REGEX = /\\(u(?:[a-f\d]{4}|{[a-f\d]{1,6}})|x[a-f\d]{2}|.)|([^\\])/gi;
  const ESCAPES = new Map([
    ["n", "\n"],
    ["r", "\r"],
    ["t", "	"],
    ["b", "\b"],
    ["f", "\f"],
    ["v", "\v"],
    ["0", "\0"],
    ["\\", "\\"],
    ["e", ""],
    ["a", "\x07"]
  ]);
  function unescape(c) {
    const u = c[0] === "u";
    const bracket = c[1] === "{";
    if (u && !bracket && c.length === 5 || c[0] === "x" && c.length === 3) {
      return String.fromCharCode(parseInt(c.slice(1), 16));
    }
    if (u && bracket) {
      return String.fromCodePoint(parseInt(c.slice(2, -1), 16));
    }
    return ESCAPES.get(c) || c;
  }
  function parseArguments(name, arguments_) {
    const results = [];
    const chunks = arguments_.trim().split(/\s*,\s*/g);
    let matches;
    for (const chunk of chunks) {
      const number = Number(chunk);
      if (!Number.isNaN(number)) {
        results.push(number);
      } else if (matches = chunk.match(STRING_REGEX)) {
        results.push(matches[2].replace(ESCAPE_REGEX, (m, escape, character) => escape ? unescape(escape) : character));
      } else {
        throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);
      }
    }
    return results;
  }
  function parseStyle(style) {
    STYLE_REGEX.lastIndex = 0;
    const results = [];
    let matches;
    while ((matches = STYLE_REGEX.exec(style)) !== null) {
      const name = matches[1];
      if (matches[2]) {
        const args = parseArguments(name, matches[2]);
        results.push([name].concat(args));
      } else {
        results.push([name]);
      }
    }
    return results;
  }
  function buildStyle(chalk5, styles) {
    const enabled = {};
    for (const layer of styles) {
      for (const style of layer.styles) {
        enabled[style[0]] = layer.inverse ? null : style.slice(1);
      }
    }
    let current = chalk5;
    for (const [styleName, styles2] of Object.entries(enabled)) {
      if (!Array.isArray(styles2)) {
        continue;
      }
      if (!(styleName in current)) {
        throw new Error(`Unknown Chalk style: ${styleName}`);
      }
      current = styles2.length > 0 ? current[styleName](...styles2) : current[styleName];
    }
    return current;
  }
  module2.exports = (chalk5, temporary) => {
    const styles = [];
    const chunks = [];
    let chunk = [];
    temporary.replace(TEMPLATE_REGEX, (m, escapeCharacter, inverse, style, close, character) => {
      if (escapeCharacter) {
        chunk.push(unescape(escapeCharacter));
      } else if (style) {
        const string = chunk.join("");
        chunk = [];
        chunks.push(styles.length === 0 ? string : buildStyle(chalk5, styles)(string));
        styles.push({inverse, styles: parseStyle(style)});
      } else if (close) {
        if (styles.length === 0) {
          throw new Error("Found extraneous } in Chalk template literal");
        }
        chunks.push(buildStyle(chalk5, styles)(chunk.join("")));
        chunk = [];
        styles.pop();
      } else {
        chunk.push(character);
      }
    });
    chunks.push(chunk.join(""));
    if (styles.length > 0) {
      const errMessage = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? "" : "s"} (\`}\`)`;
      throw new Error(errMessage);
    }
    return chunks.join("");
  };
});

// ../../node_modules/.pnpm/chalk@4.1.0/node_modules/chalk/source/index.js
var require_source = __commonJS((exports2, module2) => {
  "use strict";
  const ansiStyles = require_ansi_styles();
  const {stdout: stdoutColor, stderr: stderrColor} = require_supports_color();
  const {
    stringReplaceAll,
    stringEncaseCRLFWithFirstIndex
  } = require_util();
  const {isArray} = Array;
  const levelMapping = [
    "ansi",
    "ansi",
    "ansi256",
    "ansi16m"
  ];
  const styles = Object.create(null);
  const applyOptions = (object, options = {}) => {
    if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) {
      throw new Error("The `level` option should be an integer from 0 to 3");
    }
    const colorLevel = stdoutColor ? stdoutColor.level : 0;
    object.level = options.level === void 0 ? colorLevel : options.level;
  };
  class ChalkClass {
    constructor(options) {
      return chalkFactory(options);
    }
  }
  const chalkFactory = (options) => {
    const chalk6 = {};
    applyOptions(chalk6, options);
    chalk6.template = (...arguments_) => chalkTag(chalk6.template, ...arguments_);
    Object.setPrototypeOf(chalk6, Chalk.prototype);
    Object.setPrototypeOf(chalk6.template, chalk6);
    chalk6.template.constructor = () => {
      throw new Error("`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.");
    };
    chalk6.template.Instance = ChalkClass;
    return chalk6.template;
  };
  function Chalk(options) {
    return chalkFactory(options);
  }
  for (const [styleName, style] of Object.entries(ansiStyles)) {
    styles[styleName] = {
      get() {
        const builder = createBuilder(this, createStyler(style.open, style.close, this._styler), this._isEmpty);
        Object.defineProperty(this, styleName, {value: builder});
        return builder;
      }
    };
  }
  styles.visible = {
    get() {
      const builder = createBuilder(this, this._styler, true);
      Object.defineProperty(this, "visible", {value: builder});
      return builder;
    }
  };
  const usedModels = ["rgb", "hex", "keyword", "hsl", "hsv", "hwb", "ansi", "ansi256"];
  for (const model of usedModels) {
    styles[model] = {
      get() {
        const {level} = this;
        return function(...arguments_) {
          const styler = createStyler(ansiStyles.color[levelMapping[level]][model](...arguments_), ansiStyles.color.close, this._styler);
          return createBuilder(this, styler, this._isEmpty);
        };
      }
    };
  }
  for (const model of usedModels) {
    const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
    styles[bgModel] = {
      get() {
        const {level} = this;
        return function(...arguments_) {
          const styler = createStyler(ansiStyles.bgColor[levelMapping[level]][model](...arguments_), ansiStyles.bgColor.close, this._styler);
          return createBuilder(this, styler, this._isEmpty);
        };
      }
    };
  }
  const proto = Object.defineProperties(() => {
  }, {
    ...styles,
    level: {
      enumerable: true,
      get() {
        return this._generator.level;
      },
      set(level) {
        this._generator.level = level;
      }
    }
  });
  const createStyler = (open, close, parent) => {
    let openAll;
    let closeAll;
    if (parent === void 0) {
      openAll = open;
      closeAll = close;
    } else {
      openAll = parent.openAll + open;
      closeAll = close + parent.closeAll;
    }
    return {
      open,
      close,
      openAll,
      closeAll,
      parent
    };
  };
  const createBuilder = (self, _styler, _isEmpty) => {
    const builder = (...arguments_) => {
      if (isArray(arguments_[0]) && isArray(arguments_[0].raw)) {
        return applyStyle(builder, chalkTag(builder, ...arguments_));
      }
      return applyStyle(builder, arguments_.length === 1 ? "" + arguments_[0] : arguments_.join(" "));
    };
    Object.setPrototypeOf(builder, proto);
    builder._generator = self;
    builder._styler = _styler;
    builder._isEmpty = _isEmpty;
    return builder;
  };
  const applyStyle = (self, string) => {
    if (self.level <= 0 || !string) {
      return self._isEmpty ? "" : string;
    }
    let styler = self._styler;
    if (styler === void 0) {
      return string;
    }
    const {openAll, closeAll} = styler;
    if (string.indexOf("") !== -1) {
      while (styler !== void 0) {
        string = stringReplaceAll(string, styler.close, styler.open);
        styler = styler.parent;
      }
    }
    const lfIndex = string.indexOf("\n");
    if (lfIndex !== -1) {
      string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);
    }
    return openAll + string + closeAll;
  };
  let template;
  const chalkTag = (chalk6, ...strings) => {
    const [firstString] = strings;
    if (!isArray(firstString) || !isArray(firstString.raw)) {
      return strings.join(" ");
    }
    const arguments_ = strings.slice(1);
    const parts = [firstString.raw[0]];
    for (let i = 1; i < firstString.length; i++) {
      parts.push(String(arguments_[i - 1]).replace(/[{}\\]/g, "\\$&"), String(firstString.raw[i]));
    }
    if (template === void 0) {
      template = require_templates();
    }
    return template(chalk6, parts.join(""));
  };
  Object.defineProperties(Chalk.prototype, styles);
  const chalk5 = Chalk();
  chalk5.supportsColor = stdoutColor;
  chalk5.stderr = Chalk({level: stderrColor ? stderrColor.level : 0});
  chalk5.stderr.supportsColor = stderrColor;
  module2.exports = chalk5;
});

// ../../node_modules/.pnpm/ms@2.1.2/node_modules/ms/index.js
var require_ms = __commonJS((exports2, module2) => {
  var s = 1e3;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var w = d * 7;
  var y = d * 365.25;
  module2.exports = function(val, options) {
    options = options || {};
    var type = typeof val;
    if (type === "string" && val.length > 0) {
      return parse(val);
    } else if (type === "number" && isFinite(val)) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
  };
  function parse(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || "ms").toLowerCase();
    switch (type) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y;
      case "weeks":
      case "week":
      case "w":
        return n * w;
      case "days":
      case "day":
      case "d":
        return n * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return void 0;
    }
  }
  function fmtShort(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return Math.round(ms / d) + "d";
    }
    if (msAbs >= h) {
      return Math.round(ms / h) + "h";
    }
    if (msAbs >= m) {
      return Math.round(ms / m) + "m";
    }
    if (msAbs >= s) {
      return Math.round(ms / s) + "s";
    }
    return ms + "ms";
  }
  function fmtLong(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return plural(ms, msAbs, d, "day");
    }
    if (msAbs >= h) {
      return plural(ms, msAbs, h, "hour");
    }
    if (msAbs >= m) {
      return plural(ms, msAbs, m, "minute");
    }
    if (msAbs >= s) {
      return plural(ms, msAbs, s, "second");
    }
    return ms + " ms";
  }
  function plural(ms, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
  }
});

// ../../node_modules/.pnpm/debug@4.1.1/node_modules/debug/src/common.js
var require_common = __commonJS((exports2, module2) => {
  function setup(env) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = require_ms();
    Object.keys(env).forEach((key) => {
      createDebug[key] = env[key];
    });
    createDebug.instances = [];
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace) {
      let hash = 0;
      for (let i = 0; i < namespace.length; i++) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function createDebug(namespace) {
      let prevTime;
      function debug2(...args) {
        if (!debug2.enabled) {
          return;
        }
        const self = debug2;
        const curr = Number(new Date());
        const ms = curr - (prevTime || curr);
        self.diff = ms;
        self.prev = prevTime;
        self.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        let index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
          if (match === "%%") {
            return match;
          }
          index++;
          const formatter = createDebug.formatters[format];
          if (typeof formatter === "function") {
            const val = args[index];
            match = formatter.call(self, val);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        createDebug.formatArgs.call(self, args);
        const logFn = self.log || createDebug.log;
        logFn.apply(self, args);
      }
      debug2.namespace = namespace;
      debug2.enabled = createDebug.enabled(namespace);
      debug2.useColors = createDebug.useColors();
      debug2.color = selectColor(namespace);
      debug2.destroy = destroy;
      debug2.extend = extend;
      if (typeof createDebug.init === "function") {
        createDebug.init(debug2);
      }
      createDebug.instances.push(debug2);
      return debug2;
    }
    function destroy() {
      const index = createDebug.instances.indexOf(this);
      if (index !== -1) {
        createDebug.instances.splice(index, 1);
        return true;
      }
      return false;
    }
    function extend(namespace, delimiter) {
      const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.names = [];
      createDebug.skips = [];
      let i;
      const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
      const len = split.length;
      for (i = 0; i < len; i++) {
        if (!split[i]) {
          continue;
        }
        namespaces = split[i].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          createDebug.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
        } else {
          createDebug.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
      for (i = 0; i < createDebug.instances.length; i++) {
        const instance = createDebug.instances[i];
        instance.enabled = createDebug.enabled(instance.namespace);
      }
    }
    function disable() {
      const namespaces = [
        ...createDebug.names.map(toNamespace),
        ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
      ].join(",");
      createDebug.enable("");
      return namespaces;
    }
    function enabled(name) {
      if (name[name.length - 1] === "*") {
        return true;
      }
      let i;
      let len;
      for (i = 0, len = createDebug.skips.length; i < len; i++) {
        if (createDebug.skips[i].test(name)) {
          return false;
        }
      }
      for (i = 0, len = createDebug.names.length; i < len; i++) {
        if (createDebug.names[i].test(name)) {
          return true;
        }
      }
      return false;
    }
    function toNamespace(regexp) {
      return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
    }
    function coerce(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  }
  module2.exports = setup;
});

// ../../node_modules/.pnpm/debug@4.1.1/node_modules/debug/src/browser.js
var require_browser = __commonJS((exports2, module2) => {
  exports2.log = log;
  exports2.formatArgs = formatArgs;
  exports2.save = save;
  exports2.load = load;
  exports2.useColors = useColors;
  exports2.storage = localstorage();
  exports2.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function useColors() {
    if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
      return true;
    }
    if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
      return false;
    }
    return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function formatArgs(args) {
    args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
    if (!this.useColors) {
      return;
    }
    const c = "color: " + this.color;
    args.splice(1, 0, c, "color: inherit");
    let index = 0;
    let lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, (match) => {
      if (match === "%%") {
        return;
      }
      index++;
      if (match === "%c") {
        lastC = index;
      }
    });
    args.splice(lastC, 0, c);
  }
  function log(...args) {
    return typeof console === "object" && console.log && console.log(...args);
  }
  function save(namespaces) {
    try {
      if (namespaces) {
        exports2.storage.setItem("debug", namespaces);
      } else {
        exports2.storage.removeItem("debug");
      }
    } catch (error) {
    }
  }
  function load() {
    let r;
    try {
      r = exports2.storage.getItem("debug");
    } catch (error) {
    }
    if (!r && typeof process !== "undefined" && "env" in process) {
      r = process.env.DEBUG;
    }
    return r;
  }
  function localstorage() {
    try {
      return localStorage;
    } catch (error) {
    }
  }
  module2.exports = require_common()(exports2);
  const {formatters} = module2.exports;
  formatters.j = function(v) {
    try {
      return JSON.stringify(v);
    } catch (error) {
      return "[UnexpectedJSONParseError]: " + error.message;
    }
  };
});

// ../../node_modules/.pnpm/debug@4.1.1/node_modules/debug/src/node.js
var require_node = __commonJS((exports2, module2) => {
  const tty = require("tty");
  const util2 = require("util");
  exports2.init = init;
  exports2.log = log;
  exports2.formatArgs = formatArgs;
  exports2.save = save;
  exports2.load = load;
  exports2.useColors = useColors;
  exports2.colors = [6, 2, 3, 4, 5, 1];
  try {
    const supportsColor = require_supports_color();
    if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
      exports2.colors = [
        20,
        21,
        26,
        27,
        32,
        33,
        38,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        56,
        57,
        62,
        63,
        68,
        69,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        92,
        93,
        98,
        99,
        112,
        113,
        128,
        129,
        134,
        135,
        148,
        149,
        160,
        161,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        171,
        172,
        173,
        178,
        179,
        184,
        185,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        203,
        204,
        205,
        206,
        207,
        208,
        209,
        214,
        215,
        220,
        221
      ];
    }
  } catch (error) {
  }
  exports2.inspectOpts = Object.keys(process.env).filter((key) => {
    return /^debug_/i.test(key);
  }).reduce((obj, key) => {
    const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
      return k.toUpperCase();
    });
    let val = process.env[key];
    if (/^(yes|on|true|enabled)$/i.test(val)) {
      val = true;
    } else if (/^(no|off|false|disabled)$/i.test(val)) {
      val = false;
    } else if (val === "null") {
      val = null;
    } else {
      val = Number(val);
    }
    obj[prop] = val;
    return obj;
  }, {});
  function useColors() {
    return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(process.stderr.fd);
  }
  function formatArgs(args) {
    const {namespace: name, useColors: useColors2} = this;
    if (useColors2) {
      const c = this.color;
      const colorCode = "[3" + (c < 8 ? c : "8;5;" + c);
      const prefix = `  ${colorCode};1m${name} [0m`;
      args[0] = prefix + args[0].split("\n").join("\n" + prefix);
      args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "[0m");
    } else {
      args[0] = getDate() + name + " " + args[0];
    }
  }
  function getDate() {
    if (exports2.inspectOpts.hideDate) {
      return "";
    }
    return new Date().toISOString() + " ";
  }
  function log(...args) {
    return process.stderr.write(util2.format(...args) + "\n");
  }
  function save(namespaces) {
    if (namespaces) {
      process.env.DEBUG = namespaces;
    } else {
      delete process.env.DEBUG;
    }
  }
  function load() {
    return process.env.DEBUG;
  }
  function init(debug2) {
    debug2.inspectOpts = {};
    const keys = Object.keys(exports2.inspectOpts);
    for (let i = 0; i < keys.length; i++) {
      debug2.inspectOpts[keys[i]] = exports2.inspectOpts[keys[i]];
    }
  }
  module2.exports = require_common()(exports2);
  const {formatters} = module2.exports;
  formatters.o = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util2.inspect(v, this.inspectOpts).replace(/\s*\n\s*/g, " ");
  };
  formatters.O = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util2.inspect(v, this.inspectOpts);
  };
});

// ../../node_modules/.pnpm/debug@4.1.1/node_modules/debug/src/index.js
var require_src = __commonJS((exports2, module2) => {
  if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
    module2.exports = require_browser();
  } else {
    module2.exports = require_node();
  }
});

// ../generator-helper/dist/GeneratorProcess.js
var require_GeneratorProcess = __commonJS((exports2) => {
  "use strict";
  var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __importDefault = exports2 && exports2.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {default: mod};
  };
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.GeneratorProcess = exports2.GeneratorError = void 0;
  const cross_spawn_1 = require_cross_spawn();
  const byline_1 = __importDefault(require_byline());
  const chalk_1 = __importDefault(require_source());
  const debug_1 = __importDefault(require_src());
  const debug2 = debug_1.default("GeneratorProcess");
  let globalMessageId = 1;
  class GeneratorError extends Error {
    constructor(message, code, data) {
      super(message);
      this.code = code;
      this.data = data;
    }
  }
  exports2.GeneratorError = GeneratorError;
  class GeneratorProcess {
    constructor(executablePath) {
      this.executablePath = executablePath;
      this.listeners = {};
      this.exitCode = null;
      this.stderrLogs = "";
    }
    init() {
      return __awaiter(this, void 0, void 0, function* () {
        if (!this.initPromise) {
          this.initPromise = this.initSingleton();
        }
        return this.initPromise;
      });
    }
    initSingleton() {
      return new Promise((resolve, reject) => {
        try {
          this.child = cross_spawn_1.spawn(this.executablePath, {
            stdio: ["pipe", "inherit", "pipe"],
            env: Object.assign(Object.assign({}, process.env), {PRISMA_GENERATOR_INVOCATION: "true"}),
            shell: true
          });
          this.child.on("exit", (code) => {
            this.exitCode = code;
            if (code && code > 0 && this.currentGenerateDeferred) {
              this.currentGenerateDeferred.reject(new Error(this.stderrLogs.split("\n").slice(-5).join("\n")));
            }
          });
          this.child.on("error", (err) => {
            this.lastError = err;
            if (err.message.includes("EACCES")) {
              reject(new Error(`The executable at ${this.executablePath} lacks the right chmod. Please use ${chalk_1.default.bold(`chmod +x ${this.executablePath}`)}`));
            } else {
              reject(err);
            }
          });
          byline_1.default(this.child.stderr).on("data", (line) => {
            const response = String(line);
            this.stderrLogs += response + "\n";
            let data;
            try {
              data = JSON.parse(response);
            } catch (e) {
              debug2(response);
            }
            if (data) {
              this.handleResponse(data);
            }
          });
          setTimeout(() => {
            if (this.exitCode && this.exitCode > 0) {
              reject(new Error(`Generator at ${this.executablePath} could not start:

${this.stderrLogs}`));
            } else {
              resolve();
            }
          }, 200);
        } catch (e) {
          reject(e);
        }
      });
    }
    handleResponse(data) {
      if (data.jsonrpc && data.id) {
        if (typeof data.id !== "number") {
          throw new Error(`message.id has to be a number. Found value ${data.id}`);
        }
        if (this.listeners[data.id]) {
          if (data.error) {
            const error = new GeneratorError(data.error.message, data.error.code, data.error.data);
            this.listeners[data.id](null, error);
          } else {
            this.listeners[data.id](data.result);
          }
          delete this.listeners[data.id];
        }
      }
    }
    registerListener(messageId, cb) {
      this.listeners[messageId] = cb;
    }
    sendMessage(message) {
      this.child.stdin.write(JSON.stringify(message) + "\n");
    }
    getMessageId() {
      return globalMessageId++;
    }
    stop() {
      if (!this.child.killed) {
        this.child.kill();
      }
    }
    getManifest() {
      return new Promise((resolve, reject) => {
        const messageId = this.getMessageId();
        this.registerListener(messageId, (result, error) => {
          if (error) {
            return reject(error);
          }
          if (result.manifest) {
            resolve(result.manifest);
          } else {
            resolve(null);
          }
        });
        this.sendMessage({
          jsonrpc: "2.0",
          method: "getManifest",
          params: {},
          id: messageId
        });
      });
    }
    generate(options) {
      return new Promise((resolve, reject) => {
        const messageId = this.getMessageId();
        this.currentGenerateDeferred = {resolve, reject};
        this.registerListener(messageId, (result, error) => {
          if (error) {
            reject(error);
            this.currentGenerateDeferred = void 0;
            return;
          }
          resolve(result);
          this.currentGenerateDeferred = void 0;
        });
        this.sendMessage({
          jsonrpc: "2.0",
          method: "generate",
          params: options,
          id: messageId
        });
      });
    }
  }
  exports2.GeneratorProcess = GeneratorProcess;
});

// ../generator-helper/dist/generatorHandler.js
var require_generatorHandler = __commonJS((exports2) => {
  "use strict";
  var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __importDefault = exports2 && exports2.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {default: mod};
  };
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.generatorHandler = void 0;
  const byline_1 = __importDefault(require_byline());
  function generatorHandler2(handler) {
    byline_1.default(process.stdin).on("data", (line) => __awaiter(this, void 0, void 0, function* () {
      const json = JSON.parse(String(line));
      if (json.method === "generate" && json.params) {
        try {
          const result = yield handler.onGenerate(json.params);
          respond({
            jsonrpc: "2.0",
            result,
            id: json.id
          });
        } catch (e) {
          respond({
            jsonrpc: "2.0",
            error: {
              code: -32e3,
              message: e.stack || e.message,
              data: null
            },
            id: json.id
          });
        }
      }
      if (json.method === "getManifest") {
        if (handler.onManifest) {
          try {
            const manifest = handler.onManifest();
            respond({
              jsonrpc: "2.0",
              result: {
                manifest
              },
              id: json.id
            });
          } catch (e) {
            respond({
              jsonrpc: "2.0",
              error: {
                code: -32e3,
                message: e.stack || e.message,
                data: null
              },
              id: json.id
            });
          }
        } else {
          respond({
            jsonrpc: "2.0",
            result: {
              manifest: null
            },
            id: json.id
          });
        }
      }
    }));
    process.stdin.resume();
  }
  exports2.generatorHandler = generatorHandler2;
  function respond(response) {
    console.error(JSON.stringify(response));
  }
});

// ../generator-helper/dist/types.js
var require_types = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.DMMF = void 0;
  var DMMF2;
  (function(DMMF3) {
    let ModelAction;
    (function(ModelAction2) {
      ModelAction2["findOne"] = "findOne";
      ModelAction2["findMany"] = "findMany";
      ModelAction2["create"] = "create";
      ModelAction2["update"] = "update";
      ModelAction2["updateMany"] = "updateMany";
      ModelAction2["upsert"] = "upsert";
      ModelAction2["delete"] = "delete";
      ModelAction2["deleteMany"] = "deleteMany";
    })(ModelAction = DMMF3.ModelAction || (DMMF3.ModelAction = {}));
  })(DMMF2 = exports2.DMMF || (exports2.DMMF = {}));
});

// ../generator-helper/dist/index.js
var require_dist = __commonJS((exports2) => {
  "use strict";
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    Object.defineProperty(o, k2, {enumerable: true, get: function() {
      return m[k];
    }});
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
        __createBinding(exports3, m, p);
  };
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.generatorHandler = exports2.GeneratorError = exports2.GeneratorProcess = void 0;
  var GeneratorProcess_1 = require_GeneratorProcess();
  Object.defineProperty(exports2, "GeneratorProcess", {enumerable: true, get: function() {
    return GeneratorProcess_1.GeneratorProcess;
  }});
  Object.defineProperty(exports2, "GeneratorError", {enumerable: true, get: function() {
    return GeneratorProcess_1.GeneratorError;
  }});
  var generatorHandler_1 = require_generatorHandler();
  Object.defineProperty(exports2, "generatorHandler", {enumerable: true, get: function() {
    return generatorHandler_1.generatorHandler;
  }});
  __exportStar2(require_types(), exports2);
});

// ../debug/dist/index.js
var require_dist2 = __commonJS((exports2) => {
  "use strict";
  var __importDefault = exports2 && exports2.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {default: mod};
  };
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.getLogs = void 0;
  const debug_1 = __importDefault(require_src());
  const cache = [];
  const MAX_LOGS = 100;
  const namespaces = [];
  const enabledNamespaces = new Map();
  const envDebug = process.env.DEBUG ? process.env.DEBUG + "," : "";
  const skips = debug_1.default.skips.slice();
  const names = debug_1.default.names.slice();
  function isEnabledByEnvVar(name) {
    if (name[name.length - 1] === "*") {
      return true;
    }
    for (const skip of skips) {
      if (skip.test(name)) {
        return false;
      }
    }
    for (const nameRegex of names) {
      if (nameRegex.test(name)) {
        return true;
      }
    }
    return false;
  }
  function Debug2(namespace) {
    const debug2 = debug_1.default(namespace);
    namespaces.push(namespace);
    debug_1.default.enable(envDebug + namespaces.join(","));
    process.env.DEBUG = envDebug;
    if (isEnabledByEnvVar(namespace)) {
      enabledNamespaces.set(namespace, true);
    }
    const newDebug = (formatter, ...args) => {
      return debug2(formatter, ...args);
    };
    newDebug.log = console.error.bind(console);
    newDebug.color = debug2.color;
    newDebug.namespace = debug2.namespace;
    newDebug.enabled = debug2.enabled;
    newDebug.destroy = debug2.destroy;
    newDebug.extend = debug2.extend;
    debug2.log = (...args) => {
      cache.push(args);
      if (cache.length > MAX_LOGS) {
        cache.shift();
      }
      if (enabledNamespaces.has(namespace)) {
        newDebug.log(...args);
      }
    };
    return newDebug;
  }
  exports2.default = Debug2;
  Debug2.enable = (namespace) => {
    enabledNamespaces.set(namespace, true);
  };
  Debug2.enabled = (namespace) => enabledNamespaces.has(namespace);
  function getLogs(numChars = 7500) {
    let output = cache.map((c) => c.join("  ")).join("\n");
    if (output.length < numChars) {
      return output;
    }
    return output.slice(-numChars);
  }
  exports2.getLogs = getLogs;
});

// ../../node_modules/.pnpm/mkdirp@1.0.4/node_modules/mkdirp/lib/opts-arg.js
var require_opts_arg = __commonJS((exports2, module2) => {
  const {promisify: promisify2} = require("util");
  const fs3 = require("fs");
  const optsArg = (opts) => {
    if (!opts)
      opts = {mode: 511, fs: fs3};
    else if (typeof opts === "object")
      opts = {mode: 511, fs: fs3, ...opts};
    else if (typeof opts === "number")
      opts = {mode: opts, fs: fs3};
    else if (typeof opts === "string")
      opts = {mode: parseInt(opts, 8), fs: fs3};
    else
      throw new TypeError("invalid options argument");
    opts.mkdir = opts.mkdir || opts.fs.mkdir || fs3.mkdir;
    opts.mkdirAsync = promisify2(opts.mkdir);
    opts.stat = opts.stat || opts.fs.stat || fs3.stat;
    opts.statAsync = promisify2(opts.stat);
    opts.statSync = opts.statSync || opts.fs.statSync || fs3.statSync;
    opts.mkdirSync = opts.mkdirSync || opts.fs.mkdirSync || fs3.mkdirSync;
    return opts;
  };
  module2.exports = optsArg;
});

// ../../node_modules/.pnpm/mkdirp@1.0.4/node_modules/mkdirp/lib/path-arg.js
var require_path_arg = __commonJS((exports2, module2) => {
  const platform = process.env.__TESTING_MKDIRP_PLATFORM__ || process.platform;
  const {resolve, parse} = require("path");
  const pathArg = (path9) => {
    if (/\0/.test(path9)) {
      throw Object.assign(new TypeError("path must be a string without null bytes"), {
        path: path9,
        code: "ERR_INVALID_ARG_VALUE"
      });
    }
    path9 = resolve(path9);
    if (platform === "win32") {
      const badWinChars = /[*|"<>?:]/;
      const {root} = parse(path9);
      if (badWinChars.test(path9.substr(root.length))) {
        throw Object.assign(new Error("Illegal characters in path."), {
          path: path9,
          code: "EINVAL"
        });
      }
    }
    return path9;
  };
  module2.exports = pathArg;
});

// ../../node_modules/.pnpm/mkdirp@1.0.4/node_modules/mkdirp/lib/find-made.js
var require_find_made = __commonJS((exports2, module2) => {
  const {dirname} = require("path");
  const findMade = (opts, parent, path9 = void 0) => {
    if (path9 === parent)
      return Promise.resolve();
    return opts.statAsync(parent).then((st) => st.isDirectory() ? path9 : void 0, (er) => er.code === "ENOENT" ? findMade(opts, dirname(parent), parent) : void 0);
  };
  const findMadeSync = (opts, parent, path9 = void 0) => {
    if (path9 === parent)
      return void 0;
    try {
      return opts.statSync(parent).isDirectory() ? path9 : void 0;
    } catch (er) {
      return er.code === "ENOENT" ? findMadeSync(opts, dirname(parent), parent) : void 0;
    }
  };
  module2.exports = {findMade, findMadeSync};
});

// ../../node_modules/.pnpm/mkdirp@1.0.4/node_modules/mkdirp/lib/mkdirp-manual.js
var require_mkdirp_manual = __commonJS((exports2, module2) => {
  const {dirname} = require("path");
  const mkdirpManual = (path9, opts, made) => {
    opts.recursive = false;
    const parent = dirname(path9);
    if (parent === path9) {
      return opts.mkdirAsync(path9, opts).catch((er) => {
        if (er.code !== "EISDIR")
          throw er;
      });
    }
    return opts.mkdirAsync(path9, opts).then(() => made || path9, (er) => {
      if (er.code === "ENOENT")
        return mkdirpManual(parent, opts).then((made2) => mkdirpManual(path9, opts, made2));
      if (er.code !== "EEXIST" && er.code !== "EROFS")
        throw er;
      return opts.statAsync(path9).then((st) => {
        if (st.isDirectory())
          return made;
        else
          throw er;
      }, () => {
        throw er;
      });
    });
  };
  const mkdirpManualSync = (path9, opts, made) => {
    const parent = dirname(path9);
    opts.recursive = false;
    if (parent === path9) {
      try {
        return opts.mkdirSync(path9, opts);
      } catch (er) {
        if (er.code !== "EISDIR")
          throw er;
        else
          return;
      }
    }
    try {
      opts.mkdirSync(path9, opts);
      return made || path9;
    } catch (er) {
      if (er.code === "ENOENT")
        return mkdirpManualSync(path9, opts, mkdirpManualSync(parent, opts, made));
      if (er.code !== "EEXIST" && er.code !== "EROFS")
        throw er;
      try {
        if (!opts.statSync(path9).isDirectory())
          throw er;
      } catch (_) {
        throw er;
      }
    }
  };
  module2.exports = {mkdirpManual, mkdirpManualSync};
});

// ../../node_modules/.pnpm/mkdirp@1.0.4/node_modules/mkdirp/lib/mkdirp-native.js
var require_mkdirp_native = __commonJS((exports2, module2) => {
  const {dirname} = require("path");
  const {findMade, findMadeSync} = require_find_made();
  const {mkdirpManual, mkdirpManualSync} = require_mkdirp_manual();
  const mkdirpNative = (path9, opts) => {
    opts.recursive = true;
    const parent = dirname(path9);
    if (parent === path9)
      return opts.mkdirAsync(path9, opts);
    return findMade(opts, path9).then((made) => opts.mkdirAsync(path9, opts).then(() => made).catch((er) => {
      if (er.code === "ENOENT")
        return mkdirpManual(path9, opts);
      else
        throw er;
    }));
  };
  const mkdirpNativeSync = (path9, opts) => {
    opts.recursive = true;
    const parent = dirname(path9);
    if (parent === path9)
      return opts.mkdirSync(path9, opts);
    const made = findMadeSync(opts, path9);
    try {
      opts.mkdirSync(path9, opts);
      return made;
    } catch (er) {
      if (er.code === "ENOENT")
        return mkdirpManualSync(path9, opts);
      else
        throw er;
    }
  };
  module2.exports = {mkdirpNative, mkdirpNativeSync};
});

// ../../node_modules/.pnpm/mkdirp@1.0.4/node_modules/mkdirp/lib/use-native.js
var require_use_native = __commonJS((exports2, module2) => {
  const fs3 = require("fs");
  const version = process.env.__TESTING_MKDIRP_NODE_VERSION__ || process.version;
  const versArr = version.replace(/^v/, "").split(".");
  const hasNative = +versArr[0] > 10 || +versArr[0] === 10 && +versArr[1] >= 12;
  const useNative = !hasNative ? () => false : (opts) => opts.mkdir === fs3.mkdir;
  const useNativeSync = !hasNative ? () => false : (opts) => opts.mkdirSync === fs3.mkdirSync;
  module2.exports = {useNative, useNativeSync};
});

// ../../node_modules/.pnpm/mkdirp@1.0.4/node_modules/mkdirp/index.js
var require_mkdirp = __commonJS((exports2, module2) => {
  const optsArg = require_opts_arg();
  const pathArg = require_path_arg();
  const {mkdirpNative, mkdirpNativeSync} = require_mkdirp_native();
  const {mkdirpManual, mkdirpManualSync} = require_mkdirp_manual();
  const {useNative, useNativeSync} = require_use_native();
  const mkdirp = (path9, opts) => {
    path9 = pathArg(path9);
    opts = optsArg(opts);
    return useNative(opts) ? mkdirpNative(path9, opts) : mkdirpManual(path9, opts);
  };
  const mkdirpSync = (path9, opts) => {
    path9 = pathArg(path9);
    opts = optsArg(opts);
    return useNativeSync(opts) ? mkdirpNativeSync(path9, opts) : mkdirpManualSync(path9, opts);
  };
  mkdirp.sync = mkdirpSync;
  mkdirp.native = (path9, opts) => mkdirpNative(pathArg(path9), optsArg(opts));
  mkdirp.manual = (path9, opts) => mkdirpManual(pathArg(path9), optsArg(opts));
  mkdirp.nativeSync = (path9, opts) => mkdirpNativeSync(pathArg(path9), optsArg(opts));
  mkdirp.manualSync = (path9, opts) => mkdirpManualSync(pathArg(path9), optsArg(opts));
  module2.exports = mkdirp;
});

// ../../node_modules/.pnpm/prettysize@2.0.0/node_modules/prettysize/index.js
var require_prettysize = __commonJS((exports2, module2) => {
  "use strict";
  var sizes = [
    "Bytes",
    "kB",
    "MB",
    "GB",
    "TB",
    "PB",
    "EB"
  ];
  module2.exports = function(size, nospace, one, places, numOnly) {
    if (typeof nospace === "object") {
      var opts = nospace;
      nospace = opts.nospace;
      one = opts.one;
      places = opts.places || 1;
      numOnly = opts.numOnly;
    } else {
      places = places || 1;
    }
    var mysize;
    for (var id = 0; id < sizes.length; ++id) {
      var unit = sizes[id];
      if (one) {
        unit = unit.slice(0, 1);
      }
      var s = Math.pow(1024, id);
      var fixed;
      if (size >= s) {
        fixed = String((size / s).toFixed(places));
        if (fixed.indexOf(".0") === fixed.length - 2) {
          fixed = fixed.slice(0, -2);
        }
        mysize = fixed + (nospace ? "" : " ") + unit;
      }
    }
    if (!mysize) {
      var _unit = one ? sizes[0].slice(0, 1) : sizes[0];
      mysize = "0" + (nospace ? "" : " ") + _unit;
    }
    if (numOnly) {
      mysize = Number.parseFloat(mysize);
    }
    return mysize;
  };
});

// ../../node_modules/.pnpm/@timsuchanek/sleep-promise@8.0.1/node_modules/@timsuchanek/sleep-promise/build/cjs.js
var require_cjs = __commonJS((exports2, module2) => {
  "use strict";
  var cachedSetTimeout = setTimeout;
  function createSleepPromise(a, b) {
    var c = b.useCachedSetTimeout, d = c ? cachedSetTimeout : setTimeout;
    return new Promise(function(b2) {
      d(b2, a);
    });
  }
  function sleep(a) {
    function b(a2) {
      return e.then(function() {
        return a2;
      });
    }
    var c = 1 < arguments.length && arguments[1] !== void 0 ? arguments[1] : {}, d = c.useCachedSetTimeout, e = createSleepPromise(a, {useCachedSetTimeout: d});
    return b.then = function() {
      return e.then.apply(e, arguments);
    }, b.catch = Promise.resolve().catch, b;
  }
  module2.exports = sleep;
});

// ../../node_modules/.pnpm/@timsuchanek/copy@1.4.5/node_modules/@timsuchanek/copy/index.js
var require_copy = __commonJS((exports2, module2) => {
  const fs3 = require("fs");
  const path9 = require("path");
  const {promisify: promisify2} = require("util");
  const readFile = promisify2(fs3.readFile);
  const writeFile2 = promisify2(fs3.writeFile);
  const mkdir = promisify2(fs3.mkdir);
  const mkdirp = require_mkdirp();
  const pretty = require_prettysize();
  const sleep = require_cjs();
  const assert = require("assert");
  class Copy {
    constructor(options = {}) {
      this.from = path9.normalize(options.from);
      this.to = path9.normalize(options.to);
      this.recursive = options.recursive || false;
      this.overwrite = options.overwrite || false;
      this.overwriteMismatches = options.overwriteMismatches || false;
      this.verbose = options.verbose || false;
      this.json = options.json || false;
      this.ignoreErrors = options.ignoreErrors || false;
      this.parallelJobs = options.parallelJobs || 1;
      this.stateFile = options.state;
      this.stateFrequency = options.stateFrequency || 100;
      this.fns = {
        stat: promisify2(options.stat || fs3.stat),
        readdir: promisify2(options.readdir || fs3.readdir),
        copyFile: promisify2(options.copyFile || fs3.copyFile)
      };
      this.stateCatchUp = 0;
      this.state = {
        wip: [],
        counts: {
          directories: 0,
          files: 0,
          copies: 0
        }
      };
      this.pending = [];
      this.errors = [];
      assert.equal(typeof this.from, "string", "from should be a string");
      assert.equal(typeof this.to, "string", "to should be a string");
      assert.equal(typeof this.parallelJobs, "number", "parallelJobs should be a number");
      assert.equal(typeof this.stateFrequency, "number", "stateFrequency should be a number");
      assert.equal(typeof this.fns.stat, "function", "stat should be a function");
      assert.equal(typeof this.fns.readdir, "function", "readdir should be a function");
      assert.equal(typeof this.fns.copyFile, "function", "copyFile should be a function");
    }
    async start() {
      try {
        await this.loadState();
        if ((await this.fns.stat(this.from)).isDirectory()) {
          await mkdirp(this.to);
        } else {
          const basedir = path9.dirname(this.to);
          await mkdirp(basedir);
        }
        await this.copy(this.from, this.to);
        while (this.pending.length > 0) {
          await sleep(10);
        }
        await this.processJobErrors();
        await this.saveState();
        if (this.state.wip.length) {
          throw new Error("Incomplete `wip` found. Copy likely incomplete.");
        }
        return this.state;
      } catch (err) {
        err.state = this.state;
        throw err;
      }
    }
    async loadState() {
      if (!this.stateFile)
        return;
      try {
        await this.fns.stat(this.stateFile);
        this.state = JSON.parse(await readFile(this.stateFile));
        this.stateCatchUp = this.state.wip.length;
      } catch (err) {
        if (err.code !== "ENOENT") {
          throw err;
        }
      }
    }
    async saveState() {
      if (!this.stateFile)
        return;
      await writeFile2(this.stateFile, JSON.stringify(this.state, null, 2));
    }
    async processJobErrors() {
      let err = this.errors.shift();
      while (err) {
        this.handleError(err);
        err = this.errors.shift();
      }
    }
    async copy(from, to) {
      let catchingUp = this.stateCatchUp > 0;
      if (catchingUp) {
        if (this.state.wip.includes(from)) {
          this.stateCatchUp -= 1;
        } else if (!this.state.wip.some((wipFile) => wipFile.startsWith(from))) {
          return;
        }
      }
      try {
        await this.processJobErrors();
        const fromStat = await this.fns.stat(from);
        const isDirectory = fromStat.isDirectory();
        if (isDirectory && this.recursive) {
          await this.copyDirectory(from, to);
        } else if (!isDirectory) {
          if (!catchingUp) {
            this.state.wip.push(from);
          }
          await this.queueAction(() => this.copyFile(from, to, fromStat));
          if (this.state.counts.files % this.stateFrequency === 0) {
            await this.saveState();
          }
        }
      } catch (err) {
        this.handleError(err);
      }
    }
    async copyDirectory(from, to) {
      try {
        try {
          await this.fns.stat(to);
        } catch (err) {
          if (err.code === "ENOENT") {
            await mkdir(to);
          } else {
            throw err;
          }
        }
        const files = await this.fns.readdir(from);
        for (let file of files) {
          await this.copy(path9.join(from, file), path9.join(to, file));
        }
      } catch (err) {
        this.handleError(err);
      } finally {
        this.state.counts.directories++;
      }
    }
    async queueAction(asyncFunction) {
      while (this.pending.length >= this.parallelJobs) {
        await sleep(10);
      }
      const action = async () => {
        try {
          await asyncFunction();
        } finally {
          this.pending.splice(this.pending.indexOf(asyncFunction), 1);
        }
      };
      this.pending.push(action);
      action().catch((err) => this.errors.push(err));
    }
    async copyFile(from, to, fromStat) {
      this.logCopyAction(to, "start");
      try {
        const toStat = await this.fns.stat(to);
        if (this.overwrite) {
          await this.doCopy(from, to, fromStat);
        } else if (this.overwriteMismatches) {
          if (fromStat.size !== toStat.size || fromStat.mtimeMs > toStat.mtimeMs) {
            this.logCopyAction(to, "stats mismatch", {
              fromStat: {
                size: fromStat.size,
                mtimeMs: fromStat.mtimeMs
              },
              toStat: {
                size: toStat.size,
                mtimeMs: toStat.mtimeMs
              }
            });
            await this.doCopy(from, to, fromStat);
          } else {
            this.logCopyAction(to, "skipped, stats match");
          }
        } else {
          this.logCopyAction(to, "skipped");
        }
        this.removeWip(from);
      } catch (err) {
        if (err.code === "ENOENT") {
          await this.doCopy(from, to, fromStat);
          this.removeWip(from);
        } else {
          throw err;
        }
      }
      this.state.counts.files++;
    }
    async doCopy(from, to, fromStat) {
      try {
        if (this.verbose || this.json) {
          const start = Date.now();
          await this.fns.copyFile(from, to);
          const speed = fromStat.size / ((Date.now() - start) / 1e3);
          this.logCopyAction(to, "complete", {speed});
        } else {
          await this.fns.copyFile(from, to);
        }
        this.state.counts.copies++;
      } catch (err) {
        this.logCopyAction(to, "error");
        this.handleError(err);
      }
    }
    removeWip(from) {
      let wipIndex = this.state.wip.indexOf(from);
      if (wipIndex >= 0) {
        this.state.wip.splice(wipIndex, 1);
      }
    }
    log(message) {
      if (this.verbose || this.json) {
        if (this.json === "pretty") {
          console.log(JSON.stringify({message, state: this.state}, null, 2) + "\n");
        } else if (this.json) {
          console.log(JSON.stringify({message, state: this.state}));
        } else {
          console.log(`Count: ${this.state.counts.directories}d ${this.state.counts.files}f Jobs: ${this.pending.length} ${message}`);
        }
      }
    }
    logCopyAction(file, action, extra) {
      if (this.json) {
        let message = {file, action};
        if (extra) {
          Object.assign(message, extra);
        }
        this.log(message);
      } else {
        let message = `Copying: '${file}' (${action})`;
        if (extra && extra.speed !== void 0) {
          message += ` (${pretty(extra.speed)}/s)`;
        }
        this.log(message);
      }
    }
    handleError(err) {
      if (this.ignoreErrors) {
        console.error(err);
      } else {
        throw err;
      }
    }
  }
  module2.exports = (options) => {
    const copy3 = new Copy(options);
    return copy3.start();
  };
  module2.exports.Copy = Copy;
});

// ../../node_modules/.pnpm/semver@6.3.0/node_modules/semver/semver.js
var require_semver = __commonJS((exports2, module2) => {
  exports2 = module2.exports = SemVer;
  var debug2;
  if (typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG)) {
    debug2 = function() {
      var args = Array.prototype.slice.call(arguments, 0);
      args.unshift("SEMVER");
      console.log.apply(console, args);
    };
  } else {
    debug2 = function() {
    };
  }
  exports2.SEMVER_SPEC_VERSION = "2.0.0";
  var MAX_LENGTH = 256;
  var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
  var MAX_SAFE_COMPONENT_LENGTH = 16;
  var re = exports2.re = [];
  var src = exports2.src = [];
  var t = exports2.tokens = {};
  var R = 0;
  function tok(n) {
    t[n] = R++;
  }
  tok("NUMERICIDENTIFIER");
  src[t.NUMERICIDENTIFIER] = "0|[1-9]\\d*";
  tok("NUMERICIDENTIFIERLOOSE");
  src[t.NUMERICIDENTIFIERLOOSE] = "[0-9]+";
  tok("NONNUMERICIDENTIFIER");
  src[t.NONNUMERICIDENTIFIER] = "\\d*[a-zA-Z-][a-zA-Z0-9-]*";
  tok("MAINVERSION");
  src[t.MAINVERSION] = "(" + src[t.NUMERICIDENTIFIER] + ")\\.(" + src[t.NUMERICIDENTIFIER] + ")\\.(" + src[t.NUMERICIDENTIFIER] + ")";
  tok("MAINVERSIONLOOSE");
  src[t.MAINVERSIONLOOSE] = "(" + src[t.NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[t.NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[t.NUMERICIDENTIFIERLOOSE] + ")";
  tok("PRERELEASEIDENTIFIER");
  src[t.PRERELEASEIDENTIFIER] = "(?:" + src[t.NUMERICIDENTIFIER] + "|" + src[t.NONNUMERICIDENTIFIER] + ")";
  tok("PRERELEASEIDENTIFIERLOOSE");
  src[t.PRERELEASEIDENTIFIERLOOSE] = "(?:" + src[t.NUMERICIDENTIFIERLOOSE] + "|" + src[t.NONNUMERICIDENTIFIER] + ")";
  tok("PRERELEASE");
  src[t.PRERELEASE] = "(?:-(" + src[t.PRERELEASEIDENTIFIER] + "(?:\\." + src[t.PRERELEASEIDENTIFIER] + ")*))";
  tok("PRERELEASELOOSE");
  src[t.PRERELEASELOOSE] = "(?:-?(" + src[t.PRERELEASEIDENTIFIERLOOSE] + "(?:\\." + src[t.PRERELEASEIDENTIFIERLOOSE] + ")*))";
  tok("BUILDIDENTIFIER");
  src[t.BUILDIDENTIFIER] = "[0-9A-Za-z-]+";
  tok("BUILD");
  src[t.BUILD] = "(?:\\+(" + src[t.BUILDIDENTIFIER] + "(?:\\." + src[t.BUILDIDENTIFIER] + ")*))";
  tok("FULL");
  tok("FULLPLAIN");
  src[t.FULLPLAIN] = "v?" + src[t.MAINVERSION] + src[t.PRERELEASE] + "?" + src[t.BUILD] + "?";
  src[t.FULL] = "^" + src[t.FULLPLAIN] + "$";
  tok("LOOSEPLAIN");
  src[t.LOOSEPLAIN] = "[v=\\s]*" + src[t.MAINVERSIONLOOSE] + src[t.PRERELEASELOOSE] + "?" + src[t.BUILD] + "?";
  tok("LOOSE");
  src[t.LOOSE] = "^" + src[t.LOOSEPLAIN] + "$";
  tok("GTLT");
  src[t.GTLT] = "((?:<|>)?=?)";
  tok("XRANGEIDENTIFIERLOOSE");
  src[t.XRANGEIDENTIFIERLOOSE] = src[t.NUMERICIDENTIFIERLOOSE] + "|x|X|\\*";
  tok("XRANGEIDENTIFIER");
  src[t.XRANGEIDENTIFIER] = src[t.NUMERICIDENTIFIER] + "|x|X|\\*";
  tok("XRANGEPLAIN");
  src[t.XRANGEPLAIN] = "[v=\\s]*(" + src[t.XRANGEIDENTIFIER] + ")(?:\\.(" + src[t.XRANGEIDENTIFIER] + ")(?:\\.(" + src[t.XRANGEIDENTIFIER] + ")(?:" + src[t.PRERELEASE] + ")?" + src[t.BUILD] + "?)?)?";
  tok("XRANGEPLAINLOOSE");
  src[t.XRANGEPLAINLOOSE] = "[v=\\s]*(" + src[t.XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[t.XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[t.XRANGEIDENTIFIERLOOSE] + ")(?:" + src[t.PRERELEASELOOSE] + ")?" + src[t.BUILD] + "?)?)?";
  tok("XRANGE");
  src[t.XRANGE] = "^" + src[t.GTLT] + "\\s*" + src[t.XRANGEPLAIN] + "$";
  tok("XRANGELOOSE");
  src[t.XRANGELOOSE] = "^" + src[t.GTLT] + "\\s*" + src[t.XRANGEPLAINLOOSE] + "$";
  tok("COERCE");
  src[t.COERCE] = "(^|[^\\d])(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "})(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:$|[^\\d])";
  tok("COERCERTL");
  re[t.COERCERTL] = new RegExp(src[t.COERCE], "g");
  tok("LONETILDE");
  src[t.LONETILDE] = "(?:~>?)";
  tok("TILDETRIM");
  src[t.TILDETRIM] = "(\\s*)" + src[t.LONETILDE] + "\\s+";
  re[t.TILDETRIM] = new RegExp(src[t.TILDETRIM], "g");
  var tildeTrimReplace = "$1~";
  tok("TILDE");
  src[t.TILDE] = "^" + src[t.LONETILDE] + src[t.XRANGEPLAIN] + "$";
  tok("TILDELOOSE");
  src[t.TILDELOOSE] = "^" + src[t.LONETILDE] + src[t.XRANGEPLAINLOOSE] + "$";
  tok("LONECARET");
  src[t.LONECARET] = "(?:\\^)";
  tok("CARETTRIM");
  src[t.CARETTRIM] = "(\\s*)" + src[t.LONECARET] + "\\s+";
  re[t.CARETTRIM] = new RegExp(src[t.CARETTRIM], "g");
  var caretTrimReplace = "$1^";
  tok("CARET");
  src[t.CARET] = "^" + src[t.LONECARET] + src[t.XRANGEPLAIN] + "$";
  tok("CARETLOOSE");
  src[t.CARETLOOSE] = "^" + src[t.LONECARET] + src[t.XRANGEPLAINLOOSE] + "$";
  tok("COMPARATORLOOSE");
  src[t.COMPARATORLOOSE] = "^" + src[t.GTLT] + "\\s*(" + src[t.LOOSEPLAIN] + ")$|^$";
  tok("COMPARATOR");
  src[t.COMPARATOR] = "^" + src[t.GTLT] + "\\s*(" + src[t.FULLPLAIN] + ")$|^$";
  tok("COMPARATORTRIM");
  src[t.COMPARATORTRIM] = "(\\s*)" + src[t.GTLT] + "\\s*(" + src[t.LOOSEPLAIN] + "|" + src[t.XRANGEPLAIN] + ")";
  re[t.COMPARATORTRIM] = new RegExp(src[t.COMPARATORTRIM], "g");
  var comparatorTrimReplace = "$1$2$3";
  tok("HYPHENRANGE");
  src[t.HYPHENRANGE] = "^\\s*(" + src[t.XRANGEPLAIN] + ")\\s+-\\s+(" + src[t.XRANGEPLAIN] + ")\\s*$";
  tok("HYPHENRANGELOOSE");
  src[t.HYPHENRANGELOOSE] = "^\\s*(" + src[t.XRANGEPLAINLOOSE] + ")\\s+-\\s+(" + src[t.XRANGEPLAINLOOSE] + ")\\s*$";
  tok("STAR");
  src[t.STAR] = "(<|>)?=?\\s*\\*";
  for (var i = 0; i < R; i++) {
    debug2(i, src[i]);
    if (!re[i]) {
      re[i] = new RegExp(src[i]);
    }
  }
  exports2.parse = parse;
  function parse(version, options) {
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    if (version instanceof SemVer) {
      return version;
    }
    if (typeof version !== "string") {
      return null;
    }
    if (version.length > MAX_LENGTH) {
      return null;
    }
    var r = options.loose ? re[t.LOOSE] : re[t.FULL];
    if (!r.test(version)) {
      return null;
    }
    try {
      return new SemVer(version, options);
    } catch (er) {
      return null;
    }
  }
  exports2.valid = valid;
  function valid(version, options) {
    var v = parse(version, options);
    return v ? v.version : null;
  }
  exports2.clean = clean;
  function clean(version, options) {
    var s = parse(version.trim().replace(/^[=v]+/, ""), options);
    return s ? s.version : null;
  }
  exports2.SemVer = SemVer;
  function SemVer(version, options) {
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    if (version instanceof SemVer) {
      if (version.loose === options.loose) {
        return version;
      } else {
        version = version.version;
      }
    } else if (typeof version !== "string") {
      throw new TypeError("Invalid Version: " + version);
    }
    if (version.length > MAX_LENGTH) {
      throw new TypeError("version is longer than " + MAX_LENGTH + " characters");
    }
    if (!(this instanceof SemVer)) {
      return new SemVer(version, options);
    }
    debug2("SemVer", version, options);
    this.options = options;
    this.loose = !!options.loose;
    var m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
    if (!m) {
      throw new TypeError("Invalid Version: " + version);
    }
    this.raw = version;
    this.major = +m[1];
    this.minor = +m[2];
    this.patch = +m[3];
    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
      throw new TypeError("Invalid major version");
    }
    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
      throw new TypeError("Invalid minor version");
    }
    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
      throw new TypeError("Invalid patch version");
    }
    if (!m[4]) {
      this.prerelease = [];
    } else {
      this.prerelease = m[4].split(".").map(function(id) {
        if (/^[0-9]+$/.test(id)) {
          var num = +id;
          if (num >= 0 && num < MAX_SAFE_INTEGER) {
            return num;
          }
        }
        return id;
      });
    }
    this.build = m[5] ? m[5].split(".") : [];
    this.format();
  }
  SemVer.prototype.format = function() {
    this.version = this.major + "." + this.minor + "." + this.patch;
    if (this.prerelease.length) {
      this.version += "-" + this.prerelease.join(".");
    }
    return this.version;
  };
  SemVer.prototype.toString = function() {
    return this.version;
  };
  SemVer.prototype.compare = function(other) {
    debug2("SemVer.compare", this.version, this.options, other);
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    return this.compareMain(other) || this.comparePre(other);
  };
  SemVer.prototype.compareMain = function(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
  };
  SemVer.prototype.comparePre = function(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    if (this.prerelease.length && !other.prerelease.length) {
      return -1;
    } else if (!this.prerelease.length && other.prerelease.length) {
      return 1;
    } else if (!this.prerelease.length && !other.prerelease.length) {
      return 0;
    }
    var i2 = 0;
    do {
      var a = this.prerelease[i2];
      var b = other.prerelease[i2];
      debug2("prerelease compare", i2, a, b);
      if (a === void 0 && b === void 0) {
        return 0;
      } else if (b === void 0) {
        return 1;
      } else if (a === void 0) {
        return -1;
      } else if (a === b) {
        continue;
      } else {
        return compareIdentifiers(a, b);
      }
    } while (++i2);
  };
  SemVer.prototype.compareBuild = function(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    var i2 = 0;
    do {
      var a = this.build[i2];
      var b = other.build[i2];
      debug2("prerelease compare", i2, a, b);
      if (a === void 0 && b === void 0) {
        return 0;
      } else if (b === void 0) {
        return 1;
      } else if (a === void 0) {
        return -1;
      } else if (a === b) {
        continue;
      } else {
        return compareIdentifiers(a, b);
      }
    } while (++i2);
  };
  SemVer.prototype.inc = function(release, identifier) {
    switch (release) {
      case "premajor":
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor = 0;
        this.major++;
        this.inc("pre", identifier);
        break;
      case "preminor":
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor++;
        this.inc("pre", identifier);
        break;
      case "prepatch":
        this.prerelease.length = 0;
        this.inc("patch", identifier);
        this.inc("pre", identifier);
        break;
      case "prerelease":
        if (this.prerelease.length === 0) {
          this.inc("patch", identifier);
        }
        this.inc("pre", identifier);
        break;
      case "major":
        if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
          this.major++;
        }
        this.minor = 0;
        this.patch = 0;
        this.prerelease = [];
        break;
      case "minor":
        if (this.patch !== 0 || this.prerelease.length === 0) {
          this.minor++;
        }
        this.patch = 0;
        this.prerelease = [];
        break;
      case "patch":
        if (this.prerelease.length === 0) {
          this.patch++;
        }
        this.prerelease = [];
        break;
      case "pre":
        if (this.prerelease.length === 0) {
          this.prerelease = [0];
        } else {
          var i2 = this.prerelease.length;
          while (--i2 >= 0) {
            if (typeof this.prerelease[i2] === "number") {
              this.prerelease[i2]++;
              i2 = -2;
            }
          }
          if (i2 === -1) {
            this.prerelease.push(0);
          }
        }
        if (identifier) {
          if (this.prerelease[0] === identifier) {
            if (isNaN(this.prerelease[1])) {
              this.prerelease = [identifier, 0];
            }
          } else {
            this.prerelease = [identifier, 0];
          }
        }
        break;
      default:
        throw new Error("invalid increment argument: " + release);
    }
    this.format();
    this.raw = this.version;
    return this;
  };
  exports2.inc = inc;
  function inc(version, release, loose, identifier) {
    if (typeof loose === "string") {
      identifier = loose;
      loose = void 0;
    }
    try {
      return new SemVer(version, loose).inc(release, identifier).version;
    } catch (er) {
      return null;
    }
  }
  exports2.diff = diff;
  function diff(version1, version2) {
    if (eq(version1, version2)) {
      return null;
    } else {
      var v1 = parse(version1);
      var v2 = parse(version2);
      var prefix = "";
      if (v1.prerelease.length || v2.prerelease.length) {
        prefix = "pre";
        var defaultResult = "prerelease";
      }
      for (var key in v1) {
        if (key === "major" || key === "minor" || key === "patch") {
          if (v1[key] !== v2[key]) {
            return prefix + key;
          }
        }
      }
      return defaultResult;
    }
  }
  exports2.compareIdentifiers = compareIdentifiers;
  var numeric = /^[0-9]+$/;
  function compareIdentifiers(a, b) {
    var anum = numeric.test(a);
    var bnum = numeric.test(b);
    if (anum && bnum) {
      a = +a;
      b = +b;
    }
    return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
  }
  exports2.rcompareIdentifiers = rcompareIdentifiers;
  function rcompareIdentifiers(a, b) {
    return compareIdentifiers(b, a);
  }
  exports2.major = major;
  function major(a, loose) {
    return new SemVer(a, loose).major;
  }
  exports2.minor = minor;
  function minor(a, loose) {
    return new SemVer(a, loose).minor;
  }
  exports2.patch = patch;
  function patch(a, loose) {
    return new SemVer(a, loose).patch;
  }
  exports2.compare = compare;
  function compare(a, b, loose) {
    return new SemVer(a, loose).compare(new SemVer(b, loose));
  }
  exports2.compareLoose = compareLoose;
  function compareLoose(a, b) {
    return compare(a, b, true);
  }
  exports2.compareBuild = compareBuild;
  function compareBuild(a, b, loose) {
    var versionA = new SemVer(a, loose);
    var versionB = new SemVer(b, loose);
    return versionA.compare(versionB) || versionA.compareBuild(versionB);
  }
  exports2.rcompare = rcompare;
  function rcompare(a, b, loose) {
    return compare(b, a, loose);
  }
  exports2.sort = sort;
  function sort(list, loose) {
    return list.sort(function(a, b) {
      return exports2.compareBuild(a, b, loose);
    });
  }
  exports2.rsort = rsort;
  function rsort(list, loose) {
    return list.sort(function(a, b) {
      return exports2.compareBuild(b, a, loose);
    });
  }
  exports2.gt = gt;
  function gt(a, b, loose) {
    return compare(a, b, loose) > 0;
  }
  exports2.lt = lt;
  function lt(a, b, loose) {
    return compare(a, b, loose) < 0;
  }
  exports2.eq = eq;
  function eq(a, b, loose) {
    return compare(a, b, loose) === 0;
  }
  exports2.neq = neq;
  function neq(a, b, loose) {
    return compare(a, b, loose) !== 0;
  }
  exports2.gte = gte;
  function gte(a, b, loose) {
    return compare(a, b, loose) >= 0;
  }
  exports2.lte = lte;
  function lte(a, b, loose) {
    return compare(a, b, loose) <= 0;
  }
  exports2.cmp = cmp;
  function cmp(a, op, b, loose) {
    switch (op) {
      case "===":
        if (typeof a === "object")
          a = a.version;
        if (typeof b === "object")
          b = b.version;
        return a === b;
      case "!==":
        if (typeof a === "object")
          a = a.version;
        if (typeof b === "object")
          b = b.version;
        return a !== b;
      case "":
      case "=":
      case "==":
        return eq(a, b, loose);
      case "!=":
        return neq(a, b, loose);
      case ">":
        return gt(a, b, loose);
      case ">=":
        return gte(a, b, loose);
      case "<":
        return lt(a, b, loose);
      case "<=":
        return lte(a, b, loose);
      default:
        throw new TypeError("Invalid operator: " + op);
    }
  }
  exports2.Comparator = Comparator;
  function Comparator(comp, options) {
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    if (comp instanceof Comparator) {
      if (comp.loose === !!options.loose) {
        return comp;
      } else {
        comp = comp.value;
      }
    }
    if (!(this instanceof Comparator)) {
      return new Comparator(comp, options);
    }
    debug2("comparator", comp, options);
    this.options = options;
    this.loose = !!options.loose;
    this.parse(comp);
    if (this.semver === ANY) {
      this.value = "";
    } else {
      this.value = this.operator + this.semver.version;
    }
    debug2("comp", this);
  }
  var ANY = {};
  Comparator.prototype.parse = function(comp) {
    var r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
    var m = comp.match(r);
    if (!m) {
      throw new TypeError("Invalid comparator: " + comp);
    }
    this.operator = m[1] !== void 0 ? m[1] : "";
    if (this.operator === "=") {
      this.operator = "";
    }
    if (!m[2]) {
      this.semver = ANY;
    } else {
      this.semver = new SemVer(m[2], this.options.loose);
    }
  };
  Comparator.prototype.toString = function() {
    return this.value;
  };
  Comparator.prototype.test = function(version) {
    debug2("Comparator.test", version, this.options.loose);
    if (this.semver === ANY || version === ANY) {
      return true;
    }
    if (typeof version === "string") {
      try {
        version = new SemVer(version, this.options);
      } catch (er) {
        return false;
      }
    }
    return cmp(version, this.operator, this.semver, this.options);
  };
  Comparator.prototype.intersects = function(comp, options) {
    if (!(comp instanceof Comparator)) {
      throw new TypeError("a Comparator is required");
    }
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    var rangeTmp;
    if (this.operator === "") {
      if (this.value === "") {
        return true;
      }
      rangeTmp = new Range(comp.value, options);
      return satisfies(this.value, rangeTmp, options);
    } else if (comp.operator === "") {
      if (comp.value === "") {
        return true;
      }
      rangeTmp = new Range(this.value, options);
      return satisfies(comp.semver, rangeTmp, options);
    }
    var sameDirectionIncreasing = (this.operator === ">=" || this.operator === ">") && (comp.operator === ">=" || comp.operator === ">");
    var sameDirectionDecreasing = (this.operator === "<=" || this.operator === "<") && (comp.operator === "<=" || comp.operator === "<");
    var sameSemVer = this.semver.version === comp.semver.version;
    var differentDirectionsInclusive = (this.operator === ">=" || this.operator === "<=") && (comp.operator === ">=" || comp.operator === "<=");
    var oppositeDirectionsLessThan = cmp(this.semver, "<", comp.semver, options) && ((this.operator === ">=" || this.operator === ">") && (comp.operator === "<=" || comp.operator === "<"));
    var oppositeDirectionsGreaterThan = cmp(this.semver, ">", comp.semver, options) && ((this.operator === "<=" || this.operator === "<") && (comp.operator === ">=" || comp.operator === ">"));
    return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
  };
  exports2.Range = Range;
  function Range(range, options) {
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    if (range instanceof Range) {
      if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
        return range;
      } else {
        return new Range(range.raw, options);
      }
    }
    if (range instanceof Comparator) {
      return new Range(range.value, options);
    }
    if (!(this instanceof Range)) {
      return new Range(range, options);
    }
    this.options = options;
    this.loose = !!options.loose;
    this.includePrerelease = !!options.includePrerelease;
    this.raw = range;
    this.set = range.split(/\s*\|\|\s*/).map(function(range2) {
      return this.parseRange(range2.trim());
    }, this).filter(function(c) {
      return c.length;
    });
    if (!this.set.length) {
      throw new TypeError("Invalid SemVer Range: " + range);
    }
    this.format();
  }
  Range.prototype.format = function() {
    this.range = this.set.map(function(comps) {
      return comps.join(" ").trim();
    }).join("||").trim();
    return this.range;
  };
  Range.prototype.toString = function() {
    return this.range;
  };
  Range.prototype.parseRange = function(range) {
    var loose = this.options.loose;
    range = range.trim();
    var hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
    range = range.replace(hr, hyphenReplace);
    debug2("hyphen replace", range);
    range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
    debug2("comparator trim", range, re[t.COMPARATORTRIM]);
    range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
    range = range.replace(re[t.CARETTRIM], caretTrimReplace);
    range = range.split(/\s+/).join(" ");
    var compRe = loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
    var set = range.split(" ").map(function(comp) {
      return parseComparator(comp, this.options);
    }, this).join(" ").split(/\s+/);
    if (this.options.loose) {
      set = set.filter(function(comp) {
        return !!comp.match(compRe);
      });
    }
    set = set.map(function(comp) {
      return new Comparator(comp, this.options);
    }, this);
    return set;
  };
  Range.prototype.intersects = function(range, options) {
    if (!(range instanceof Range)) {
      throw new TypeError("a Range is required");
    }
    return this.set.some(function(thisComparators) {
      return isSatisfiable(thisComparators, options) && range.set.some(function(rangeComparators) {
        return isSatisfiable(rangeComparators, options) && thisComparators.every(function(thisComparator) {
          return rangeComparators.every(function(rangeComparator) {
            return thisComparator.intersects(rangeComparator, options);
          });
        });
      });
    });
  };
  function isSatisfiable(comparators, options) {
    var result = true;
    var remainingComparators = comparators.slice();
    var testComparator = remainingComparators.pop();
    while (result && remainingComparators.length) {
      result = remainingComparators.every(function(otherComparator) {
        return testComparator.intersects(otherComparator, options);
      });
      testComparator = remainingComparators.pop();
    }
    return result;
  }
  exports2.toComparators = toComparators;
  function toComparators(range, options) {
    return new Range(range, options).set.map(function(comp) {
      return comp.map(function(c) {
        return c.value;
      }).join(" ").trim().split(" ");
    });
  }
  function parseComparator(comp, options) {
    debug2("comp", comp, options);
    comp = replaceCarets(comp, options);
    debug2("caret", comp);
    comp = replaceTildes(comp, options);
    debug2("tildes", comp);
    comp = replaceXRanges(comp, options);
    debug2("xrange", comp);
    comp = replaceStars(comp, options);
    debug2("stars", comp);
    return comp;
  }
  function isX(id) {
    return !id || id.toLowerCase() === "x" || id === "*";
  }
  function replaceTildes(comp, options) {
    return comp.trim().split(/\s+/).map(function(comp2) {
      return replaceTilde(comp2, options);
    }).join(" ");
  }
  function replaceTilde(comp, options) {
    var r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
    return comp.replace(r, function(_, M, m, p, pr) {
      debug2("tilde", comp, _, M, m, p, pr);
      var ret;
      if (isX(M)) {
        ret = "";
      } else if (isX(m)) {
        ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
      } else if (isX(p)) {
        ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
      } else if (pr) {
        debug2("replaceTilde pr", pr);
        ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0";
      } else {
        ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0";
      }
      debug2("tilde return", ret);
      return ret;
    });
  }
  function replaceCarets(comp, options) {
    return comp.trim().split(/\s+/).map(function(comp2) {
      return replaceCaret(comp2, options);
    }).join(" ");
  }
  function replaceCaret(comp, options) {
    debug2("caret", comp, options);
    var r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
    return comp.replace(r, function(_, M, m, p, pr) {
      debug2("caret", comp, _, M, m, p, pr);
      var ret;
      if (isX(M)) {
        ret = "";
      } else if (isX(m)) {
        ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
      } else if (isX(p)) {
        if (M === "0") {
          ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
        } else {
          ret = ">=" + M + "." + m + ".0 <" + (+M + 1) + ".0.0";
        }
      } else if (pr) {
        debug2("replaceCaret pr", pr);
        if (M === "0") {
          if (m === "0") {
            ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + m + "." + (+p + 1);
          } else {
            ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0";
          }
        } else {
          ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + (+M + 1) + ".0.0";
        }
      } else {
        debug2("no pr");
        if (M === "0") {
          if (m === "0") {
            ret = ">=" + M + "." + m + "." + p + " <" + M + "." + m + "." + (+p + 1);
          } else {
            ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0";
          }
        } else {
          ret = ">=" + M + "." + m + "." + p + " <" + (+M + 1) + ".0.0";
        }
      }
      debug2("caret return", ret);
      return ret;
    });
  }
  function replaceXRanges(comp, options) {
    debug2("replaceXRanges", comp, options);
    return comp.split(/\s+/).map(function(comp2) {
      return replaceXRange(comp2, options);
    }).join(" ");
  }
  function replaceXRange(comp, options) {
    comp = comp.trim();
    var r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
    return comp.replace(r, function(ret, gtlt, M, m, p, pr) {
      debug2("xRange", comp, ret, gtlt, M, m, p, pr);
      var xM = isX(M);
      var xm = xM || isX(m);
      var xp = xm || isX(p);
      var anyX = xp;
      if (gtlt === "=" && anyX) {
        gtlt = "";
      }
      pr = options.includePrerelease ? "-0" : "";
      if (xM) {
        if (gtlt === ">" || gtlt === "<") {
          ret = "<0.0.0-0";
        } else {
          ret = "*";
        }
      } else if (gtlt && anyX) {
        if (xm) {
          m = 0;
        }
        p = 0;
        if (gtlt === ">") {
          gtlt = ">=";
          if (xm) {
            M = +M + 1;
            m = 0;
            p = 0;
          } else {
            m = +m + 1;
            p = 0;
          }
        } else if (gtlt === "<=") {
          gtlt = "<";
          if (xm) {
            M = +M + 1;
          } else {
            m = +m + 1;
          }
        }
        ret = gtlt + M + "." + m + "." + p + pr;
      } else if (xm) {
        ret = ">=" + M + ".0.0" + pr + " <" + (+M + 1) + ".0.0" + pr;
      } else if (xp) {
        ret = ">=" + M + "." + m + ".0" + pr + " <" + M + "." + (+m + 1) + ".0" + pr;
      }
      debug2("xRange return", ret);
      return ret;
    });
  }
  function replaceStars(comp, options) {
    debug2("replaceStars", comp, options);
    return comp.trim().replace(re[t.STAR], "");
  }
  function hyphenReplace($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {
    if (isX(fM)) {
      from = "";
    } else if (isX(fm)) {
      from = ">=" + fM + ".0.0";
    } else if (isX(fp)) {
      from = ">=" + fM + "." + fm + ".0";
    } else {
      from = ">=" + from;
    }
    if (isX(tM)) {
      to = "";
    } else if (isX(tm)) {
      to = "<" + (+tM + 1) + ".0.0";
    } else if (isX(tp)) {
      to = "<" + tM + "." + (+tm + 1) + ".0";
    } else if (tpr) {
      to = "<=" + tM + "." + tm + "." + tp + "-" + tpr;
    } else {
      to = "<=" + to;
    }
    return (from + " " + to).trim();
  }
  Range.prototype.test = function(version) {
    if (!version) {
      return false;
    }
    if (typeof version === "string") {
      try {
        version = new SemVer(version, this.options);
      } catch (er) {
        return false;
      }
    }
    for (var i2 = 0; i2 < this.set.length; i2++) {
      if (testSet(this.set[i2], version, this.options)) {
        return true;
      }
    }
    return false;
  };
  function testSet(set, version, options) {
    for (var i2 = 0; i2 < set.length; i2++) {
      if (!set[i2].test(version)) {
        return false;
      }
    }
    if (version.prerelease.length && !options.includePrerelease) {
      for (i2 = 0; i2 < set.length; i2++) {
        debug2(set[i2].semver);
        if (set[i2].semver === ANY) {
          continue;
        }
        if (set[i2].semver.prerelease.length > 0) {
          var allowed = set[i2].semver;
          if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
            return true;
          }
        }
      }
      return false;
    }
    return true;
  }
  exports2.satisfies = satisfies;
  function satisfies(version, range, options) {
    try {
      range = new Range(range, options);
    } catch (er) {
      return false;
    }
    return range.test(version);
  }
  exports2.maxSatisfying = maxSatisfying;
  function maxSatisfying(versions, range, options) {
    var max = null;
    var maxSV = null;
    try {
      var rangeObj = new Range(range, options);
    } catch (er) {
      return null;
    }
    versions.forEach(function(v) {
      if (rangeObj.test(v)) {
        if (!max || maxSV.compare(v) === -1) {
          max = v;
          maxSV = new SemVer(max, options);
        }
      }
    });
    return max;
  }
  exports2.minSatisfying = minSatisfying;
  function minSatisfying(versions, range, options) {
    var min = null;
    var minSV = null;
    try {
      var rangeObj = new Range(range, options);
    } catch (er) {
      return null;
    }
    versions.forEach(function(v) {
      if (rangeObj.test(v)) {
        if (!min || minSV.compare(v) === 1) {
          min = v;
          minSV = new SemVer(min, options);
        }
      }
    });
    return min;
  }
  exports2.minVersion = minVersion;
  function minVersion(range, loose) {
    range = new Range(range, loose);
    var minver = new SemVer("0.0.0");
    if (range.test(minver)) {
      return minver;
    }
    minver = new SemVer("0.0.0-0");
    if (range.test(minver)) {
      return minver;
    }
    minver = null;
    for (var i2 = 0; i2 < range.set.length; ++i2) {
      var comparators = range.set[i2];
      comparators.forEach(function(comparator) {
        var compver = new SemVer(comparator.semver.version);
        switch (comparator.operator) {
          case ">":
            if (compver.prerelease.length === 0) {
              compver.patch++;
            } else {
              compver.prerelease.push(0);
            }
            compver.raw = compver.format();
          case "":
          case ">=":
            if (!minver || gt(minver, compver)) {
              minver = compver;
            }
            break;
          case "<":
          case "<=":
            break;
          default:
            throw new Error("Unexpected operation: " + comparator.operator);
        }
      });
    }
    if (minver && range.test(minver)) {
      return minver;
    }
    return null;
  }
  exports2.validRange = validRange;
  function validRange(range, options) {
    try {
      return new Range(range, options).range || "*";
    } catch (er) {
      return null;
    }
  }
  exports2.ltr = ltr;
  function ltr(version, range, options) {
    return outside(version, range, "<", options);
  }
  exports2.gtr = gtr;
  function gtr(version, range, options) {
    return outside(version, range, ">", options);
  }
  exports2.outside = outside;
  function outside(version, range, hilo, options) {
    version = new SemVer(version, options);
    range = new Range(range, options);
    var gtfn, ltefn, ltfn, comp, ecomp;
    switch (hilo) {
      case ">":
        gtfn = gt;
        ltefn = lte;
        ltfn = lt;
        comp = ">";
        ecomp = ">=";
        break;
      case "<":
        gtfn = lt;
        ltefn = gte;
        ltfn = gt;
        comp = "<";
        ecomp = "<=";
        break;
      default:
        throw new TypeError('Must provide a hilo val of "<" or ">"');
    }
    if (satisfies(version, range, options)) {
      return false;
    }
    for (var i2 = 0; i2 < range.set.length; ++i2) {
      var comparators = range.set[i2];
      var high = null;
      var low = null;
      comparators.forEach(function(comparator) {
        if (comparator.semver === ANY) {
          comparator = new Comparator(">=0.0.0");
        }
        high = high || comparator;
        low = low || comparator;
        if (gtfn(comparator.semver, high.semver, options)) {
          high = comparator;
        } else if (ltfn(comparator.semver, low.semver, options)) {
          low = comparator;
        }
      });
      if (high.operator === comp || high.operator === ecomp) {
        return false;
      }
      if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
        return false;
      } else if (low.operator === ecomp && ltfn(version, low.semver)) {
        return false;
      }
    }
    return true;
  }
  exports2.prerelease = prerelease;
  function prerelease(version, options) {
    var parsed = parse(version, options);
    return parsed && parsed.prerelease.length ? parsed.prerelease : null;
  }
  exports2.intersects = intersects;
  function intersects(r1, r2, options) {
    r1 = new Range(r1, options);
    r2 = new Range(r2, options);
    return r1.intersects(r2);
  }
  exports2.coerce = coerce;
  function coerce(version, options) {
    if (version instanceof SemVer) {
      return version;
    }
    if (typeof version === "number") {
      version = String(version);
    }
    if (typeof version !== "string") {
      return null;
    }
    options = options || {};
    var match = null;
    if (!options.rtl) {
      match = version.match(re[t.COERCE]);
    } else {
      var next;
      while ((next = re[t.COERCERTL].exec(version)) && (!match || match.index + match[0].length !== version.length)) {
        if (!match || next.index + next[0].length !== match.index + match[0].length) {
          match = next;
        }
        re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
      }
      re[t.COERCERTL].lastIndex = -1;
    }
    if (match === null) {
      return null;
    }
    return parse(match[2] + "." + (match[3] || "0") + "." + (match[4] || "0"), options);
  }
});

// ../../node_modules/.pnpm/make-dir@3.1.0/node_modules/make-dir/index.js
var require_make_dir = __commonJS((exports2, module2) => {
  "use strict";
  const fs3 = require("fs");
  const path9 = require("path");
  const {promisify: promisify2} = require("util");
  const semver = require_semver();
  const useNativeRecursiveOption = semver.satisfies(process.version, ">=10.12.0");
  const checkPath = (pth) => {
    if (process.platform === "win32") {
      const pathHasInvalidWinCharacters = /[<>:"|?*]/.test(pth.replace(path9.parse(pth).root, ""));
      if (pathHasInvalidWinCharacters) {
        const error = new Error(`Path contains invalid characters: ${pth}`);
        error.code = "EINVAL";
        throw error;
      }
    }
  };
  const processOptions = (options) => {
    const defaults = {
      mode: 511,
      fs: fs3
    };
    return {
      ...defaults,
      ...options
    };
  };
  const permissionError = (pth) => {
    const error = new Error(`operation not permitted, mkdir '${pth}'`);
    error.code = "EPERM";
    error.errno = -4048;
    error.path = pth;
    error.syscall = "mkdir";
    return error;
  };
  const makeDir2 = async (input, options) => {
    checkPath(input);
    options = processOptions(options);
    const mkdir = promisify2(options.fs.mkdir);
    const stat2 = promisify2(options.fs.stat);
    if (useNativeRecursiveOption && options.fs.mkdir === fs3.mkdir) {
      const pth = path9.resolve(input);
      await mkdir(pth, {
        mode: options.mode,
        recursive: true
      });
      return pth;
    }
    const make = async (pth) => {
      try {
        await mkdir(pth, options.mode);
        return pth;
      } catch (error) {
        if (error.code === "EPERM") {
          throw error;
        }
        if (error.code === "ENOENT") {
          if (path9.dirname(pth) === pth) {
            throw permissionError(pth);
          }
          if (error.message.includes("null bytes")) {
            throw error;
          }
          await make(path9.dirname(pth));
          return make(pth);
        }
        try {
          const stats = await stat2(pth);
          if (!stats.isDirectory()) {
            throw new Error("The path is not a directory");
          }
        } catch (_) {
          throw error;
        }
        return pth;
      }
    };
    return make(path9.resolve(input));
  };
  module2.exports = makeDir2;
  module2.exports.sync = (input, options) => {
    checkPath(input);
    options = processOptions(options);
    if (useNativeRecursiveOption && options.fs.mkdirSync === fs3.mkdirSync) {
      const pth = path9.resolve(input);
      fs3.mkdirSync(pth, {
        mode: options.mode,
        recursive: true
      });
      return pth;
    }
    const make = (pth) => {
      try {
        options.fs.mkdirSync(pth, options.mode);
      } catch (error) {
        if (error.code === "EPERM") {
          throw error;
        }
        if (error.code === "ENOENT") {
          if (path9.dirname(pth) === pth) {
            throw permissionError(pth);
          }
          if (error.message.includes("null bytes")) {
            throw error;
          }
          make(path9.dirname(pth));
          return make(pth);
        }
        try {
          if (!options.fs.statSync(pth).isDirectory()) {
            throw new Error("The path is not a directory");
          }
        } catch (_) {
          throw error;
        }
      }
      return pth;
    };
    return make(path9.resolve(input));
  };
});

// ../../node_modules/.pnpm/strip-final-newline@2.0.0/node_modules/strip-final-newline/index.js
var require_strip_final_newline = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = (input) => {
    const LF = typeof input === "string" ? "\n" : "\n".charCodeAt();
    const CR = typeof input === "string" ? "\r" : "\r".charCodeAt();
    if (input[input.length - 1] === LF) {
      input = input.slice(0, input.length - 1);
    }
    if (input[input.length - 1] === CR) {
      input = input.slice(0, input.length - 1);
    }
    return input;
  };
});

// ../../node_modules/.pnpm/npm-run-path@4.0.1/node_modules/npm-run-path/index.js
var require_npm_run_path = __commonJS((exports2, module2) => {
  "use strict";
  const path9 = require("path");
  const pathKey = require_path_key();
  const npmRunPath = (options) => {
    options = {
      cwd: process.cwd(),
      path: process.env[pathKey()],
      execPath: process.execPath,
      ...options
    };
    let previous;
    let cwdPath = path9.resolve(options.cwd);
    const result = [];
    while (previous !== cwdPath) {
      result.push(path9.join(cwdPath, "node_modules/.bin"));
      previous = cwdPath;
      cwdPath = path9.resolve(cwdPath, "..");
    }
    const execPathDir = path9.resolve(options.cwd, options.execPath, "..");
    result.push(execPathDir);
    return result.concat(options.path).join(path9.delimiter);
  };
  module2.exports = npmRunPath;
  module2.exports.default = npmRunPath;
  module2.exports.env = (options) => {
    options = {
      env: process.env,
      ...options
    };
    const env = {...options.env};
    const path10 = pathKey({env});
    options.path = env[path10];
    env[path10] = module2.exports(options);
    return env;
  };
});

// ../../node_modules/.pnpm/mimic-fn@2.1.0/node_modules/mimic-fn/index.js
var require_mimic_fn = __commonJS((exports2, module2) => {
  "use strict";
  const mimicFn = (to, from) => {
    for (const prop of Reflect.ownKeys(from)) {
      Object.defineProperty(to, prop, Object.getOwnPropertyDescriptor(from, prop));
    }
    return to;
  };
  module2.exports = mimicFn;
  module2.exports.default = mimicFn;
});

// ../../node_modules/.pnpm/onetime@5.1.0/node_modules/onetime/index.js
var require_onetime = __commonJS((exports2, module2) => {
  "use strict";
  const mimicFn = require_mimic_fn();
  const calledFunctions = new WeakMap();
  const oneTime = (fn, options = {}) => {
    if (typeof fn !== "function") {
      throw new TypeError("Expected a function");
    }
    let ret;
    let isCalled = false;
    let callCount = 0;
    const functionName = fn.displayName || fn.name || "<anonymous>";
    const onetime = function(...args) {
      calledFunctions.set(onetime, ++callCount);
      if (isCalled) {
        if (options.throw === true) {
          throw new Error(`Function \`${functionName}\` can only be called once`);
        }
        return ret;
      }
      isCalled = true;
      ret = fn.apply(this, args);
      fn = null;
      return ret;
    };
    mimicFn(onetime, fn);
    calledFunctions.set(onetime, callCount);
    return onetime;
  };
  module2.exports = oneTime;
  module2.exports.default = oneTime;
  module2.exports.callCount = (fn) => {
    if (!calledFunctions.has(fn)) {
      throw new Error(`The given function \`${fn.name}\` is not wrapped by the \`onetime\` package`);
    }
    return calledFunctions.get(fn);
  };
});

// ../../node_modules/.pnpm/human-signals@1.1.1/node_modules/human-signals/build/src/core.js
var require_core = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.SIGNALS = void 0;
  const SIGNALS = [
    {
      name: "SIGHUP",
      number: 1,
      action: "terminate",
      description: "Terminal closed",
      standard: "posix"
    },
    {
      name: "SIGINT",
      number: 2,
      action: "terminate",
      description: "User interruption with CTRL-C",
      standard: "ansi"
    },
    {
      name: "SIGQUIT",
      number: 3,
      action: "core",
      description: "User interruption with CTRL-\\",
      standard: "posix"
    },
    {
      name: "SIGILL",
      number: 4,
      action: "core",
      description: "Invalid machine instruction",
      standard: "ansi"
    },
    {
      name: "SIGTRAP",
      number: 5,
      action: "core",
      description: "Debugger breakpoint",
      standard: "posix"
    },
    {
      name: "SIGABRT",
      number: 6,
      action: "core",
      description: "Aborted",
      standard: "ansi"
    },
    {
      name: "SIGIOT",
      number: 6,
      action: "core",
      description: "Aborted",
      standard: "bsd"
    },
    {
      name: "SIGBUS",
      number: 7,
      action: "core",
      description: "Bus error due to misaligned, non-existing address or paging error",
      standard: "bsd"
    },
    {
      name: "SIGEMT",
      number: 7,
      action: "terminate",
      description: "Command should be emulated but is not implemented",
      standard: "other"
    },
    {
      name: "SIGFPE",
      number: 8,
      action: "core",
      description: "Floating point arithmetic error",
      standard: "ansi"
    },
    {
      name: "SIGKILL",
      number: 9,
      action: "terminate",
      description: "Forced termination",
      standard: "posix",
      forced: true
    },
    {
      name: "SIGUSR1",
      number: 10,
      action: "terminate",
      description: "Application-specific signal",
      standard: "posix"
    },
    {
      name: "SIGSEGV",
      number: 11,
      action: "core",
      description: "Segmentation fault",
      standard: "ansi"
    },
    {
      name: "SIGUSR2",
      number: 12,
      action: "terminate",
      description: "Application-specific signal",
      standard: "posix"
    },
    {
      name: "SIGPIPE",
      number: 13,
      action: "terminate",
      description: "Broken pipe or socket",
      standard: "posix"
    },
    {
      name: "SIGALRM",
      number: 14,
      action: "terminate",
      description: "Timeout or timer",
      standard: "posix"
    },
    {
      name: "SIGTERM",
      number: 15,
      action: "terminate",
      description: "Termination",
      standard: "ansi"
    },
    {
      name: "SIGSTKFLT",
      number: 16,
      action: "terminate",
      description: "Stack is empty or overflowed",
      standard: "other"
    },
    {
      name: "SIGCHLD",
      number: 17,
      action: "ignore",
      description: "Child process terminated, paused or unpaused",
      standard: "posix"
    },
    {
      name: "SIGCLD",
      number: 17,
      action: "ignore",
      description: "Child process terminated, paused or unpaused",
      standard: "other"
    },
    {
      name: "SIGCONT",
      number: 18,
      action: "unpause",
      description: "Unpaused",
      standard: "posix",
      forced: true
    },
    {
      name: "SIGSTOP",
      number: 19,
      action: "pause",
      description: "Paused",
      standard: "posix",
      forced: true
    },
    {
      name: "SIGTSTP",
      number: 20,
      action: "pause",
      description: 'Paused using CTRL-Z or "suspend"',
      standard: "posix"
    },
    {
      name: "SIGTTIN",
      number: 21,
      action: "pause",
      description: "Background process cannot read terminal input",
      standard: "posix"
    },
    {
      name: "SIGBREAK",
      number: 21,
      action: "terminate",
      description: "User interruption with CTRL-BREAK",
      standard: "other"
    },
    {
      name: "SIGTTOU",
      number: 22,
      action: "pause",
      description: "Background process cannot write to terminal output",
      standard: "posix"
    },
    {
      name: "SIGURG",
      number: 23,
      action: "ignore",
      description: "Socket received out-of-band data",
      standard: "bsd"
    },
    {
      name: "SIGXCPU",
      number: 24,
      action: "core",
      description: "Process timed out",
      standard: "bsd"
    },
    {
      name: "SIGXFSZ",
      number: 25,
      action: "core",
      description: "File too big",
      standard: "bsd"
    },
    {
      name: "SIGVTALRM",
      number: 26,
      action: "terminate",
      description: "Timeout or timer",
      standard: "bsd"
    },
    {
      name: "SIGPROF",
      number: 27,
      action: "terminate",
      description: "Timeout or timer",
      standard: "bsd"
    },
    {
      name: "SIGWINCH",
      number: 28,
      action: "ignore",
      description: "Terminal window size changed",
      standard: "bsd"
    },
    {
      name: "SIGIO",
      number: 29,
      action: "terminate",
      description: "I/O is available",
      standard: "other"
    },
    {
      name: "SIGPOLL",
      number: 29,
      action: "terminate",
      description: "Watched event",
      standard: "other"
    },
    {
      name: "SIGINFO",
      number: 29,
      action: "ignore",
      description: "Request for process information",
      standard: "other"
    },
    {
      name: "SIGPWR",
      number: 30,
      action: "terminate",
      description: "Device running out of power",
      standard: "systemv"
    },
    {
      name: "SIGSYS",
      number: 31,
      action: "core",
      description: "Invalid system call",
      standard: "other"
    },
    {
      name: "SIGUNUSED",
      number: 31,
      action: "terminate",
      description: "Invalid system call",
      standard: "other"
    }
  ];
  exports2.SIGNALS = SIGNALS;
});

// ../../node_modules/.pnpm/human-signals@1.1.1/node_modules/human-signals/build/src/realtime.js
var require_realtime = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.SIGRTMAX = exports2.getRealtimeSignals = void 0;
  const getRealtimeSignals = function() {
    const length = SIGRTMAX - SIGRTMIN + 1;
    return Array.from({length}, getRealtimeSignal);
  };
  exports2.getRealtimeSignals = getRealtimeSignals;
  const getRealtimeSignal = function(value, index) {
    return {
      name: `SIGRT${index + 1}`,
      number: SIGRTMIN + index,
      action: "terminate",
      description: "Application-specific signal (realtime)",
      standard: "posix"
    };
  };
  const SIGRTMIN = 34;
  const SIGRTMAX = 64;
  exports2.SIGRTMAX = SIGRTMAX;
});

// ../../node_modules/.pnpm/human-signals@1.1.1/node_modules/human-signals/build/src/signals.js
var require_signals = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.getSignals = void 0;
  var _os = require("os");
  var _core = require_core();
  var _realtime = require_realtime();
  const getSignals = function() {
    const realtimeSignals = (0, _realtime.getRealtimeSignals)();
    const signals = [..._core.SIGNALS, ...realtimeSignals].map(normalizeSignal);
    return signals;
  };
  exports2.getSignals = getSignals;
  const normalizeSignal = function({
    name,
    number: defaultNumber,
    description,
    action,
    forced = false,
    standard
  }) {
    const {
      signals: {[name]: constantSignal}
    } = _os.constants;
    const supported = constantSignal !== void 0;
    const number = supported ? constantSignal : defaultNumber;
    return {name, number, description, supported, action, forced, standard};
  };
});

// ../../node_modules/.pnpm/human-signals@1.1.1/node_modules/human-signals/build/src/main.js
var require_main = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.signalsByNumber = exports2.signalsByName = void 0;
  var _os = require("os");
  var _signals = require_signals();
  var _realtime = require_realtime();
  const getSignalsByName = function() {
    const signals = (0, _signals.getSignals)();
    return signals.reduce(getSignalByName, {});
  };
  const getSignalByName = function(signalByNameMemo, {name, number, description, supported, action, forced, standard}) {
    return {
      ...signalByNameMemo,
      [name]: {name, number, description, supported, action, forced, standard}
    };
  };
  const signalsByName = getSignalsByName();
  exports2.signalsByName = signalsByName;
  const getSignalsByNumber = function() {
    const signals = (0, _signals.getSignals)();
    const length = _realtime.SIGRTMAX + 1;
    const signalsA = Array.from({length}, (value, number) => getSignalByNumber(number, signals));
    return Object.assign({}, ...signalsA);
  };
  const getSignalByNumber = function(number, signals) {
    const signal = findSignalByNumber(number, signals);
    if (signal === void 0) {
      return {};
    }
    const {name, description, supported, action, forced, standard} = signal;
    return {
      [number]: {
        name,
        number,
        description,
        supported,
        action,
        forced,
        standard
      }
    };
  };
  const findSignalByNumber = function(number, signals) {
    const signal = signals.find(({name}) => _os.constants.signals[name] === number);
    if (signal !== void 0) {
      return signal;
    }
    return signals.find((signalA) => signalA.number === number);
  };
  const signalsByNumber = getSignalsByNumber();
  exports2.signalsByNumber = signalsByNumber;
});

// ../../node_modules/.pnpm/execa@4.0.2/node_modules/execa/lib/error.js
var require_error = __commonJS((exports2, module2) => {
  "use strict";
  const {signalsByName} = require_main();
  const getErrorPrefix = ({timedOut, timeout, errorCode, signal, signalDescription, exitCode, isCanceled}) => {
    if (timedOut) {
      return `timed out after ${timeout} milliseconds`;
    }
    if (isCanceled) {
      return "was canceled";
    }
    if (errorCode !== void 0) {
      return `failed with ${errorCode}`;
    }
    if (signal !== void 0) {
      return `was killed with ${signal} (${signalDescription})`;
    }
    if (exitCode !== void 0) {
      return `failed with exit code ${exitCode}`;
    }
    return "failed";
  };
  const makeError = ({
    stdout,
    stderr,
    all,
    error,
    signal,
    exitCode,
    command,
    timedOut,
    isCanceled,
    killed,
    parsed: {options: {timeout}}
  }) => {
    exitCode = exitCode === null ? void 0 : exitCode;
    signal = signal === null ? void 0 : signal;
    const signalDescription = signal === void 0 ? void 0 : signalsByName[signal].description;
    const errorCode = error && error.code;
    const prefix = getErrorPrefix({timedOut, timeout, errorCode, signal, signalDescription, exitCode, isCanceled});
    const execaMessage = `Command ${prefix}: ${command}`;
    const isError = Object.prototype.toString.call(error) === "[object Error]";
    const shortMessage = isError ? `${execaMessage}
${error.message}` : execaMessage;
    const message = [shortMessage, stderr, stdout].filter(Boolean).join("\n");
    if (isError) {
      error.originalMessage = error.message;
      error.message = message;
    } else {
      error = new Error(message);
    }
    error.shortMessage = shortMessage;
    error.command = command;
    error.exitCode = exitCode;
    error.signal = signal;
    error.signalDescription = signalDescription;
    error.stdout = stdout;
    error.stderr = stderr;
    if (all !== void 0) {
      error.all = all;
    }
    if ("bufferedData" in error) {
      delete error.bufferedData;
    }
    error.failed = true;
    error.timedOut = Boolean(timedOut);
    error.isCanceled = isCanceled;
    error.killed = killed && !timedOut;
    return error;
  };
  module2.exports = makeError;
});

// ../../node_modules/.pnpm/execa@4.0.2/node_modules/execa/lib/stdio.js
var require_stdio = __commonJS((exports2, module2) => {
  "use strict";
  const aliases = ["stdin", "stdout", "stderr"];
  const hasAlias = (opts) => aliases.some((alias) => opts[alias] !== void 0);
  const normalizeStdio = (opts) => {
    if (!opts) {
      return;
    }
    const {stdio} = opts;
    if (stdio === void 0) {
      return aliases.map((alias) => opts[alias]);
    }
    if (hasAlias(opts)) {
      throw new Error(`It's not possible to provide \`stdio\` in combination with one of ${aliases.map((alias) => `\`${alias}\``).join(", ")}`);
    }
    if (typeof stdio === "string") {
      return stdio;
    }
    if (!Array.isArray(stdio)) {
      throw new TypeError(`Expected \`stdio\` to be of type \`string\` or \`Array\`, got \`${typeof stdio}\``);
    }
    const length = Math.max(stdio.length, aliases.length);
    return Array.from({length}, (value, index) => stdio[index]);
  };
  module2.exports = normalizeStdio;
  module2.exports.node = (opts) => {
    const stdio = normalizeStdio(opts);
    if (stdio === "ipc") {
      return "ipc";
    }
    if (stdio === void 0 || typeof stdio === "string") {
      return [stdio, stdio, stdio, "ipc"];
    }
    if (stdio.includes("ipc")) {
      return stdio;
    }
    return [...stdio, "ipc"];
  };
});

// ../../node_modules/.pnpm/signal-exit@3.0.3/node_modules/signal-exit/signals.js
var require_signals2 = __commonJS((exports2, module2) => {
  module2.exports = [
    "SIGABRT",
    "SIGALRM",
    "SIGHUP",
    "SIGINT",
    "SIGTERM"
  ];
  if (process.platform !== "win32") {
    module2.exports.push("SIGVTALRM", "SIGXCPU", "SIGXFSZ", "SIGUSR2", "SIGTRAP", "SIGSYS", "SIGQUIT", "SIGIOT");
  }
  if (process.platform === "linux") {
    module2.exports.push("SIGIO", "SIGPOLL", "SIGPWR", "SIGSTKFLT", "SIGUNUSED");
  }
});

// ../../node_modules/.pnpm/signal-exit@3.0.3/node_modules/signal-exit/index.js
var require_signal_exit = __commonJS((exports2, module2) => {
  var assert = require("assert");
  var signals = require_signals2();
  var isWin = /^win/i.test(process.platform);
  var EE = require("events");
  if (typeof EE !== "function") {
    EE = EE.EventEmitter;
  }
  var emitter;
  if (process.__signal_exit_emitter__) {
    emitter = process.__signal_exit_emitter__;
  } else {
    emitter = process.__signal_exit_emitter__ = new EE();
    emitter.count = 0;
    emitter.emitted = {};
  }
  if (!emitter.infinite) {
    emitter.setMaxListeners(Infinity);
    emitter.infinite = true;
  }
  module2.exports = function(cb, opts) {
    assert.equal(typeof cb, "function", "a callback must be provided for exit handler");
    if (loaded === false) {
      load();
    }
    var ev = "exit";
    if (opts && opts.alwaysLast) {
      ev = "afterexit";
    }
    var remove2 = function() {
      emitter.removeListener(ev, cb);
      if (emitter.listeners("exit").length === 0 && emitter.listeners("afterexit").length === 0) {
        unload();
      }
    };
    emitter.on(ev, cb);
    return remove2;
  };
  module2.exports.unload = unload;
  function unload() {
    if (!loaded) {
      return;
    }
    loaded = false;
    signals.forEach(function(sig) {
      try {
        process.removeListener(sig, sigListeners[sig]);
      } catch (er) {
      }
    });
    process.emit = originalProcessEmit;
    process.reallyExit = originalProcessReallyExit;
    emitter.count -= 1;
  }
  function emit(event, code, signal) {
    if (emitter.emitted[event]) {
      return;
    }
    emitter.emitted[event] = true;
    emitter.emit(event, code, signal);
  }
  var sigListeners = {};
  signals.forEach(function(sig) {
    sigListeners[sig] = function listener() {
      var listeners = process.listeners(sig);
      if (listeners.length === emitter.count) {
        unload();
        emit("exit", null, sig);
        emit("afterexit", null, sig);
        if (isWin && sig === "SIGHUP") {
          sig = "SIGINT";
        }
        process.kill(process.pid, sig);
      }
    };
  });
  module2.exports.signals = function() {
    return signals;
  };
  module2.exports.load = load;
  var loaded = false;
  function load() {
    if (loaded) {
      return;
    }
    loaded = true;
    emitter.count += 1;
    signals = signals.filter(function(sig) {
      try {
        process.on(sig, sigListeners[sig]);
        return true;
      } catch (er) {
        return false;
      }
    });
    process.emit = processEmit;
    process.reallyExit = processReallyExit;
  }
  var originalProcessReallyExit = process.reallyExit;
  function processReallyExit(code) {
    process.exitCode = code || 0;
    emit("exit", process.exitCode, null);
    emit("afterexit", process.exitCode, null);
    originalProcessReallyExit.call(process, process.exitCode);
  }
  var originalProcessEmit = process.emit;
  function processEmit(ev, arg) {
    if (ev === "exit") {
      if (arg !== void 0) {
        process.exitCode = arg;
      }
      var ret = originalProcessEmit.apply(this, arguments);
      emit("exit", process.exitCode, null);
      emit("afterexit", process.exitCode, null);
      return ret;
    } else {
      return originalProcessEmit.apply(this, arguments);
    }
  }
});

// ../../node_modules/.pnpm/execa@4.0.2/node_modules/execa/lib/kill.js
var require_kill = __commonJS((exports2, module2) => {
  "use strict";
  const os = require("os");
  const onExit = require_signal_exit();
  const DEFAULT_FORCE_KILL_TIMEOUT = 1e3 * 5;
  const spawnedKill = (kill, signal = "SIGTERM", options = {}) => {
    const killResult = kill(signal);
    setKillTimeout(kill, signal, options, killResult);
    return killResult;
  };
  const setKillTimeout = (kill, signal, options, killResult) => {
    if (!shouldForceKill(signal, options, killResult)) {
      return;
    }
    const timeout = getForceKillAfterTimeout(options);
    const t = setTimeout(() => {
      kill("SIGKILL");
    }, timeout);
    if (t.unref) {
      t.unref();
    }
  };
  const shouldForceKill = (signal, {forceKillAfterTimeout}, killResult) => {
    return isSigterm(signal) && forceKillAfterTimeout !== false && killResult;
  };
  const isSigterm = (signal) => {
    return signal === os.constants.signals.SIGTERM || typeof signal === "string" && signal.toUpperCase() === "SIGTERM";
  };
  const getForceKillAfterTimeout = ({forceKillAfterTimeout = true}) => {
    if (forceKillAfterTimeout === true) {
      return DEFAULT_FORCE_KILL_TIMEOUT;
    }
    if (!Number.isInteger(forceKillAfterTimeout) || forceKillAfterTimeout < 0) {
      throw new TypeError(`Expected the \`forceKillAfterTimeout\` option to be a non-negative integer, got \`${forceKillAfterTimeout}\` (${typeof forceKillAfterTimeout})`);
    }
    return forceKillAfterTimeout;
  };
  const spawnedCancel = (spawned, context) => {
    const killResult = spawned.kill();
    if (killResult) {
      context.isCanceled = true;
    }
  };
  const timeoutKill = (spawned, signal, reject) => {
    spawned.kill(signal);
    reject(Object.assign(new Error("Timed out"), {timedOut: true, signal}));
  };
  const setupTimeout = (spawned, {timeout, killSignal = "SIGTERM"}, spawnedPromise) => {
    if (timeout === 0 || timeout === void 0) {
      return spawnedPromise;
    }
    if (!Number.isInteger(timeout) || timeout < 0) {
      throw new TypeError(`Expected the \`timeout\` option to be a non-negative integer, got \`${timeout}\` (${typeof timeout})`);
    }
    let timeoutId;
    const timeoutPromise = new Promise((resolve, reject) => {
      timeoutId = setTimeout(() => {
        timeoutKill(spawned, killSignal, reject);
      }, timeout);
    });
    const safeSpawnedPromise = spawnedPromise.finally(() => {
      clearTimeout(timeoutId);
    });
    return Promise.race([timeoutPromise, safeSpawnedPromise]);
  };
  const setExitHandler = async (spawned, {cleanup, detached}, timedPromise) => {
    if (!cleanup || detached) {
      return timedPromise;
    }
    const removeExitHandler = onExit(() => {
      spawned.kill();
    });
    return timedPromise.finally(() => {
      removeExitHandler();
    });
  };
  module2.exports = {
    spawnedKill,
    spawnedCancel,
    setupTimeout,
    setExitHandler
  };
});

// ../../node_modules/.pnpm/is-stream@2.0.0/node_modules/is-stream/index.js
var require_is_stream = __commonJS((exports2, module2) => {
  "use strict";
  const isStream = (stream) => stream !== null && typeof stream === "object" && typeof stream.pipe === "function";
  isStream.writable = (stream) => isStream(stream) && stream.writable !== false && typeof stream._write === "function" && typeof stream._writableState === "object";
  isStream.readable = (stream) => isStream(stream) && stream.readable !== false && typeof stream._read === "function" && typeof stream._readableState === "object";
  isStream.duplex = (stream) => isStream.writable(stream) && isStream.readable(stream);
  isStream.transform = (stream) => isStream.duplex(stream) && typeof stream._transform === "function" && typeof stream._transformState === "object";
  module2.exports = isStream;
});

// ../../node_modules/.pnpm/wrappy@1.0.2/node_modules/wrappy/wrappy.js
var require_wrappy = __commonJS((exports2, module2) => {
  module2.exports = wrappy;
  function wrappy(fn, cb) {
    if (fn && cb)
      return wrappy(fn)(cb);
    if (typeof fn !== "function")
      throw new TypeError("need wrapper function");
    Object.keys(fn).forEach(function(k) {
      wrapper[k] = fn[k];
    });
    return wrapper;
    function wrapper() {
      var args = new Array(arguments.length);
      for (var i = 0; i < args.length; i++) {
        args[i] = arguments[i];
      }
      var ret = fn.apply(this, args);
      var cb2 = args[args.length - 1];
      if (typeof ret === "function" && ret !== cb2) {
        Object.keys(cb2).forEach(function(k) {
          ret[k] = cb2[k];
        });
      }
      return ret;
    }
  }
});

// ../../node_modules/.pnpm/once@1.4.0/node_modules/once/once.js
var require_once = __commonJS((exports2, module2) => {
  var wrappy = require_wrappy();
  module2.exports = wrappy(once);
  module2.exports.strict = wrappy(onceStrict);
  once.proto = once(function() {
    Object.defineProperty(Function.prototype, "once", {
      value: function() {
        return once(this);
      },
      configurable: true
    });
    Object.defineProperty(Function.prototype, "onceStrict", {
      value: function() {
        return onceStrict(this);
      },
      configurable: true
    });
  });
  function once(fn) {
    var f = function() {
      if (f.called)
        return f.value;
      f.called = true;
      return f.value = fn.apply(this, arguments);
    };
    f.called = false;
    return f;
  }
  function onceStrict(fn) {
    var f = function() {
      if (f.called)
        throw new Error(f.onceError);
      f.called = true;
      return f.value = fn.apply(this, arguments);
    };
    var name = fn.name || "Function wrapped with `once`";
    f.onceError = name + " shouldn't be called more than once";
    f.called = false;
    return f;
  }
});

// ../../node_modules/.pnpm/end-of-stream@1.4.4/node_modules/end-of-stream/index.js
var require_end_of_stream = __commonJS((exports2, module2) => {
  var once = require_once();
  var noop = function() {
  };
  var isRequest = function(stream) {
    return stream.setHeader && typeof stream.abort === "function";
  };
  var isChildProcess = function(stream) {
    return stream.stdio && Array.isArray(stream.stdio) && stream.stdio.length === 3;
  };
  var eos = function(stream, opts, callback) {
    if (typeof opts === "function")
      return eos(stream, null, opts);
    if (!opts)
      opts = {};
    callback = once(callback || noop);
    var ws = stream._writableState;
    var rs = stream._readableState;
    var readable = opts.readable || opts.readable !== false && stream.readable;
    var writable = opts.writable || opts.writable !== false && stream.writable;
    var cancelled = false;
    var onlegacyfinish = function() {
      if (!stream.writable)
        onfinish();
    };
    var onfinish = function() {
      writable = false;
      if (!readable)
        callback.call(stream);
    };
    var onend = function() {
      readable = false;
      if (!writable)
        callback.call(stream);
    };
    var onexit = function(exitCode) {
      callback.call(stream, exitCode ? new Error("exited with error code: " + exitCode) : null);
    };
    var onerror = function(err) {
      callback.call(stream, err);
    };
    var onclose = function() {
      process.nextTick(onclosenexttick);
    };
    var onclosenexttick = function() {
      if (cancelled)
        return;
      if (readable && !(rs && (rs.ended && !rs.destroyed)))
        return callback.call(stream, new Error("premature close"));
      if (writable && !(ws && (ws.ended && !ws.destroyed)))
        return callback.call(stream, new Error("premature close"));
    };
    var onrequest = function() {
      stream.req.on("finish", onfinish);
    };
    if (isRequest(stream)) {
      stream.on("complete", onfinish);
      stream.on("abort", onclose);
      if (stream.req)
        onrequest();
      else
        stream.on("request", onrequest);
    } else if (writable && !ws) {
      stream.on("end", onlegacyfinish);
      stream.on("close", onlegacyfinish);
    }
    if (isChildProcess(stream))
      stream.on("exit", onexit);
    stream.on("end", onend);
    stream.on("finish", onfinish);
    if (opts.error !== false)
      stream.on("error", onerror);
    stream.on("close", onclose);
    return function() {
      cancelled = true;
      stream.removeListener("complete", onfinish);
      stream.removeListener("abort", onclose);
      stream.removeListener("request", onrequest);
      if (stream.req)
        stream.req.removeListener("finish", onfinish);
      stream.removeListener("end", onlegacyfinish);
      stream.removeListener("close", onlegacyfinish);
      stream.removeListener("finish", onfinish);
      stream.removeListener("exit", onexit);
      stream.removeListener("end", onend);
      stream.removeListener("error", onerror);
      stream.removeListener("close", onclose);
    };
  };
  module2.exports = eos;
});

// ../../node_modules/.pnpm/pump@3.0.0/node_modules/pump/index.js
var require_pump = __commonJS((exports2, module2) => {
  var once = require_once();
  var eos = require_end_of_stream();
  var fs3 = require("fs");
  var noop = function() {
  };
  var ancient = /^v?\.0/.test(process.version);
  var isFn = function(fn) {
    return typeof fn === "function";
  };
  var isFS = function(stream) {
    if (!ancient)
      return false;
    if (!fs3)
      return false;
    return (stream instanceof (fs3.ReadStream || noop) || stream instanceof (fs3.WriteStream || noop)) && isFn(stream.close);
  };
  var isRequest = function(stream) {
    return stream.setHeader && isFn(stream.abort);
  };
  var destroyer = function(stream, reading, writing, callback) {
    callback = once(callback);
    var closed = false;
    stream.on("close", function() {
      closed = true;
    });
    eos(stream, {readable: reading, writable: writing}, function(err) {
      if (err)
        return callback(err);
      closed = true;
      callback();
    });
    var destroyed = false;
    return function(err) {
      if (closed)
        return;
      if (destroyed)
        return;
      destroyed = true;
      if (isFS(stream))
        return stream.close(noop);
      if (isRequest(stream))
        return stream.abort();
      if (isFn(stream.destroy))
        return stream.destroy();
      callback(err || new Error("stream was destroyed"));
    };
  };
  var call = function(fn) {
    fn();
  };
  var pipe = function(from, to) {
    return from.pipe(to);
  };
  var pump = function() {
    var streams = Array.prototype.slice.call(arguments);
    var callback = isFn(streams[streams.length - 1] || noop) && streams.pop() || noop;
    if (Array.isArray(streams[0]))
      streams = streams[0];
    if (streams.length < 2)
      throw new Error("pump requires two streams per minimum");
    var error;
    var destroys = streams.map(function(stream, i) {
      var reading = i < streams.length - 1;
      var writing = i > 0;
      return destroyer(stream, reading, writing, function(err) {
        if (!error)
          error = err;
        if (err)
          destroys.forEach(call);
        if (reading)
          return;
        destroys.forEach(call);
        callback(error);
      });
    });
    return streams.reduce(pipe);
  };
  module2.exports = pump;
});

// ../../node_modules/.pnpm/get-stream@5.1.0/node_modules/get-stream/buffer-stream.js
var require_buffer_stream = __commonJS((exports2, module2) => {
  "use strict";
  const {PassThrough: PassThroughStream} = require("stream");
  module2.exports = (options) => {
    options = {...options};
    const {array} = options;
    let {encoding} = options;
    const isBuffer = encoding === "buffer";
    let objectMode = false;
    if (array) {
      objectMode = !(encoding || isBuffer);
    } else {
      encoding = encoding || "utf8";
    }
    if (isBuffer) {
      encoding = null;
    }
    const stream = new PassThroughStream({objectMode});
    if (encoding) {
      stream.setEncoding(encoding);
    }
    let length = 0;
    const chunks = [];
    stream.on("data", (chunk) => {
      chunks.push(chunk);
      if (objectMode) {
        length = chunks.length;
      } else {
        length += chunk.length;
      }
    });
    stream.getBufferedValue = () => {
      if (array) {
        return chunks;
      }
      return isBuffer ? Buffer.concat(chunks, length) : chunks.join("");
    };
    stream.getBufferedLength = () => length;
    return stream;
  };
});

// ../../node_modules/.pnpm/get-stream@5.1.0/node_modules/get-stream/index.js
var require_get_stream = __commonJS((exports2, module2) => {
  "use strict";
  const pump = require_pump();
  const bufferStream = require_buffer_stream();
  class MaxBufferError extends Error {
    constructor() {
      super("maxBuffer exceeded");
      this.name = "MaxBufferError";
    }
  }
  async function getStream(inputStream, options) {
    if (!inputStream) {
      return Promise.reject(new Error("Expected a stream"));
    }
    options = {
      maxBuffer: Infinity,
      ...options
    };
    const {maxBuffer} = options;
    let stream;
    await new Promise((resolve, reject) => {
      const rejectPromise = (error) => {
        if (error) {
          error.bufferedData = stream.getBufferedValue();
        }
        reject(error);
      };
      stream = pump(inputStream, bufferStream(options), (error) => {
        if (error) {
          rejectPromise(error);
          return;
        }
        resolve();
      });
      stream.on("data", () => {
        if (stream.getBufferedLength() > maxBuffer) {
          rejectPromise(new MaxBufferError());
        }
      });
    });
    return stream.getBufferedValue();
  }
  module2.exports = getStream;
  module2.exports.default = getStream;
  module2.exports.buffer = (stream, options) => getStream(stream, {...options, encoding: "buffer"});
  module2.exports.array = (stream, options) => getStream(stream, {...options, array: true});
  module2.exports.MaxBufferError = MaxBufferError;
});

// ../../node_modules/.pnpm/merge-stream@2.0.0/node_modules/merge-stream/index.js
var require_merge_stream = __commonJS((exports2, module2) => {
  "use strict";
  const {PassThrough} = require("stream");
  module2.exports = function() {
    var sources = [];
    var output = new PassThrough({objectMode: true});
    output.setMaxListeners(0);
    output.add = add;
    output.isEmpty = isEmpty;
    output.on("unpipe", remove2);
    Array.prototype.slice.call(arguments).forEach(add);
    return output;
    function add(source) {
      if (Array.isArray(source)) {
        source.forEach(add);
        return this;
      }
      sources.push(source);
      source.once("end", remove2.bind(null, source));
      source.once("error", output.emit.bind(output, "error"));
      source.pipe(output, {end: false});
      return this;
    }
    function isEmpty() {
      return sources.length == 0;
    }
    function remove2(source) {
      sources = sources.filter(function(it) {
        return it !== source;
      });
      if (!sources.length && output.readable) {
        output.end();
      }
    }
  };
});

// ../../node_modules/.pnpm/execa@4.0.2/node_modules/execa/lib/stream.js
var require_stream = __commonJS((exports2, module2) => {
  "use strict";
  const isStream = require_is_stream();
  const getStream = require_get_stream();
  const mergeStream = require_merge_stream();
  const handleInput = (spawned, input) => {
    if (input === void 0 || spawned.stdin === void 0) {
      return;
    }
    if (isStream(input)) {
      input.pipe(spawned.stdin);
    } else {
      spawned.stdin.end(input);
    }
  };
  const makeAllStream = (spawned, {all}) => {
    if (!all || !spawned.stdout && !spawned.stderr) {
      return;
    }
    const mixed = mergeStream();
    if (spawned.stdout) {
      mixed.add(spawned.stdout);
    }
    if (spawned.stderr) {
      mixed.add(spawned.stderr);
    }
    return mixed;
  };
  const getBufferedData = async (stream, streamPromise) => {
    if (!stream) {
      return;
    }
    stream.destroy();
    try {
      return await streamPromise;
    } catch (error) {
      return error.bufferedData;
    }
  };
  const getStreamPromise = (stream, {encoding, buffer, maxBuffer}) => {
    if (!stream || !buffer) {
      return;
    }
    if (encoding) {
      return getStream(stream, {encoding, maxBuffer});
    }
    return getStream.buffer(stream, {maxBuffer});
  };
  const getSpawnedResult = async ({stdout, stderr, all}, {encoding, buffer, maxBuffer}, processDone) => {
    const stdoutPromise = getStreamPromise(stdout, {encoding, buffer, maxBuffer});
    const stderrPromise = getStreamPromise(stderr, {encoding, buffer, maxBuffer});
    const allPromise = getStreamPromise(all, {encoding, buffer, maxBuffer: maxBuffer * 2});
    try {
      return await Promise.all([processDone, stdoutPromise, stderrPromise, allPromise]);
    } catch (error) {
      return Promise.all([
        {error, signal: error.signal, timedOut: error.timedOut},
        getBufferedData(stdout, stdoutPromise),
        getBufferedData(stderr, stderrPromise),
        getBufferedData(all, allPromise)
      ]);
    }
  };
  const validateInputSync = ({input}) => {
    if (isStream(input)) {
      throw new TypeError("The `input` option cannot be a stream in sync mode");
    }
  };
  module2.exports = {
    handleInput,
    makeAllStream,
    getSpawnedResult,
    validateInputSync
  };
});

// ../../node_modules/.pnpm/execa@4.0.2/node_modules/execa/lib/promise.js
var require_promise = __commonJS((exports2, module2) => {
  "use strict";
  const nativePromisePrototype = (async () => {
  })().constructor.prototype;
  const descriptors = ["then", "catch", "finally"].map((property) => [
    property,
    Reflect.getOwnPropertyDescriptor(nativePromisePrototype, property)
  ]);
  const mergePromise = (spawned, promise) => {
    for (const [property, descriptor] of descriptors) {
      const value = typeof promise === "function" ? (...args) => Reflect.apply(descriptor.value, promise(), args) : descriptor.value.bind(promise);
      Reflect.defineProperty(spawned, property, {...descriptor, value});
    }
    return spawned;
  };
  const getSpawnedPromise = (spawned) => {
    return new Promise((resolve, reject) => {
      spawned.on("exit", (exitCode, signal) => {
        resolve({exitCode, signal});
      });
      spawned.on("error", (error) => {
        reject(error);
      });
      if (spawned.stdin) {
        spawned.stdin.on("error", (error) => {
          reject(error);
        });
      }
    });
  };
  module2.exports = {
    mergePromise,
    getSpawnedPromise
  };
});

// ../../node_modules/.pnpm/execa@4.0.2/node_modules/execa/lib/command.js
var require_command = __commonJS((exports2, module2) => {
  "use strict";
  const SPACES_REGEXP = / +/g;
  const joinCommand = (file, args = []) => {
    if (!Array.isArray(args)) {
      return file;
    }
    return [file, ...args].join(" ");
  };
  const handleEscaping = (tokens, token, index) => {
    if (index === 0) {
      return [token];
    }
    const previousToken = tokens[tokens.length - 1];
    if (previousToken.endsWith("\\")) {
      return [...tokens.slice(0, -1), `${previousToken.slice(0, -1)} ${token}`];
    }
    return [...tokens, token];
  };
  const parseCommand = (command) => {
    return command.trim().split(SPACES_REGEXP).reduce(handleEscaping, []);
  };
  module2.exports = {
    joinCommand,
    parseCommand
  };
});

// ../../node_modules/.pnpm/execa@4.0.2/node_modules/execa/index.js
var require_execa = __commonJS((exports2, module2) => {
  "use strict";
  const path9 = require("path");
  const childProcess = require("child_process");
  const crossSpawn = require_cross_spawn();
  const stripFinalNewline = require_strip_final_newline();
  const npmRunPath = require_npm_run_path();
  const onetime = require_onetime();
  const makeError = require_error();
  const normalizeStdio = require_stdio();
  const {spawnedKill, spawnedCancel, setupTimeout, setExitHandler} = require_kill();
  const {handleInput, getSpawnedResult, makeAllStream, validateInputSync} = require_stream();
  const {mergePromise, getSpawnedPromise} = require_promise();
  const {joinCommand, parseCommand} = require_command();
  const DEFAULT_MAX_BUFFER = 1e3 * 1e3 * 100;
  const getEnv = ({env: envOption, extendEnv, preferLocal, localDir, execPath}) => {
    const env = extendEnv ? {...process.env, ...envOption} : envOption;
    if (preferLocal) {
      return npmRunPath.env({env, cwd: localDir, execPath});
    }
    return env;
  };
  const handleArgs = (file, args, options = {}) => {
    const parsed = crossSpawn._parse(file, args, options);
    file = parsed.command;
    args = parsed.args;
    options = parsed.options;
    options = {
      maxBuffer: DEFAULT_MAX_BUFFER,
      buffer: true,
      stripFinalNewline: true,
      extendEnv: true,
      preferLocal: false,
      localDir: options.cwd || process.cwd(),
      execPath: process.execPath,
      encoding: "utf8",
      reject: true,
      cleanup: true,
      all: false,
      windowsHide: true,
      ...options
    };
    options.env = getEnv(options);
    options.stdio = normalizeStdio(options);
    if (process.platform === "win32" && path9.basename(file, ".exe") === "cmd") {
      args.unshift("/q");
    }
    return {file, args, options, parsed};
  };
  const handleOutput = (options, value, error) => {
    if (typeof value !== "string" && !Buffer.isBuffer(value)) {
      return error === void 0 ? void 0 : "";
    }
    if (options.stripFinalNewline) {
      return stripFinalNewline(value);
    }
    return value;
  };
  const execa = (file, args, options) => {
    const parsed = handleArgs(file, args, options);
    const command = joinCommand(file, args);
    let spawned;
    try {
      spawned = childProcess.spawn(parsed.file, parsed.args, parsed.options);
    } catch (error) {
      const dummySpawned = new childProcess.ChildProcess();
      const errorPromise = Promise.reject(makeError({
        error,
        stdout: "",
        stderr: "",
        all: "",
        command,
        parsed,
        timedOut: false,
        isCanceled: false,
        killed: false
      }));
      return mergePromise(dummySpawned, errorPromise);
    }
    const spawnedPromise = getSpawnedPromise(spawned);
    const timedPromise = setupTimeout(spawned, parsed.options, spawnedPromise);
    const processDone = setExitHandler(spawned, parsed.options, timedPromise);
    const context = {isCanceled: false};
    spawned.kill = spawnedKill.bind(null, spawned.kill.bind(spawned));
    spawned.cancel = spawnedCancel.bind(null, spawned, context);
    const handlePromise = async () => {
      const [{error, exitCode, signal, timedOut}, stdoutResult, stderrResult, allResult] = await getSpawnedResult(spawned, parsed.options, processDone);
      const stdout = handleOutput(parsed.options, stdoutResult);
      const stderr = handleOutput(parsed.options, stderrResult);
      const all = handleOutput(parsed.options, allResult);
      if (error || exitCode !== 0 || signal !== null) {
        const returnedError = makeError({
          error,
          exitCode,
          signal,
          stdout,
          stderr,
          all,
          command,
          parsed,
          timedOut,
          isCanceled: context.isCanceled,
          killed: spawned.killed
        });
        if (!parsed.options.reject) {
          return returnedError;
        }
        throw returnedError;
      }
      return {
        command,
        exitCode: 0,
        stdout,
        stderr,
        all,
        failed: false,
        timedOut: false,
        isCanceled: false,
        killed: false
      };
    };
    const handlePromiseOnce = onetime(handlePromise);
    crossSpawn._enoent.hookChildProcess(spawned, parsed.parsed);
    handleInput(spawned, parsed.options.input);
    spawned.all = makeAllStream(spawned, parsed.options);
    return mergePromise(spawned, handlePromiseOnce);
  };
  module2.exports = execa;
  module2.exports.sync = (file, args, options) => {
    const parsed = handleArgs(file, args, options);
    const command = joinCommand(file, args);
    validateInputSync(parsed.options);
    let result;
    try {
      result = childProcess.spawnSync(parsed.file, parsed.args, parsed.options);
    } catch (error) {
      throw makeError({
        error,
        stdout: "",
        stderr: "",
        all: "",
        command,
        parsed,
        timedOut: false,
        isCanceled: false,
        killed: false
      });
    }
    const stdout = handleOutput(parsed.options, result.stdout, result.error);
    const stderr = handleOutput(parsed.options, result.stderr, result.error);
    if (result.error || result.status !== 0 || result.signal !== null) {
      const error = makeError({
        stdout,
        stderr,
        error: result.error,
        signal: result.signal,
        exitCode: result.status,
        command,
        parsed,
        timedOut: result.error && result.error.code === "ETIMEDOUT",
        isCanceled: false,
        killed: result.signal !== null
      });
      if (!parsed.options.reject) {
        return error;
      }
      throw error;
    }
    return {
      command,
      exitCode: 0,
      stdout,
      stderr,
      failed: false,
      timedOut: false,
      isCanceled: false,
      killed: false
    };
  };
  module2.exports.command = (command, options) => {
    const [file, ...args] = parseCommand(command);
    return execa(file, args, options);
  };
  module2.exports.commandSync = (command, options) => {
    const [file, ...args] = parseCommand(command);
    return execa.sync(file, args, options);
  };
  module2.exports.node = (scriptPath, args, options = {}) => {
    if (args && !Array.isArray(args) && typeof args === "object") {
      options = args;
      args = [];
    }
    const stdio = normalizeStdio.node(options);
    const {nodePath = process.execPath, nodeOptions = process.execArgv} = options;
    return execa(nodePath, [
      ...nodeOptions,
      scriptPath,
      ...Array.isArray(args) ? args : []
    ], {
      ...options,
      stdin: void 0,
      stdout: void 0,
      stderr: void 0,
      stdio,
      shell: false
    });
  };
});

// ../../node_modules/.pnpm/graceful-fs@4.2.4/node_modules/graceful-fs/polyfills.js
var require_polyfills = __commonJS((exports2, module2) => {
  var constants = require("constants");
  var origCwd = process.cwd;
  var cwd = null;
  var platform = process.env.GRACEFUL_FS_PLATFORM || process.platform;
  process.cwd = function() {
    if (!cwd)
      cwd = origCwd.call(process);
    return cwd;
  };
  try {
    process.cwd();
  } catch (er) {
  }
  var chdir = process.chdir;
  process.chdir = function(d) {
    cwd = null;
    chdir.call(process, d);
  };
  module2.exports = patch;
  function patch(fs3) {
    if (constants.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
      patchLchmod(fs3);
    }
    if (!fs3.lutimes) {
      patchLutimes(fs3);
    }
    fs3.chown = chownFix(fs3.chown);
    fs3.fchown = chownFix(fs3.fchown);
    fs3.lchown = chownFix(fs3.lchown);
    fs3.chmod = chmodFix(fs3.chmod);
    fs3.fchmod = chmodFix(fs3.fchmod);
    fs3.lchmod = chmodFix(fs3.lchmod);
    fs3.chownSync = chownFixSync(fs3.chownSync);
    fs3.fchownSync = chownFixSync(fs3.fchownSync);
    fs3.lchownSync = chownFixSync(fs3.lchownSync);
    fs3.chmodSync = chmodFixSync(fs3.chmodSync);
    fs3.fchmodSync = chmodFixSync(fs3.fchmodSync);
    fs3.lchmodSync = chmodFixSync(fs3.lchmodSync);
    fs3.stat = statFix(fs3.stat);
    fs3.fstat = statFix(fs3.fstat);
    fs3.lstat = statFix(fs3.lstat);
    fs3.statSync = statFixSync(fs3.statSync);
    fs3.fstatSync = statFixSync(fs3.fstatSync);
    fs3.lstatSync = statFixSync(fs3.lstatSync);
    if (!fs3.lchmod) {
      fs3.lchmod = function(path9, mode, cb) {
        if (cb)
          process.nextTick(cb);
      };
      fs3.lchmodSync = function() {
      };
    }
    if (!fs3.lchown) {
      fs3.lchown = function(path9, uid, gid, cb) {
        if (cb)
          process.nextTick(cb);
      };
      fs3.lchownSync = function() {
      };
    }
    if (platform === "win32") {
      fs3.rename = function(fs$rename) {
        return function(from, to, cb) {
          var start = Date.now();
          var backoff = 0;
          fs$rename(from, to, function CB(er) {
            if (er && (er.code === "EACCES" || er.code === "EPERM") && Date.now() - start < 6e4) {
              setTimeout(function() {
                fs3.stat(to, function(stater, st) {
                  if (stater && stater.code === "ENOENT")
                    fs$rename(from, to, CB);
                  else
                    cb(er);
                });
              }, backoff);
              if (backoff < 100)
                backoff += 10;
              return;
            }
            if (cb)
              cb(er);
          });
        };
      }(fs3.rename);
    }
    fs3.read = function(fs$read) {
      function read(fd, buffer, offset, length, position, callback_) {
        var callback;
        if (callback_ && typeof callback_ === "function") {
          var eagCounter = 0;
          callback = function(er, _, __) {
            if (er && er.code === "EAGAIN" && eagCounter < 10) {
              eagCounter++;
              return fs$read.call(fs3, fd, buffer, offset, length, position, callback);
            }
            callback_.apply(this, arguments);
          };
        }
        return fs$read.call(fs3, fd, buffer, offset, length, position, callback);
      }
      read.__proto__ = fs$read;
      return read;
    }(fs3.read);
    fs3.readSync = function(fs$readSync) {
      return function(fd, buffer, offset, length, position) {
        var eagCounter = 0;
        while (true) {
          try {
            return fs$readSync.call(fs3, fd, buffer, offset, length, position);
          } catch (er) {
            if (er.code === "EAGAIN" && eagCounter < 10) {
              eagCounter++;
              continue;
            }
            throw er;
          }
        }
      };
    }(fs3.readSync);
    function patchLchmod(fs4) {
      fs4.lchmod = function(path9, mode, callback) {
        fs4.open(path9, constants.O_WRONLY | constants.O_SYMLINK, mode, function(err, fd) {
          if (err) {
            if (callback)
              callback(err);
            return;
          }
          fs4.fchmod(fd, mode, function(err2) {
            fs4.close(fd, function(err22) {
              if (callback)
                callback(err2 || err22);
            });
          });
        });
      };
      fs4.lchmodSync = function(path9, mode) {
        var fd = fs4.openSync(path9, constants.O_WRONLY | constants.O_SYMLINK, mode);
        var threw = true;
        var ret;
        try {
          ret = fs4.fchmodSync(fd, mode);
          threw = false;
        } finally {
          if (threw) {
            try {
              fs4.closeSync(fd);
            } catch (er) {
            }
          } else {
            fs4.closeSync(fd);
          }
        }
        return ret;
      };
    }
    function patchLutimes(fs4) {
      if (constants.hasOwnProperty("O_SYMLINK")) {
        fs4.lutimes = function(path9, at, mt, cb) {
          fs4.open(path9, constants.O_SYMLINK, function(er, fd) {
            if (er) {
              if (cb)
                cb(er);
              return;
            }
            fs4.futimes(fd, at, mt, function(er2) {
              fs4.close(fd, function(er22) {
                if (cb)
                  cb(er2 || er22);
              });
            });
          });
        };
        fs4.lutimesSync = function(path9, at, mt) {
          var fd = fs4.openSync(path9, constants.O_SYMLINK);
          var ret;
          var threw = true;
          try {
            ret = fs4.futimesSync(fd, at, mt);
            threw = false;
          } finally {
            if (threw) {
              try {
                fs4.closeSync(fd);
              } catch (er) {
              }
            } else {
              fs4.closeSync(fd);
            }
          }
          return ret;
        };
      } else {
        fs4.lutimes = function(_a, _b, _c, cb) {
          if (cb)
            process.nextTick(cb);
        };
        fs4.lutimesSync = function() {
        };
      }
    }
    function chmodFix(orig) {
      if (!orig)
        return orig;
      return function(target, mode, cb) {
        return orig.call(fs3, target, mode, function(er) {
          if (chownErOk(er))
            er = null;
          if (cb)
            cb.apply(this, arguments);
        });
      };
    }
    function chmodFixSync(orig) {
      if (!orig)
        return orig;
      return function(target, mode) {
        try {
          return orig.call(fs3, target, mode);
        } catch (er) {
          if (!chownErOk(er))
            throw er;
        }
      };
    }
    function chownFix(orig) {
      if (!orig)
        return orig;
      return function(target, uid, gid, cb) {
        return orig.call(fs3, target, uid, gid, function(er) {
          if (chownErOk(er))
            er = null;
          if (cb)
            cb.apply(this, arguments);
        });
      };
    }
    function chownFixSync(orig) {
      if (!orig)
        return orig;
      return function(target, uid, gid) {
        try {
          return orig.call(fs3, target, uid, gid);
        } catch (er) {
          if (!chownErOk(er))
            throw er;
        }
      };
    }
    function statFix(orig) {
      if (!orig)
        return orig;
      return function(target, options, cb) {
        if (typeof options === "function") {
          cb = options;
          options = null;
        }
        function callback(er, stats) {
          if (stats) {
            if (stats.uid < 0)
              stats.uid += 4294967296;
            if (stats.gid < 0)
              stats.gid += 4294967296;
          }
          if (cb)
            cb.apply(this, arguments);
        }
        return options ? orig.call(fs3, target, options, callback) : orig.call(fs3, target, callback);
      };
    }
    function statFixSync(orig) {
      if (!orig)
        return orig;
      return function(target, options) {
        var stats = options ? orig.call(fs3, target, options) : orig.call(fs3, target);
        if (stats.uid < 0)
          stats.uid += 4294967296;
        if (stats.gid < 0)
          stats.gid += 4294967296;
        return stats;
      };
    }
    function chownErOk(er) {
      if (!er)
        return true;
      if (er.code === "ENOSYS")
        return true;
      var nonroot = !process.getuid || process.getuid() !== 0;
      if (nonroot) {
        if (er.code === "EINVAL" || er.code === "EPERM")
          return true;
      }
      return false;
    }
  }
});

// ../../node_modules/.pnpm/graceful-fs@4.2.4/node_modules/graceful-fs/legacy-streams.js
var require_legacy_streams = __commonJS((exports2, module2) => {
  var Stream = require("stream").Stream;
  module2.exports = legacy;
  function legacy(fs3) {
    return {
      ReadStream,
      WriteStream
    };
    function ReadStream(path9, options) {
      if (!(this instanceof ReadStream))
        return new ReadStream(path9, options);
      Stream.call(this);
      var self = this;
      this.path = path9;
      this.fd = null;
      this.readable = true;
      this.paused = false;
      this.flags = "r";
      this.mode = 438;
      this.bufferSize = 64 * 1024;
      options = options || {};
      var keys = Object.keys(options);
      for (var index = 0, length = keys.length; index < length; index++) {
        var key = keys[index];
        this[key] = options[key];
      }
      if (this.encoding)
        this.setEncoding(this.encoding);
      if (this.start !== void 0) {
        if (typeof this.start !== "number") {
          throw TypeError("start must be a Number");
        }
        if (this.end === void 0) {
          this.end = Infinity;
        } else if (typeof this.end !== "number") {
          throw TypeError("end must be a Number");
        }
        if (this.start > this.end) {
          throw new Error("start must be <= end");
        }
        this.pos = this.start;
      }
      if (this.fd !== null) {
        process.nextTick(function() {
          self._read();
        });
        return;
      }
      fs3.open(this.path, this.flags, this.mode, function(err, fd) {
        if (err) {
          self.emit("error", err);
          self.readable = false;
          return;
        }
        self.fd = fd;
        self.emit("open", fd);
        self._read();
      });
    }
    function WriteStream(path9, options) {
      if (!(this instanceof WriteStream))
        return new WriteStream(path9, options);
      Stream.call(this);
      this.path = path9;
      this.fd = null;
      this.writable = true;
      this.flags = "w";
      this.encoding = "binary";
      this.mode = 438;
      this.bytesWritten = 0;
      options = options || {};
      var keys = Object.keys(options);
      for (var index = 0, length = keys.length; index < length; index++) {
        var key = keys[index];
        this[key] = options[key];
      }
      if (this.start !== void 0) {
        if (typeof this.start !== "number") {
          throw TypeError("start must be a Number");
        }
        if (this.start < 0) {
          throw new Error("start must be >= zero");
        }
        this.pos = this.start;
      }
      this.busy = false;
      this._queue = [];
      if (this.fd === null) {
        this._open = fs3.open;
        this._queue.push([this._open, this.path, this.flags, this.mode, void 0]);
        this.flush();
      }
    }
  }
});

// ../../node_modules/.pnpm/graceful-fs@4.2.4/node_modules/graceful-fs/clone.js
var require_clone = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = clone;
  function clone(obj) {
    if (obj === null || typeof obj !== "object")
      return obj;
    if (obj instanceof Object)
      var copy3 = {__proto__: obj.__proto__};
    else
      var copy3 = Object.create(null);
    Object.getOwnPropertyNames(obj).forEach(function(key) {
      Object.defineProperty(copy3, key, Object.getOwnPropertyDescriptor(obj, key));
    });
    return copy3;
  }
});

// ../../node_modules/.pnpm/graceful-fs@4.2.4/node_modules/graceful-fs/graceful-fs.js
var require_graceful_fs = __commonJS((exports2, module2) => {
  var fs3 = require("fs");
  var polyfills = require_polyfills();
  var legacy = require_legacy_streams();
  var clone = require_clone();
  var util2 = require("util");
  var gracefulQueue;
  var previousSymbol;
  if (typeof Symbol === "function" && typeof Symbol.for === "function") {
    gracefulQueue = Symbol.for("graceful-fs.queue");
    previousSymbol = Symbol.for("graceful-fs.previous");
  } else {
    gracefulQueue = "___graceful-fs.queue";
    previousSymbol = "___graceful-fs.previous";
  }
  function noop() {
  }
  function publishQueue(context, queue2) {
    Object.defineProperty(context, gracefulQueue, {
      get: function() {
        return queue2;
      }
    });
  }
  var debug2 = noop;
  if (util2.debuglog)
    debug2 = util2.debuglog("gfs4");
  else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || ""))
    debug2 = function() {
      var m = util2.format.apply(util2, arguments);
      m = "GFS4: " + m.split(/\n/).join("\nGFS4: ");
      console.error(m);
    };
  if (!fs3[gracefulQueue]) {
    var queue = global[gracefulQueue] || [];
    publishQueue(fs3, queue);
    fs3.close = function(fs$close) {
      function close(fd, cb) {
        return fs$close.call(fs3, fd, function(err) {
          if (!err) {
            retry();
          }
          if (typeof cb === "function")
            cb.apply(this, arguments);
        });
      }
      Object.defineProperty(close, previousSymbol, {
        value: fs$close
      });
      return close;
    }(fs3.close);
    fs3.closeSync = function(fs$closeSync) {
      function closeSync(fd) {
        fs$closeSync.apply(fs3, arguments);
        retry();
      }
      Object.defineProperty(closeSync, previousSymbol, {
        value: fs$closeSync
      });
      return closeSync;
    }(fs3.closeSync);
    if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || "")) {
      process.on("exit", function() {
        debug2(fs3[gracefulQueue]);
        require("assert").equal(fs3[gracefulQueue].length, 0);
      });
    }
  }
  if (!global[gracefulQueue]) {
    publishQueue(global, fs3[gracefulQueue]);
  }
  module2.exports = patch(clone(fs3));
  if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs3.__patched) {
    module2.exports = patch(fs3);
    fs3.__patched = true;
  }
  function patch(fs4) {
    polyfills(fs4);
    fs4.gracefulify = patch;
    fs4.createReadStream = createReadStream;
    fs4.createWriteStream = createWriteStream;
    var fs$readFile = fs4.readFile;
    fs4.readFile = readFile;
    function readFile(path9, options, cb) {
      if (typeof options === "function")
        cb = options, options = null;
      return go$readFile(path9, options, cb);
      function go$readFile(path10, options2, cb2) {
        return fs$readFile(path10, options2, function(err) {
          if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
            enqueue([go$readFile, [path10, options2, cb2]]);
          else {
            if (typeof cb2 === "function")
              cb2.apply(this, arguments);
            retry();
          }
        });
      }
    }
    var fs$writeFile = fs4.writeFile;
    fs4.writeFile = writeFile2;
    function writeFile2(path9, data, options, cb) {
      if (typeof options === "function")
        cb = options, options = null;
      return go$writeFile(path9, data, options, cb);
      function go$writeFile(path10, data2, options2, cb2) {
        return fs$writeFile(path10, data2, options2, function(err) {
          if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
            enqueue([go$writeFile, [path10, data2, options2, cb2]]);
          else {
            if (typeof cb2 === "function")
              cb2.apply(this, arguments);
            retry();
          }
        });
      }
    }
    var fs$appendFile = fs4.appendFile;
    if (fs$appendFile)
      fs4.appendFile = appendFile;
    function appendFile(path9, data, options, cb) {
      if (typeof options === "function")
        cb = options, options = null;
      return go$appendFile(path9, data, options, cb);
      function go$appendFile(path10, data2, options2, cb2) {
        return fs$appendFile(path10, data2, options2, function(err) {
          if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
            enqueue([go$appendFile, [path10, data2, options2, cb2]]);
          else {
            if (typeof cb2 === "function")
              cb2.apply(this, arguments);
            retry();
          }
        });
      }
    }
    var fs$readdir = fs4.readdir;
    fs4.readdir = readdir;
    function readdir(path9, options, cb) {
      var args = [path9];
      if (typeof options !== "function") {
        args.push(options);
      } else {
        cb = options;
      }
      args.push(go$readdir$cb);
      return go$readdir(args);
      function go$readdir$cb(err, files) {
        if (files && files.sort)
          files.sort();
        if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
          enqueue([go$readdir, [args]]);
        else {
          if (typeof cb === "function")
            cb.apply(this, arguments);
          retry();
        }
      }
    }
    function go$readdir(args) {
      return fs$readdir.apply(fs4, args);
    }
    if (process.version.substr(0, 4) === "v0.8") {
      var legStreams = legacy(fs4);
      ReadStream = legStreams.ReadStream;
      WriteStream = legStreams.WriteStream;
    }
    var fs$ReadStream = fs4.ReadStream;
    if (fs$ReadStream) {
      ReadStream.prototype = Object.create(fs$ReadStream.prototype);
      ReadStream.prototype.open = ReadStream$open;
    }
    var fs$WriteStream = fs4.WriteStream;
    if (fs$WriteStream) {
      WriteStream.prototype = Object.create(fs$WriteStream.prototype);
      WriteStream.prototype.open = WriteStream$open;
    }
    Object.defineProperty(fs4, "ReadStream", {
      get: function() {
        return ReadStream;
      },
      set: function(val) {
        ReadStream = val;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(fs4, "WriteStream", {
      get: function() {
        return WriteStream;
      },
      set: function(val) {
        WriteStream = val;
      },
      enumerable: true,
      configurable: true
    });
    var FileReadStream = ReadStream;
    Object.defineProperty(fs4, "FileReadStream", {
      get: function() {
        return FileReadStream;
      },
      set: function(val) {
        FileReadStream = val;
      },
      enumerable: true,
      configurable: true
    });
    var FileWriteStream = WriteStream;
    Object.defineProperty(fs4, "FileWriteStream", {
      get: function() {
        return FileWriteStream;
      },
      set: function(val) {
        FileWriteStream = val;
      },
      enumerable: true,
      configurable: true
    });
    function ReadStream(path9, options) {
      if (this instanceof ReadStream)
        return fs$ReadStream.apply(this, arguments), this;
      else
        return ReadStream.apply(Object.create(ReadStream.prototype), arguments);
    }
    function ReadStream$open() {
      var that = this;
      open(that.path, that.flags, that.mode, function(err, fd) {
        if (err) {
          if (that.autoClose)
            that.destroy();
          that.emit("error", err);
        } else {
          that.fd = fd;
          that.emit("open", fd);
          that.read();
        }
      });
    }
    function WriteStream(path9, options) {
      if (this instanceof WriteStream)
        return fs$WriteStream.apply(this, arguments), this;
      else
        return WriteStream.apply(Object.create(WriteStream.prototype), arguments);
    }
    function WriteStream$open() {
      var that = this;
      open(that.path, that.flags, that.mode, function(err, fd) {
        if (err) {
          that.destroy();
          that.emit("error", err);
        } else {
          that.fd = fd;
          that.emit("open", fd);
        }
      });
    }
    function createReadStream(path9, options) {
      return new fs4.ReadStream(path9, options);
    }
    function createWriteStream(path9, options) {
      return new fs4.WriteStream(path9, options);
    }
    var fs$open = fs4.open;
    fs4.open = open;
    function open(path9, flags, mode, cb) {
      if (typeof mode === "function")
        cb = mode, mode = null;
      return go$open(path9, flags, mode, cb);
      function go$open(path10, flags2, mode2, cb2) {
        return fs$open(path10, flags2, mode2, function(err, fd) {
          if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
            enqueue([go$open, [path10, flags2, mode2, cb2]]);
          else {
            if (typeof cb2 === "function")
              cb2.apply(this, arguments);
            retry();
          }
        });
      }
    }
    return fs4;
  }
  function enqueue(elem) {
    debug2("ENQUEUE", elem[0].name, elem[1]);
    fs3[gracefulQueue].push(elem);
  }
  function retry() {
    var elem = fs3[gracefulQueue].shift();
    if (elem) {
      debug2("RETRY", elem[0].name, elem[1]);
      elem[0].apply(null, elem[1]);
    }
  }
});

// ../../node_modules/.pnpm/uuid@3.4.0/node_modules/uuid/lib/rng.js
var require_rng = __commonJS((exports2, module2) => {
  var crypto = require("crypto");
  module2.exports = function nodeRNG() {
    return crypto.randomBytes(16);
  };
});

// ../../node_modules/.pnpm/uuid@3.4.0/node_modules/uuid/lib/bytesToUuid.js
var require_bytesToUuid = __commonJS((exports2, module2) => {
  var byteToHex = [];
  for (var i = 0; i < 256; ++i) {
    byteToHex[i] = (i + 256).toString(16).substr(1);
  }
  function bytesToUuid(buf, offset) {
    var i2 = offset || 0;
    var bth = byteToHex;
    return [
      bth[buf[i2++]],
      bth[buf[i2++]],
      bth[buf[i2++]],
      bth[buf[i2++]],
      "-",
      bth[buf[i2++]],
      bth[buf[i2++]],
      "-",
      bth[buf[i2++]],
      bth[buf[i2++]],
      "-",
      bth[buf[i2++]],
      bth[buf[i2++]],
      "-",
      bth[buf[i2++]],
      bth[buf[i2++]],
      bth[buf[i2++]],
      bth[buf[i2++]],
      bth[buf[i2++]],
      bth[buf[i2++]]
    ].join("");
  }
  module2.exports = bytesToUuid;
});

// ../../node_modules/.pnpm/uuid@3.4.0/node_modules/uuid/v1.js
var require_v1 = __commonJS((exports2, module2) => {
  var rng = require_rng();
  var bytesToUuid = require_bytesToUuid();
  var _nodeId;
  var _clockseq;
  var _lastMSecs = 0;
  var _lastNSecs = 0;
  function v1(options, buf, offset) {
    var i = buf && offset || 0;
    var b = buf || [];
    options = options || {};
    var node = options.node || _nodeId;
    var clockseq = options.clockseq !== void 0 ? options.clockseq : _clockseq;
    if (node == null || clockseq == null) {
      var seedBytes = rng();
      if (node == null) {
        node = _nodeId = [
          seedBytes[0] | 1,
          seedBytes[1],
          seedBytes[2],
          seedBytes[3],
          seedBytes[4],
          seedBytes[5]
        ];
      }
      if (clockseq == null) {
        clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
      }
    }
    var msecs = options.msecs !== void 0 ? options.msecs : new Date().getTime();
    var nsecs = options.nsecs !== void 0 ? options.nsecs : _lastNSecs + 1;
    var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
    if (dt < 0 && options.clockseq === void 0) {
      clockseq = clockseq + 1 & 16383;
    }
    if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === void 0) {
      nsecs = 0;
    }
    if (nsecs >= 1e4) {
      throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
    }
    _lastMSecs = msecs;
    _lastNSecs = nsecs;
    _clockseq = clockseq;
    msecs += 122192928e5;
    var tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
    b[i++] = tl >>> 24 & 255;
    b[i++] = tl >>> 16 & 255;
    b[i++] = tl >>> 8 & 255;
    b[i++] = tl & 255;
    var tmh = msecs / 4294967296 * 1e4 & 268435455;
    b[i++] = tmh >>> 8 & 255;
    b[i++] = tmh & 255;
    b[i++] = tmh >>> 24 & 15 | 16;
    b[i++] = tmh >>> 16 & 255;
    b[i++] = clockseq >>> 8 | 128;
    b[i++] = clockseq & 255;
    for (var n = 0; n < 6; ++n) {
      b[i + n] = node[n];
    }
    return buf ? buf : bytesToUuid(b);
  }
  module2.exports = v1;
});

// ../../node_modules/.pnpm/uuid@3.4.0/node_modules/uuid/v4.js
var require_v4 = __commonJS((exports2, module2) => {
  var rng = require_rng();
  var bytesToUuid = require_bytesToUuid();
  function v4(options, buf, offset) {
    var i = buf && offset || 0;
    if (typeof options == "string") {
      buf = options === "binary" ? new Array(16) : null;
      options = null;
    }
    options = options || {};
    var rnds = options.random || (options.rng || rng)();
    rnds[6] = rnds[6] & 15 | 64;
    rnds[8] = rnds[8] & 63 | 128;
    if (buf) {
      for (var ii = 0; ii < 16; ++ii) {
        buf[i + ii] = rnds[ii];
      }
    }
    return buf || bytesToUuid(rnds);
  }
  module2.exports = v4;
});

// ../../node_modules/.pnpm/uuid@3.4.0/node_modules/uuid/index.js
var require_uuid = __commonJS((exports2, module2) => {
  var v1 = require_v1();
  var v4 = require_v4();
  var uuid = v4;
  uuid.v1 = v1;
  uuid.v4 = v4;
  module2.exports = uuid;
});

// ../../node_modules/.pnpm/temp-dir@1.0.0/node_modules/temp-dir/index.js
var require_temp_dir = __commonJS((exports2, module2) => {
  "use strict";
  const fs3 = require("fs");
  const os = require("os");
  const ID = "__RESOLVED_TMP_DIR__";
  if (!global[ID]) {
    Object.defineProperty(global, ID, {
      value: fs3.realpathSync(os.tmpdir())
    });
  }
  module2.exports = global[ID];
});

// ../../node_modules/.pnpm/temp-write@4.0.0/node_modules/temp-write/index.js
var require_temp_write = __commonJS((exports2, module2) => {
  "use strict";
  const {promisify: promisify2} = require("util");
  const path9 = require("path");
  const fs3 = require_graceful_fs();
  const isStream = require_is_stream();
  const makeDir2 = require_make_dir();
  const uuid = require_uuid();
  const tempDir = require_temp_dir();
  const writeFileP = promisify2(fs3.writeFile);
  const tempfile = (filePath) => path9.join(tempDir, uuid.v4(), filePath || "");
  const writeStream = async (filePath, fileContent) => new Promise((resolve, reject) => {
    const writable = fs3.createWriteStream(filePath);
    fileContent.on("error", (error) => {
      reject(error);
      fileContent.unpipe(writable);
      writable.end();
    }).pipe(writable).on("error", reject).on("finish", resolve);
  });
  module2.exports = async (fileContent, filePath) => {
    const tempPath = tempfile(filePath);
    const write = isStream(fileContent) ? writeStream : writeFileP;
    await makeDir2(path9.dirname(tempPath));
    await write(tempPath, fileContent);
    return tempPath;
  };
  module2.exports.sync = (fileContent, filePath) => {
    const tempPath = tempfile(filePath);
    makeDir2.sync(path9.dirname(tempPath));
    fs3.writeFileSync(tempPath, fileContent);
    return tempPath;
  };
});

// ../../node_modules/.pnpm/temp-dir@2.0.0/node_modules/temp-dir/index.js
var require_temp_dir2 = __commonJS((exports2, module2) => {
  "use strict";
  const fs3 = require("fs");
  const os = require("os");
  const tempDirectorySymbol = Symbol.for("__RESOLVED_TEMP_DIRECTORY__");
  if (!global[tempDirectorySymbol]) {
    Object.defineProperty(global, tempDirectorySymbol, {
      value: fs3.realpathSync(os.tmpdir())
    });
  }
  module2.exports = global[tempDirectorySymbol];
});

// ../get-platform/dist/getPlatform.js
var require_getPlatform = __commonJS((exports2) => {
  "use strict";
  var __importDefault = exports2 && exports2.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {default: mod};
  };
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.getPlatform = exports2.getOpenSSLVersion = exports2.parseOpenSSLVersion = exports2.resolveDistro = exports2.parseDistro = exports2.getos = void 0;
  const os_1 = __importDefault(require("os"));
  const fs_1 = __importDefault(require("fs"));
  const util_1 = require("util");
  const child_process_1 = require("child_process");
  const readFile = util_1.promisify(fs_1.default.readFile);
  const exists2 = util_1.promisify(fs_1.default.exists);
  async function getos() {
    const platform = os_1.default.platform();
    if (platform === "freebsd") {
      const version = await gracefulExec(`freebsd-version`);
      if (version && version.trim().length > 0) {
        const regex = /^(\d+)\.?/;
        const match = regex.exec(version);
        if (match) {
          return {
            platform: "freebsd",
            distro: `freebsd${match[1]}`
          };
        }
      }
    }
    if (platform !== "linux") {
      return {
        platform
      };
    }
    return {
      platform: "linux",
      libssl: await getOpenSSLVersion(),
      distro: await resolveDistro()
    };
  }
  exports2.getos = getos;
  function parseDistro(input) {
    const idRegex = /^ID="?([^"\n]*)"?$/im;
    const idLikeRegex = /^ID_LIKE="?([^"\n]*)"?$/im;
    const idMatch = idRegex.exec(input);
    const id = idMatch && idMatch[1] && idMatch[1].toLowerCase() || "";
    const idLikeMatch = idLikeRegex.exec(input);
    const idLike = idLikeMatch && idLikeMatch[1] && idLikeMatch[1].toLowerCase() || "";
    if (id === "raspbian") {
      return "arm";
    }
    if (id === "nixos") {
      return "nixos";
    }
    if (idLike.includes("centos") || idLike.includes("fedora") || idLike.includes("rhel") || id === "fedora") {
      return "rhel";
    }
    if (idLike.includes("debian") || idLike.includes("ubuntu") || id === "debian") {
      return "debian";
    }
    return;
  }
  exports2.parseDistro = parseDistro;
  async function resolveDistro() {
    const osReleaseFile = "/etc/os-release";
    const alpineReleaseFile = "/etc/alpine-release";
    if (await exists2(alpineReleaseFile)) {
      return "musl";
    } else if (await exists2(osReleaseFile)) {
      return parseDistro(await readFile(osReleaseFile, "utf-8"));
    } else {
      return;
    }
  }
  exports2.resolveDistro = resolveDistro;
  function parseOpenSSLVersion(input) {
    const match = /^OpenSSL\s(\d+\.\d+)\.\d+/.exec(input);
    if (match) {
      return match[1] + ".x";
    }
    return;
  }
  exports2.parseOpenSSLVersion = parseOpenSSLVersion;
  async function getOpenSSLVersion() {
    const [version, ls] = await Promise.all([
      gracefulExec(`openssl version -v`),
      gracefulExec(`
      ls -l /lib64 | grep ssl;
      ls -l /usr/lib64 | grep ssl;
    `)
    ]);
    if (version) {
      const v = parseOpenSSLVersion(version);
      if (v) {
        return v;
      }
    }
    if (ls) {
      const match = /libssl\.so\.(\d+\.\d+)\.\d+/.exec(ls);
      if (match) {
        return match[1] + ".x";
      }
    }
    return void 0;
  }
  exports2.getOpenSSLVersion = getOpenSSLVersion;
  async function gracefulExec(cmd) {
    return new Promise((resolve) => {
      try {
        child_process_1.exec(cmd, (err, stdout) => {
          resolve(String(stdout));
        });
      } catch (e) {
        resolve(void 0);
        return void 0;
      }
    });
  }
  async function getPlatform() {
    const {platform, libssl, distro} = await getos();
    if (platform === "darwin") {
      return "darwin";
    }
    if (platform === "win32") {
      return "windows";
    }
    if (platform === "freebsd") {
      return distro;
    }
    if (platform === "openbsd") {
      return "openbsd";
    }
    if (platform === "netbsd") {
      return "netbsd";
    }
    if (platform === "linux" && distro === "nixos") {
      return "linux-nixos";
    }
    if (platform === "linux" && distro === "musl") {
      return "linux-musl";
    }
    if (platform === "linux" && distro && libssl) {
      return distro + "-openssl-" + libssl;
    }
    if (libssl) {
      return "debian-openssl-" + libssl;
    }
    if (distro) {
      return distro + "-openssl-1.1.x";
    }
    return "debian-openssl-1.1.x";
  }
  exports2.getPlatform = getPlatform;
});

// ../get-platform/dist/platforms.js
var require_platforms = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.mayBeCompatible = exports2.platforms = void 0;
  exports2.platforms = [
    "darwin",
    "debian-openssl-1.0.x",
    "debian-openssl-1.1.x",
    "rhel-openssl-1.0.x",
    "rhel-openssl-1.1.x",
    "linux-musl",
    "linux-nixos",
    "windows",
    "freebsd11",
    "freebsd12",
    "openbsd",
    "netbsd",
    "arm"
  ];
  function mayBeCompatible(platformA, platformB) {
    if (platformA.startsWith("freebsd") || platformB.startsWith("freebsd")) {
      return false;
    }
    if (platformA === "native" || platformB === "native") {
      return true;
    }
    if (platformA === "darwin" || platformB === "darwin") {
      return false;
    }
    if (platformA === "windows" || platformB === "windows") {
      return false;
    }
    return true;
  }
  exports2.mayBeCompatible = mayBeCompatible;
});

// ../get-platform/dist/index.js
var require_dist3 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.platforms = exports2.mayBeCompatible = exports2.getos = exports2.getPlatform = void 0;
  var getPlatform_1 = require_getPlatform();
  Object.defineProperty(exports2, "getPlatform", {enumerable: true, get: function() {
    return getPlatform_1.getPlatform;
  }});
  Object.defineProperty(exports2, "getos", {enumerable: true, get: function() {
    return getPlatform_1.getos;
  }});
  var platforms_1 = require_platforms();
  Object.defineProperty(exports2, "mayBeCompatible", {enumerable: true, get: function() {
    return platforms_1.mayBeCompatible;
  }});
  var platforms_2 = require_platforms();
  Object.defineProperty(exports2, "platforms", {enumerable: true, get: function() {
    return platforms_2.platforms;
  }});
});

// ../../node_modules/.pnpm/ansi-escapes@4.3.1/node_modules/ansi-escapes/index.js
var require_ansi_escapes = __commonJS((exports2, module2) => {
  "use strict";
  const ansiEscapes = module2.exports;
  module2.exports.default = ansiEscapes;
  const ESC = "[";
  const OSC = "]";
  const BEL = "\x07";
  const SEP = ";";
  const isTerminalApp = process.env.TERM_PROGRAM === "Apple_Terminal";
  ansiEscapes.cursorTo = (x, y) => {
    if (typeof x !== "number") {
      throw new TypeError("The `x` argument is required");
    }
    if (typeof y !== "number") {
      return ESC + (x + 1) + "G";
    }
    return ESC + (y + 1) + ";" + (x + 1) + "H";
  };
  ansiEscapes.cursorMove = (x, y) => {
    if (typeof x !== "number") {
      throw new TypeError("The `x` argument is required");
    }
    let ret = "";
    if (x < 0) {
      ret += ESC + -x + "D";
    } else if (x > 0) {
      ret += ESC + x + "C";
    }
    if (y < 0) {
      ret += ESC + -y + "A";
    } else if (y > 0) {
      ret += ESC + y + "B";
    }
    return ret;
  };
  ansiEscapes.cursorUp = (count = 1) => ESC + count + "A";
  ansiEscapes.cursorDown = (count = 1) => ESC + count + "B";
  ansiEscapes.cursorForward = (count = 1) => ESC + count + "C";
  ansiEscapes.cursorBackward = (count = 1) => ESC + count + "D";
  ansiEscapes.cursorLeft = ESC + "G";
  ansiEscapes.cursorSavePosition = isTerminalApp ? "7" : ESC + "s";
  ansiEscapes.cursorRestorePosition = isTerminalApp ? "8" : ESC + "u";
  ansiEscapes.cursorGetPosition = ESC + "6n";
  ansiEscapes.cursorNextLine = ESC + "E";
  ansiEscapes.cursorPrevLine = ESC + "F";
  ansiEscapes.cursorHide = ESC + "?25l";
  ansiEscapes.cursorShow = ESC + "?25h";
  ansiEscapes.eraseLines = (count) => {
    let clear = "";
    for (let i = 0; i < count; i++) {
      clear += ansiEscapes.eraseLine + (i < count - 1 ? ansiEscapes.cursorUp() : "");
    }
    if (count) {
      clear += ansiEscapes.cursorLeft;
    }
    return clear;
  };
  ansiEscapes.eraseEndLine = ESC + "K";
  ansiEscapes.eraseStartLine = ESC + "1K";
  ansiEscapes.eraseLine = ESC + "2K";
  ansiEscapes.eraseDown = ESC + "J";
  ansiEscapes.eraseUp = ESC + "1J";
  ansiEscapes.eraseScreen = ESC + "2J";
  ansiEscapes.scrollUp = ESC + "S";
  ansiEscapes.scrollDown = ESC + "T";
  ansiEscapes.clearScreen = "c";
  ansiEscapes.clearTerminal = process.platform === "win32" ? `${ansiEscapes.eraseScreen}${ESC}0f` : `${ansiEscapes.eraseScreen}${ESC}3J${ESC}H`;
  ansiEscapes.beep = BEL;
  ansiEscapes.link = (text, url) => {
    return [
      OSC,
      "8",
      SEP,
      SEP,
      url,
      BEL,
      text,
      OSC,
      "8",
      SEP,
      SEP,
      BEL
    ].join("");
  };
  ansiEscapes.image = (buffer, options = {}) => {
    let ret = `${OSC}1337;File=inline=1`;
    if (options.width) {
      ret += `;width=${options.width}`;
    }
    if (options.height) {
      ret += `;height=${options.height}`;
    }
    if (options.preserveAspectRatio === false) {
      ret += ";preserveAspectRatio=0";
    }
    return ret + ":" + buffer.toString("base64") + BEL;
  };
  ansiEscapes.iTerm = {
    setCwd: (cwd = process.cwd()) => `${OSC}50;CurrentDir=${cwd}${BEL}`,
    annotation: (message, options = {}) => {
      let ret = `${OSC}1337;`;
      const hasX = typeof options.x !== "undefined";
      const hasY = typeof options.y !== "undefined";
      if ((hasX || hasY) && !(hasX && hasY && typeof options.length !== "undefined")) {
        throw new Error("`x`, `y` and `length` must be defined when `x` or `y` is defined");
      }
      message = message.replace(/\|/g, "");
      ret += options.isHidden ? "AddHiddenAnnotation=" : "AddAnnotation=";
      if (options.length > 0) {
        ret += (hasX ? [message, options.length, options.x, options.y] : [options.length, message]).join("|");
      } else {
        ret += message;
      }
      return ret + BEL;
    }
  };
});

// ../../node_modules/.pnpm/supports-hyperlinks@2.1.0/node_modules/supports-hyperlinks/index.js
var require_supports_hyperlinks = __commonJS((exports2, module2) => {
  "use strict";
  const supportsColor = require_supports_color();
  const hasFlag = require_has_flag();
  function parseVersion(versionString) {
    if (/^\d{3,4}$/.test(versionString)) {
      const m = /(\d{1,2})(\d{2})/.exec(versionString);
      return {
        major: 0,
        minor: parseInt(m[1], 10),
        patch: parseInt(m[2], 10)
      };
    }
    const versions = (versionString || "").split(".").map((n) => parseInt(n, 10));
    return {
      major: versions[0],
      minor: versions[1],
      patch: versions[2]
    };
  }
  function supportsHyperlink(stream) {
    const {env} = process;
    if ("FORCE_HYPERLINK" in env) {
      return !(env.FORCE_HYPERLINK.length > 0 && parseInt(env.FORCE_HYPERLINK, 10) === 0);
    }
    if (hasFlag("no-hyperlink") || hasFlag("no-hyperlinks") || hasFlag("hyperlink=false") || hasFlag("hyperlink=never")) {
      return false;
    }
    if (hasFlag("hyperlink=true") || hasFlag("hyperlink=always")) {
      return true;
    }
    if (!supportsColor.supportsColor(stream)) {
      return false;
    }
    if (stream && !stream.isTTY) {
      return false;
    }
    if (process.platform === "win32") {
      return false;
    }
    if ("CI" in env) {
      return false;
    }
    if ("TEAMCITY_VERSION" in env) {
      return false;
    }
    if ("TERM_PROGRAM" in env) {
      const version = parseVersion(env.TERM_PROGRAM_VERSION);
      switch (env.TERM_PROGRAM) {
        case "iTerm.app":
          if (version.major === 3) {
            return version.minor >= 1;
          }
          return version.major > 3;
      }
    }
    if ("VTE_VERSION" in env) {
      if (env.VTE_VERSION === "0.50.0") {
        return false;
      }
      const version = parseVersion(env.VTE_VERSION);
      return version.major > 0 || version.minor >= 50;
    }
    return false;
  }
  module2.exports = {
    supportsHyperlink,
    stdout: supportsHyperlink(process.stdout),
    stderr: supportsHyperlink(process.stderr)
  };
});

// ../../node_modules/.pnpm/terminal-link@2.1.1/node_modules/terminal-link/index.js
var require_terminal_link = __commonJS((exports2, module2) => {
  "use strict";
  const ansiEscapes = require_ansi_escapes();
  const supportsHyperlinks = require_supports_hyperlinks();
  const terminalLink = (text, url, {target = "stdout", ...options} = {}) => {
    if (!supportsHyperlinks[target]) {
      if (options.fallback === false) {
        return text;
      }
      return typeof options.fallback === "function" ? options.fallback(text, url) : `${text} (​${url}​)`;
    }
    return ansiEscapes.link(text, url);
  };
  module2.exports = (text, url, options = {}) => terminalLink(text, url, options);
  module2.exports.stderr = (text, url, options = {}) => terminalLink(text, url, {target: "stderr", ...options});
  module2.exports.isSupported = supportsHyperlinks.stdout;
  module2.exports.stderr.isSupported = supportsHyperlinks.stderr;
});

// ../../node_modules/.pnpm/new-github-issue-url@0.2.1/node_modules/new-github-issue-url/index.js
var require_new_github_issue_url = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = (options = {}) => {
    let repoUrl;
    if (options.repoUrl) {
      repoUrl = options.repoUrl;
    } else if (options.user && options.repo) {
      repoUrl = `https://github.com/${options.user}/${options.repo}`;
    } else {
      throw new Error("You need to specify either the `repoUrl` option or both the `user` and `repo` options");
    }
    const url = new URL(`${repoUrl}/issues/new`);
    const types = [
      "body",
      "title",
      "labels",
      "template",
      "milestone",
      "assignee",
      "projects"
    ];
    for (const type of types) {
      let value = options[type];
      if (value === void 0) {
        continue;
      }
      if (type === "labels" || type === "projects") {
        if (!Array.isArray(value)) {
          throw new TypeError(`The \`${type}\` option should be an array`);
        }
        value = value.join(",");
      }
      url.searchParams.set(type, value);
    }
    return url.toString();
  };
  module2.exports.default = module2.exports;
});

// ../engine-core/dist/util.js
var require_util2 = __commonJS((exports2) => {
  "use strict";
  var __importDefault = exports2 && exports2.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {default: mod};
  };
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.getRandomString = exports2.getGithubIssueUrl = exports2.link = exports2.fixBinaryTargets = exports2.plusX = void 0;
  const fs_1 = __importDefault(require("fs"));
  const terminal_link_1 = __importDefault(require_terminal_link());
  const new_github_issue_url_1 = __importDefault(require_new_github_issue_url());
  const chalk_1 = __importDefault(require_source());
  const debug_1 = __importDefault(require_dist2());
  const crypto_1 = __importDefault(require("crypto"));
  const debug2 = debug_1.default("plusX");
  function plusX(file) {
    const s = fs_1.default.statSync(file);
    const newMode = s.mode | 64 | 8 | 1;
    if (s.mode === newMode) {
      debug2(`Execution permissions of ${file} are fine`);
      return;
    }
    const base8 = newMode.toString(8).slice(-3);
    debug2(`Have to call plusX on ${file}`);
    fs_1.default.chmodSync(file, base8);
  }
  exports2.plusX = plusX;
  function fixBinaryTargets(platforms, platform) {
    platforms = platforms || [];
    if (!platforms.includes("native")) {
      return ["native", ...platforms];
    }
    return [...platforms, platform];
  }
  exports2.fixBinaryTargets = fixBinaryTargets;
  function link(url) {
    return terminal_link_1.default(url, url, {
      fallback: (url2) => chalk_1.default.underline(url2)
    });
  }
  exports2.link = link;
  function getGithubIssueUrl({title, user = "prisma", repo = "prisma-client-js", template = "bug_report.md", body}) {
    return new_github_issue_url_1.default({
      user,
      repo,
      template,
      title,
      body
    });
  }
  exports2.getGithubIssueUrl = getGithubIssueUrl;
  function getRandomString() {
    return crypto_1.default.randomBytes(12).toString("hex");
  }
  exports2.getRandomString = getRandomString;
});

// ../sdk/dist/resolveBinary.js
var require_resolveBinary = __commonJS((exports2) => {
  "use strict";
  var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __importDefault = exports2 && exports2.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {default: mod};
  };
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.maybeCopyToTmp = exports2.resolveBinary = void 0;
  const fs_1 = __importDefault(require("fs"));
  const path_1 = __importDefault(require("path"));
  const temp_dir_1 = __importDefault(require_temp_dir2());
  const make_dir_1 = __importDefault(require_make_dir());
  const util_1 = require("util");
  const get_platform_1 = require_dist3();
  const util_2 = require_util2();
  const readFile = util_1.promisify(fs_1.default.readFile);
  const writeFile2 = util_1.promisify(fs_1.default.writeFile);
  const engineEnvVarMap = {
    "query-engine": "PRISMA_QUERY_ENGINE_BINARY",
    "migration-engine": "PRISMA_MIGRATION_ENGINE_BINARY",
    "introspection-engine": "PRISMA_INTROSPECTION_ENGINE_BINARY",
    "prisma-fmt": "PRISMA_FMT_BINARY"
  };
  function resolveBinary(name, proposedPath) {
    return __awaiter(this, void 0, void 0, function* () {
      if (proposedPath && !proposedPath.startsWith("/snapshot/") && fs_1.default.existsSync(proposedPath)) {
        return proposedPath;
      }
      const envVar = engineEnvVarMap[name];
      if (process.env[envVar]) {
        if (!fs_1.default.existsSync(process.env[envVar])) {
          throw new Error(`Env var ${envVar} is provided, but provided path ${process.env[envVar]} can't be resolved.`);
        }
        return process.env[envVar];
      }
      const dir = eval("__dirname");
      const platform = yield get_platform_1.getPlatform();
      const extension = platform === "windows" ? ".exe" : "";
      const binaryName = `${name}-${platform}${extension}`;
      let prismaPath = path_1.default.join(dir, "..", binaryName);
      if (fs_1.default.existsSync(prismaPath)) {
        return maybeCopyToTmp(prismaPath);
      }
      prismaPath = path_1.default.join(dir, "../..", binaryName);
      if (fs_1.default.existsSync(prismaPath)) {
        return maybeCopyToTmp(prismaPath);
      }
      prismaPath = path_1.default.join(__dirname, "..", binaryName);
      if (fs_1.default.existsSync(prismaPath)) {
        return maybeCopyToTmp(prismaPath);
      }
      prismaPath = path_1.default.join(__dirname, "../..", binaryName);
      if (fs_1.default.existsSync(prismaPath)) {
        return maybeCopyToTmp(prismaPath);
      }
      prismaPath = path_1.default.join(__dirname, "../runtime", binaryName);
      if (fs_1.default.existsSync(prismaPath)) {
        return maybeCopyToTmp(prismaPath);
      }
      throw new Error(`Could not find ${name} binary. Searched in ${path_1.default.join(dir, "..", binaryName)} and ${path_1.default.join(dir, "../..", binaryName)}`);
    });
  }
  exports2.resolveBinary = resolveBinary;
  function maybeCopyToTmp(file) {
    return __awaiter(this, void 0, void 0, function* () {
      const dir = eval("__dirname");
      if (dir.startsWith("/snapshot/")) {
        const targetDir = path_1.default.join(temp_dir_1.default, "prisma-binaries");
        yield make_dir_1.default(targetDir);
        const target = path_1.default.join(targetDir, path_1.default.basename(file));
        const data = yield readFile(file);
        yield writeFile2(target, data);
        util_2.plusX(target);
        return target;
      }
      return file;
    });
  }
  exports2.maybeCopyToTmp = maybeCopyToTmp;
});

// ../sdk/dist/engineCommands.js
var require_engineCommands = __commonJS((exports2) => {
  "use strict";
  var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __importDefault = exports2 && exports2.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {default: mod};
  };
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.getVersion = exports2.formatSchema = exports2.getConfig = exports2.getDMMF = void 0;
  const chalk_1 = __importDefault(require_source());
  const execa_1 = __importDefault(require_execa());
  const path_1 = __importDefault(require("path"));
  const temp_write_1 = __importDefault(require_temp_write());
  const fs_1 = __importDefault(require("fs"));
  const util_1 = require("util");
  const debug_1 = __importDefault(require_dist2());
  const resolveBinary_1 = require_resolveBinary();
  const debug2 = debug_1.default("engineCommands");
  const unlink = util_1.promisify(fs_1.default.unlink);
  const MAX_BUFFER = 1e3 * 1e3 * 1e3;
  path_1.default.join(__dirname, "../query-engine-darwin");
  path_1.default.join(__dirname, "../introspection-engine-darwin");
  path_1.default.join(__dirname, "../prisma-fmt-darwin");
  path_1.default.join(__dirname, "../query-engine-debian-openssl-1.0.x");
  path_1.default.join(__dirname, "../introspection-engine-debian-openssl-1.0.x");
  path_1.default.join(__dirname, "../prisma-fmt-debian-openssl-1.0.x");
  path_1.default.join(__dirname, "../query-engine-debian-openssl-1.1.x");
  path_1.default.join(__dirname, "../introspection-engine-debian-openssl-1.1.x");
  path_1.default.join(__dirname, "../prisma-fmt-debian-openssl-1.1.x");
  path_1.default.join(__dirname, "../query-engine-rhel-openssl-1.0.x");
  path_1.default.join(__dirname, "../introspection-engine-rhel-openssl-1.0.x");
  path_1.default.join(__dirname, "../prisma-fmt-rhel-openssl-1.0.x");
  path_1.default.join(__dirname, "../query-engine-rhel-openssl-1.1.x");
  path_1.default.join(__dirname, "../introspection-engine-rhel-openssl-1.1.x");
  path_1.default.join(__dirname, "../prisma-fmt-rhel-openssl-1.1.x");
  function getDMMF4({datamodel, cwd = process.cwd(), prismaPath: queryEnginePath, datamodelPath, retry = 4, enableExperimental}) {
    return __awaiter(this, void 0, void 0, function* () {
      queryEnginePath = yield resolveBinary_1.resolveBinary("query-engine", queryEnginePath);
      let result;
      try {
        let tempDatamodelPath = datamodelPath;
        if (!tempDatamodelPath) {
          try {
            tempDatamodelPath = yield temp_write_1.default(datamodel);
          } catch (err) {
            throw new Error(chalk_1.default.redBright.bold("Get DMMF ") + "unable to write temp data model path");
          }
        }
        const options = {
          cwd,
          env: Object.assign(Object.assign(Object.assign({}, process.env), {PRISMA_DML_PATH: tempDatamodelPath, RUST_BACKTRACE: "1"}), process.env.NO_COLOR ? {} : {CLICOLOR_FORCE: "1"}),
          maxBuffer: MAX_BUFFER
        };
        if (enableExperimental) {
          enableExperimental = enableExperimental.filter((e) => !["middlewares", "aggregateApi", "distinct", "aggregations"].includes(e));
        }
        const experimentalFlags = enableExperimental && Array.isArray(enableExperimental) && enableExperimental.length > 0 ? [`--enable-experimental=${enableExperimental.join(",")}`] : [];
        const args = [...experimentalFlags, "--enable-raw-queries", "cli", "dmmf"];
        result = yield execa_1.default(queryEnginePath, args, options);
        if (!datamodelPath) {
          yield unlink(tempDatamodelPath);
        }
        if (result.stdout.includes("Please wait until the") && retry > 0) {
          debug2('Retrying after "Please wait until"');
          yield new Promise((r) => setTimeout(r, 5e3));
          return getDMMF4({
            datamodel,
            cwd,
            prismaPath: queryEnginePath,
            datamodelPath,
            retry: retry - 1
          });
        }
        const firstCurly = result.stdout.indexOf("{");
        const stdout = result.stdout.slice(firstCurly);
        return JSON.parse(stdout);
      } catch (e) {
        debug2("getDMMF failed", e);
        if (e.message.includes("Command failed with exit code 26 (ETXTBSY)") && retry > 0) {
          yield new Promise((resolve) => setTimeout(resolve, 500));
          debug2("Retrying after ETXTBSY");
          return getDMMF4({
            datamodel,
            cwd,
            prismaPath: queryEnginePath,
            datamodelPath,
            retry: retry - 1
          });
        }
        const output = e.stderr || e.stdout;
        if (output) {
          let json;
          try {
            json = JSON.parse(output);
          } catch (e2) {
          }
          let message = json && json.message || output;
          if (message.includes("debian-openssl-1.1.x: error while loading shared libraries: libssl.so.1.1: cannot open shared object file: No such file or directory") || message.includes("debian-openssl-1.0.x: error while loading shared libraries: libssl.so.1.0.0: cannot open shared object file: No such file or directory")) {
            message += `
${chalk_1.default.green(`Your linux installation misses the openssl package. You can install it like so:
`)}${chalk_1.default.green.bold("apt-get -qy update && apt-get -qy install openssl")}`;
          }
          throw new Error(chalk_1.default.redBright.bold("Schema parsing\n") + message);
        }
        if (e.message.includes("in JSON at position")) {
          throw new Error(`Problem while parsing the query engine response at ${queryEnginePath}. ${result.stdout}
${e.stack}`);
        }
        throw new Error(e);
      }
    });
  }
  exports2.getDMMF = getDMMF4;
  function getConfig({datamodel, cwd = process.cwd(), prismaPath: queryEnginePath, datamodelPath, ignoreEnvVarErrors}) {
    return __awaiter(this, void 0, void 0, function* () {
      queryEnginePath = yield resolveBinary_1.resolveBinary("query-engine", queryEnginePath);
      let tempDatamodelPath = datamodelPath;
      if (!tempDatamodelPath) {
        try {
          tempDatamodelPath = yield temp_write_1.default(datamodel);
        } catch (err) {
          throw new Error(chalk_1.default.redBright.bold("Get DMMF ") + "unable to write temp data model path");
        }
      }
      const args = ignoreEnvVarErrors ? ["--ignoreEnvVarErrors"] : [];
      try {
        const result = yield execa_1.default(queryEnginePath, ["cli", "get-config", ...args], {
          cwd,
          env: Object.assign(Object.assign({}, process.env), {PRISMA_DML_PATH: tempDatamodelPath, RUST_BACKTRACE: "1"}),
          maxBuffer: MAX_BUFFER
        });
        if (!datamodelPath) {
          yield unlink(tempDatamodelPath);
        }
        return JSON.parse(result.stdout);
      } catch (e) {
        if (e.stderr || e.stdout) {
          const error = e.stderr ? e.stderr : e.stout;
          let jsonError, message;
          try {
            jsonError = JSON.parse(error);
            message = `${chalk_1.default.redBright.bold("Get config ")}
${chalk_1.default.redBright(jsonError.message)}
`;
            if (jsonError.error_code) {
              if (jsonError.error_code === "P1012") {
                message = chalk_1.default.redBright(`Schema Parsing ${jsonError.error_code}

`) + message;
              } else {
                message = chalk_1.default.redBright(`${jsonError.error_code}

`) + message;
              }
            }
          } catch (e2) {
            throw new Error(chalk_1.default.redBright.bold("Get config ") + error);
          }
          throw new Error(message);
        }
        throw new Error(chalk_1.default.redBright.bold("Get config ") + e);
      }
    });
  }
  exports2.getConfig = getConfig;
  function formatSchema({schemaPath, schema}) {
    return __awaiter(this, void 0, void 0, function* () {
      if (!schema && !schemaPath) {
        throw new Error(`Paramater schema or schemaPath must be passed.`);
      }
      const prismaFmtPath = yield resolveBinary_1.resolveBinary("prisma-fmt");
      const showColors = !process.env.NO_COLOR && process.stdout.isTTY;
      const options = {
        env: Object.assign(Object.assign(Object.assign({}, process.env), {RUST_BACKTRACE: "1"}), showColors ? {CLICOLOR_FORCE: "1"} : {}),
        maxBuffer: MAX_BUFFER
      };
      let result;
      if (schemaPath) {
        if (!fs_1.default.existsSync(schemaPath)) {
          throw new Error(`Schema at ${schemaPath} does not exist.`);
        }
        result = yield execa_1.default(prismaFmtPath, ["format", "-i", schemaPath], options);
      } else if (schema) {
        result = yield execa_1.default(prismaFmtPath, ["format"], Object.assign(Object.assign({}, options), {input: schema}));
      }
      return result.stdout;
    });
  }
  exports2.formatSchema = formatSchema;
  function getVersion2(enginePath) {
    return __awaiter(this, void 0, void 0, function* () {
      enginePath = yield resolveBinary_1.resolveBinary("query-engine", enginePath);
      const result = yield execa_1.default(enginePath, ["--version"], {
        env: Object.assign({}, process.env),
        maxBuffer: MAX_BUFFER
      });
      return result.stdout;
    });
  }
  exports2.getVersion = getVersion2;
});

// ../../node_modules/.pnpm/pluralize@8.0.0/node_modules/pluralize/pluralize.js
var require_pluralize = __commonJS((exports2, module2) => {
  (function(root, pluralize5) {
    if (typeof exports2 === "object" && typeof module2 === "object") {
      module2.exports = pluralize5();
    } else if (typeof define === "function" && define.amd) {
      define(function() {
        return pluralize5();
      });
    } else {
      root.pluralize = pluralize5();
    }
  })(exports2, function() {
    var pluralRules = [];
    var singularRules = [];
    var uncountables = {};
    var irregularPlurals = {};
    var irregularSingles = {};
    function sanitizeRule(rule) {
      if (typeof rule === "string") {
        return new RegExp("^" + rule + "$", "i");
      }
      return rule;
    }
    function restoreCase(word, token) {
      if (word === token)
        return token;
      if (word === word.toLowerCase())
        return token.toLowerCase();
      if (word === word.toUpperCase())
        return token.toUpperCase();
      if (word[0] === word[0].toUpperCase()) {
        return token.charAt(0).toUpperCase() + token.substr(1).toLowerCase();
      }
      return token.toLowerCase();
    }
    function interpolate(str, args) {
      return str.replace(/\$(\d{1,2})/g, function(match, index) {
        return args[index] || "";
      });
    }
    function replace(word, rule) {
      return word.replace(rule[0], function(match, index) {
        var result = interpolate(rule[1], arguments);
        if (match === "") {
          return restoreCase(word[index - 1], result);
        }
        return restoreCase(match, result);
      });
    }
    function sanitizeWord(token, word, rules) {
      if (!token.length || uncountables.hasOwnProperty(token)) {
        return word;
      }
      var len = rules.length;
      while (len--) {
        var rule = rules[len];
        if (rule[0].test(word))
          return replace(word, rule);
      }
      return word;
    }
    function replaceWord(replaceMap, keepMap, rules) {
      return function(word) {
        var token = word.toLowerCase();
        if (keepMap.hasOwnProperty(token)) {
          return restoreCase(word, token);
        }
        if (replaceMap.hasOwnProperty(token)) {
          return restoreCase(word, replaceMap[token]);
        }
        return sanitizeWord(token, word, rules);
      };
    }
    function checkWord(replaceMap, keepMap, rules, bool) {
      return function(word) {
        var token = word.toLowerCase();
        if (keepMap.hasOwnProperty(token))
          return true;
        if (replaceMap.hasOwnProperty(token))
          return false;
        return sanitizeWord(token, token, rules) === token;
      };
    }
    function pluralize5(word, count, inclusive) {
      var pluralized = count === 1 ? pluralize5.singular(word) : pluralize5.plural(word);
      return (inclusive ? count + " " : "") + pluralized;
    }
    pluralize5.plural = replaceWord(irregularSingles, irregularPlurals, pluralRules);
    pluralize5.isPlural = checkWord(irregularSingles, irregularPlurals, pluralRules);
    pluralize5.singular = replaceWord(irregularPlurals, irregularSingles, singularRules);
    pluralize5.isSingular = checkWord(irregularPlurals, irregularSingles, singularRules);
    pluralize5.addPluralRule = function(rule, replacement) {
      pluralRules.push([sanitizeRule(rule), replacement]);
    };
    pluralize5.addSingularRule = function(rule, replacement) {
      singularRules.push([sanitizeRule(rule), replacement]);
    };
    pluralize5.addUncountableRule = function(word) {
      if (typeof word === "string") {
        uncountables[word.toLowerCase()] = true;
        return;
      }
      pluralize5.addPluralRule(word, "$0");
      pluralize5.addSingularRule(word, "$0");
    };
    pluralize5.addIrregularRule = function(single, plural) {
      plural = plural.toLowerCase();
      single = single.toLowerCase();
      irregularSingles[single] = plural;
      irregularPlurals[plural] = single;
    };
    [
      ["I", "we"],
      ["me", "us"],
      ["he", "they"],
      ["she", "they"],
      ["them", "them"],
      ["myself", "ourselves"],
      ["yourself", "yourselves"],
      ["itself", "themselves"],
      ["herself", "themselves"],
      ["himself", "themselves"],
      ["themself", "themselves"],
      ["is", "are"],
      ["was", "were"],
      ["has", "have"],
      ["this", "these"],
      ["that", "those"],
      ["echo", "echoes"],
      ["dingo", "dingoes"],
      ["volcano", "volcanoes"],
      ["tornado", "tornadoes"],
      ["torpedo", "torpedoes"],
      ["genus", "genera"],
      ["viscus", "viscera"],
      ["stigma", "stigmata"],
      ["stoma", "stomata"],
      ["dogma", "dogmata"],
      ["lemma", "lemmata"],
      ["schema", "schemata"],
      ["anathema", "anathemata"],
      ["ox", "oxen"],
      ["axe", "axes"],
      ["die", "dice"],
      ["yes", "yeses"],
      ["foot", "feet"],
      ["eave", "eaves"],
      ["goose", "geese"],
      ["tooth", "teeth"],
      ["quiz", "quizzes"],
      ["human", "humans"],
      ["proof", "proofs"],
      ["carve", "carves"],
      ["valve", "valves"],
      ["looey", "looies"],
      ["thief", "thieves"],
      ["groove", "grooves"],
      ["pickaxe", "pickaxes"],
      ["passerby", "passersby"]
    ].forEach(function(rule) {
      return pluralize5.addIrregularRule(rule[0], rule[1]);
    });
    [
      [/s?$/i, "s"],
      [/[^\u0000-\u007F]$/i, "$0"],
      [/([^aeiou]ese)$/i, "$1"],
      [/(ax|test)is$/i, "$1es"],
      [/(alias|[^aou]us|t[lm]as|gas|ris)$/i, "$1es"],
      [/(e[mn]u)s?$/i, "$1s"],
      [/([^l]ias|[aeiou]las|[ejzr]as|[iu]am)$/i, "$1"],
      [/(alumn|syllab|vir|radi|nucle|fung|cact|stimul|termin|bacill|foc|uter|loc|strat)(?:us|i)$/i, "$1i"],
      [/(alumn|alg|vertebr)(?:a|ae)$/i, "$1ae"],
      [/(seraph|cherub)(?:im)?$/i, "$1im"],
      [/(her|at|gr)o$/i, "$1oes"],
      [/(agend|addend|millenni|dat|extrem|bacteri|desiderat|strat|candelabr|errat|ov|symposi|curricul|automat|quor)(?:a|um)$/i, "$1a"],
      [/(apheli|hyperbat|periheli|asyndet|noumen|phenomen|criteri|organ|prolegomen|hedr|automat)(?:a|on)$/i, "$1a"],
      [/sis$/i, "ses"],
      [/(?:(kni|wi|li)fe|(ar|l|ea|eo|oa|hoo)f)$/i, "$1$2ves"],
      [/([^aeiouy]|qu)y$/i, "$1ies"],
      [/([^ch][ieo][ln])ey$/i, "$1ies"],
      [/(x|ch|ss|sh|zz)$/i, "$1es"],
      [/(matr|cod|mur|sil|vert|ind|append)(?:ix|ex)$/i, "$1ices"],
      [/\b((?:tit)?m|l)(?:ice|ouse)$/i, "$1ice"],
      [/(pe)(?:rson|ople)$/i, "$1ople"],
      [/(child)(?:ren)?$/i, "$1ren"],
      [/eaux$/i, "$0"],
      [/m[ae]n$/i, "men"],
      ["thou", "you"]
    ].forEach(function(rule) {
      return pluralize5.addPluralRule(rule[0], rule[1]);
    });
    [
      [/s$/i, ""],
      [/(ss)$/i, "$1"],
      [/(wi|kni|(?:after|half|high|low|mid|non|night|[^\w]|^)li)ves$/i, "$1fe"],
      [/(ar|(?:wo|[ae])l|[eo][ao])ves$/i, "$1f"],
      [/ies$/i, "y"],
      [/\b([pl]|zomb|(?:neck|cross)?t|coll|faer|food|gen|goon|group|lass|talk|goal|cut)ies$/i, "$1ie"],
      [/\b(mon|smil)ies$/i, "$1ey"],
      [/\b((?:tit)?m|l)ice$/i, "$1ouse"],
      [/(seraph|cherub)im$/i, "$1"],
      [/(x|ch|ss|sh|zz|tto|go|cho|alias|[^aou]us|t[lm]as|gas|(?:her|at|gr)o|[aeiou]ris)(?:es)?$/i, "$1"],
      [/(analy|diagno|parenthe|progno|synop|the|empha|cri|ne)(?:sis|ses)$/i, "$1sis"],
      [/(movie|twelve|abuse|e[mn]u)s$/i, "$1"],
      [/(test)(?:is|es)$/i, "$1is"],
      [/(alumn|syllab|vir|radi|nucle|fung|cact|stimul|termin|bacill|foc|uter|loc|strat)(?:us|i)$/i, "$1us"],
      [/(agend|addend|millenni|dat|extrem|bacteri|desiderat|strat|candelabr|errat|ov|symposi|curricul|quor)a$/i, "$1um"],
      [/(apheli|hyperbat|periheli|asyndet|noumen|phenomen|criteri|organ|prolegomen|hedr|automat)a$/i, "$1on"],
      [/(alumn|alg|vertebr)ae$/i, "$1a"],
      [/(cod|mur|sil|vert|ind)ices$/i, "$1ex"],
      [/(matr|append)ices$/i, "$1ix"],
      [/(pe)(rson|ople)$/i, "$1rson"],
      [/(child)ren$/i, "$1"],
      [/(eau)x?$/i, "$1"],
      [/men$/i, "man"]
    ].forEach(function(rule) {
      return pluralize5.addSingularRule(rule[0], rule[1]);
    });
    [
      "adulthood",
      "advice",
      "agenda",
      "aid",
      "aircraft",
      "alcohol",
      "ammo",
      "analytics",
      "anime",
      "athletics",
      "audio",
      "bison",
      "blood",
      "bream",
      "buffalo",
      "butter",
      "carp",
      "cash",
      "chassis",
      "chess",
      "clothing",
      "cod",
      "commerce",
      "cooperation",
      "corps",
      "debris",
      "diabetes",
      "digestion",
      "elk",
      "energy",
      "equipment",
      "excretion",
      "expertise",
      "firmware",
      "flounder",
      "fun",
      "gallows",
      "garbage",
      "graffiti",
      "hardware",
      "headquarters",
      "health",
      "herpes",
      "highjinks",
      "homework",
      "housework",
      "information",
      "jeans",
      "justice",
      "kudos",
      "labour",
      "literature",
      "machinery",
      "mackerel",
      "mail",
      "media",
      "mews",
      "moose",
      "music",
      "mud",
      "manga",
      "news",
      "only",
      "personnel",
      "pike",
      "plankton",
      "pliers",
      "police",
      "pollution",
      "premises",
      "rain",
      "research",
      "rice",
      "salmon",
      "scissors",
      "series",
      "sewage",
      "shambles",
      "shrimp",
      "software",
      "species",
      "staff",
      "swine",
      "tennis",
      "traffic",
      "transportation",
      "trout",
      "tuna",
      "wealth",
      "welfare",
      "whiting",
      "wildebeest",
      "wildlife",
      "you",
      /pok[eé]mon$/i,
      /[^aeiou]ese$/i,
      /deer$/i,
      /fish$/i,
      /measles$/i,
      /o[iu]s$/i,
      /pox$/i,
      /sheep$/i
    ].forEach(pluralize5.addUncountableRule);
    return pluralize5;
  });
});

// ../../node_modules/.pnpm/indent-string@4.0.0/node_modules/indent-string/index.js
var require_indent_string = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = (string, count = 1, options) => {
    options = {
      indent: " ",
      includeEmptyLines: false,
      ...options
    };
    if (typeof string !== "string") {
      throw new TypeError(`Expected \`input\` to be a \`string\`, got \`${typeof string}\``);
    }
    if (typeof count !== "number") {
      throw new TypeError(`Expected \`count\` to be a \`number\`, got \`${typeof count}\``);
    }
    if (typeof options.indent !== "string") {
      throw new TypeError(`Expected \`options.indent\` to be a \`string\`, got \`${typeof options.indent}\``);
    }
    if (count === 0) {
      return string;
    }
    const regex = options.includeEmptyLines ? /^/gm : /^(?!\s*$)/gm;
    return string.replace(regex, options.indent.repeat(count));
  };
});

// ../../node_modules/.pnpm/js-levenshtein@1.1.6/node_modules/js-levenshtein/index.js
var require_js_levenshtein = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function() {
    function _min(d0, d1, d2, bx, ay) {
      return d0 < d1 || d2 < d1 ? d0 > d2 ? d2 + 1 : d0 + 1 : bx === ay ? d1 : d1 + 1;
    }
    return function(a, b) {
      if (a === b) {
        return 0;
      }
      if (a.length > b.length) {
        var tmp = a;
        a = b;
        b = tmp;
      }
      var la = a.length;
      var lb = b.length;
      while (la > 0 && a.charCodeAt(la - 1) === b.charCodeAt(lb - 1)) {
        la--;
        lb--;
      }
      var offset = 0;
      while (offset < la && a.charCodeAt(offset) === b.charCodeAt(offset)) {
        offset++;
      }
      la -= offset;
      lb -= offset;
      if (la === 0 || lb < 3) {
        return lb;
      }
      var x = 0;
      var y;
      var d0;
      var d1;
      var d2;
      var d3;
      var dd;
      var dy;
      var ay;
      var bx0;
      var bx1;
      var bx2;
      var bx3;
      var vector = [];
      for (y = 0; y < la; y++) {
        vector.push(y + 1);
        vector.push(a.charCodeAt(offset + y));
      }
      var len = vector.length - 1;
      for (; x < lb - 3; ) {
        bx0 = b.charCodeAt(offset + (d0 = x));
        bx1 = b.charCodeAt(offset + (d1 = x + 1));
        bx2 = b.charCodeAt(offset + (d2 = x + 2));
        bx3 = b.charCodeAt(offset + (d3 = x + 3));
        dd = x += 4;
        for (y = 0; y < len; y += 2) {
          dy = vector[y];
          ay = vector[y + 1];
          d0 = _min(dy, d0, d1, bx0, ay);
          d1 = _min(d0, d1, d2, bx1, ay);
          d2 = _min(d1, d2, d3, bx2, ay);
          dd = _min(d2, d3, dd, bx3, ay);
          vector[y] = dd;
          d3 = d2;
          d2 = d1;
          d1 = d0;
          d0 = dy;
        }
      }
      for (; x < lb; ) {
        bx0 = b.charCodeAt(offset + (d0 = x));
        dd = ++x;
        for (y = 0; y < len; y += 2) {
          dy = vector[y];
          vector[y] = dd = _min(dy, d0, dd, bx0, vector[y + 1]);
          d0 = dy;
        }
      }
      return dd;
    };
  }();
});

// ../../node_modules/.pnpm/klona@1.1.2/node_modules/klona/dist/index.js
var require_dist4 = __commonJS((exports2, module2) => {
  module2.exports = function klona5(x) {
    if (typeof x !== "object")
      return x;
    var k, tmp, str = Object.prototype.toString.call(x);
    if (str === "[object Object]") {
      if (x.constructor !== Object && typeof x.constructor === "function") {
        tmp = new x.constructor();
        for (k in x) {
          if (tmp.hasOwnProperty(k) && tmp[k] !== x[k]) {
            tmp[k] = klona5(x[k]);
          }
        }
      } else {
        tmp = {};
        for (k in x) {
          if (k === "__proto__") {
            Object.defineProperty(tmp, k, {
              value: klona5(x[k]),
              configurable: true,
              enumerable: true,
              writable: true
            });
          } else {
            tmp[k] = klona5(x[k]);
          }
        }
      }
      return tmp;
    }
    if (str === "[object Array]") {
      k = x.length;
      for (tmp = Array(k); k--; ) {
        tmp[k] = klona5(x[k]);
      }
      return tmp;
    }
    if (str === "[object Set]") {
      tmp = new Set();
      x.forEach(function(val) {
        tmp.add(klona5(val));
      });
      return tmp;
    }
    if (str === "[object Map]") {
      tmp = new Map();
      x.forEach(function(val, key) {
        tmp.set(klona5(key), klona5(val));
      });
      return tmp;
    }
    if (str === "[object Date]") {
      return new Date(+x);
    }
    if (str === "[object RegExp]") {
      tmp = new RegExp(x.source, x.flags);
      tmp.lastIndex = x.lastIndex;
      return tmp;
    }
    if (str.slice(-6) === "Array]") {
      return new x.constructor(x);
    }
    return x;
  };
});

// ../../node_modules/.pnpm/flat-map-polyfill@0.3.8/node_modules/flat-map-polyfill/dist/cjs/array-species-create.js
var require_array_species_create = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
    return typeof obj;
  } : function(obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  };
  exports2.default = arraySpeciesCreate;
  function arraySpeciesCreate(originalArray, length) {
    var isArray = Array.isArray(originalArray);
    if (!isArray) {
      return Array(length);
    }
    var C = Object.getPrototypeOf(originalArray).constructor;
    if (C) {
      if ((typeof C === "undefined" ? "undefined" : _typeof(C)) === "object" || typeof C === "function") {
        C = C[Symbol.species.toString()];
        C = C !== null ? C : void 0;
      }
      if (C === void 0) {
        return Array(length);
      }
      if (typeof C !== "function") {
        throw TypeError("invalid constructor");
      }
      var result = new C(length);
      return result;
    }
  }
});

// ../../node_modules/.pnpm/flat-map-polyfill@0.3.8/node_modules/flat-map-polyfill/dist/cjs/flatten-into-array.js
var require_flatten_into_array = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = flattenIntoArray;
  function flattenIntoArray(target, source, start, depth, mapperFunction, thisArg) {
    var mapperFunctionProvied = mapperFunction !== void 0;
    var targetIndex = start;
    var sourceIndex = 0;
    var sourceLen = source.length;
    while (sourceIndex < sourceLen) {
      var p = sourceIndex;
      var exists2 = !!source[p];
      if (exists2 === true) {
        var element = source[p];
        if (element) {
          if (mapperFunctionProvied) {
            element = mapperFunction.call(thisArg, element, sourceIndex, target);
          }
          var spreadable = Object.getOwnPropertySymbols(element).includes(Symbol.isConcatSpreadable) || Array.isArray(element);
          if (spreadable === true && depth > 0) {
            var nextIndex = flattenIntoArray(target, element, targetIndex, depth - 1);
            targetIndex = nextIndex;
          } else {
            if (!Number.isSafeInteger(targetIndex)) {
              throw TypeError();
            }
            target[targetIndex] = element;
          }
        }
      }
      targetIndex += 1;
      sourceIndex += 1;
    }
    return targetIndex;
  }
});

// ../../node_modules/.pnpm/flat-map-polyfill@0.3.8/node_modules/flat-map-polyfill/dist/cjs/flatten.js
var require_flatten = __commonJS(() => {
  "use strict";
  var _arraySpeciesCreate = require_array_species_create();
  var _arraySpeciesCreate2 = _interopRequireDefault(_arraySpeciesCreate);
  var _flattenIntoArray = require_flatten_into_array();
  var _flattenIntoArray2 = _interopRequireDefault(_flattenIntoArray);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  if (!Object.prototype.hasOwnProperty.call(Array.prototype, "flatten")) {
    Array.prototype.flatten = function flatten2(depth) {
      var o = Object(this);
      var a = (0, _arraySpeciesCreate2.default)(o, this.length);
      var depthNum = depth !== void 0 ? Number(depth) : Infinity;
      (0, _flattenIntoArray2.default)(a, o, 0, depthNum);
      return a.filter(function(e) {
        return e !== void 0;
      });
    };
  }
});

// ../../node_modules/.pnpm/flat-map-polyfill@0.3.8/node_modules/flat-map-polyfill/dist/cjs/flat-map.js
var require_flat_map = __commonJS(() => {
  "use strict";
  var _flattenIntoArray = require_flatten_into_array();
  var _flattenIntoArray2 = _interopRequireDefault(_flattenIntoArray);
  var _arraySpeciesCreate = require_array_species_create();
  var _arraySpeciesCreate2 = _interopRequireDefault(_arraySpeciesCreate);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  if (!Object.prototype.hasOwnProperty.call(Array.prototype, "flatMap")) {
    Array.prototype.flatMap = function flatMap2(callbackFn, thisArg) {
      var o = Object(this);
      if (!callbackFn || typeof callbackFn.call !== "function") {
        throw TypeError("callbackFn must be callable.");
      }
      var t = thisArg !== void 0 ? thisArg : void 0;
      var a = (0, _arraySpeciesCreate2.default)(o, o.length);
      (0, _flattenIntoArray2.default)(a, o, 0, 1, callbackFn, t);
      return a.filter(function(x) {
        return x !== void 0;
      }, a);
    };
  }
});

// ../../node_modules/.pnpm/path-exists@3.0.0/node_modules/path-exists/index.js
var require_path_exists = __commonJS((exports2, module2) => {
  "use strict";
  const fs3 = require("fs");
  module2.exports = (fp) => new Promise((resolve) => {
    fs3.access(fp, (err) => {
      resolve(!err);
    });
  });
  module2.exports.sync = (fp) => {
    try {
      fs3.accessSync(fp);
      return true;
    } catch (err) {
      return false;
    }
  };
});

// ../../node_modules/.pnpm/p-try@2.2.0/node_modules/p-try/index.js
var require_p_try = __commonJS((exports2, module2) => {
  "use strict";
  const pTry = (fn, ...arguments_) => new Promise((resolve) => {
    resolve(fn(...arguments_));
  });
  module2.exports = pTry;
  module2.exports.default = pTry;
});

// ../../node_modules/.pnpm/p-limit@2.3.0/node_modules/p-limit/index.js
var require_p_limit = __commonJS((exports2, module2) => {
  "use strict";
  const pTry = require_p_try();
  const pLimit = (concurrency) => {
    if (!((Number.isInteger(concurrency) || concurrency === Infinity) && concurrency > 0)) {
      return Promise.reject(new TypeError("Expected `concurrency` to be a number from 1 and up"));
    }
    const queue = [];
    let activeCount = 0;
    const next = () => {
      activeCount--;
      if (queue.length > 0) {
        queue.shift()();
      }
    };
    const run = (fn, resolve, ...args) => {
      activeCount++;
      const result = pTry(fn, ...args);
      resolve(result);
      result.then(next, next);
    };
    const enqueue = (fn, resolve, ...args) => {
      if (activeCount < concurrency) {
        run(fn, resolve, ...args);
      } else {
        queue.push(run.bind(null, fn, resolve, ...args));
      }
    };
    const generator = (fn, ...args) => new Promise((resolve) => enqueue(fn, resolve, ...args));
    Object.defineProperties(generator, {
      activeCount: {
        get: () => activeCount
      },
      pendingCount: {
        get: () => queue.length
      },
      clearQueue: {
        value: () => {
          queue.length = 0;
        }
      }
    });
    return generator;
  };
  module2.exports = pLimit;
  module2.exports.default = pLimit;
});

// ../../node_modules/.pnpm/p-locate@3.0.0/node_modules/p-locate/index.js
var require_p_locate = __commonJS((exports2, module2) => {
  "use strict";
  const pLimit = require_p_limit();
  class EndError extends Error {
    constructor(value) {
      super();
      this.value = value;
    }
  }
  const testElement = (el, tester) => Promise.resolve(el).then(tester);
  const finder = (el) => Promise.all(el).then((val) => val[1] === true && Promise.reject(new EndError(val[0])));
  module2.exports = (iterable, tester, opts) => {
    opts = Object.assign({
      concurrency: Infinity,
      preserveOrder: true
    }, opts);
    const limit = pLimit(opts.concurrency);
    const items = [...iterable].map((el) => [el, limit(testElement, el, tester)]);
    const checkLimit = pLimit(opts.preserveOrder ? 1 : Infinity);
    return Promise.all(items.map((el) => checkLimit(finder, el))).then(() => {
    }).catch((err) => err instanceof EndError ? err.value : Promise.reject(err));
  };
});

// ../../node_modules/.pnpm/locate-path@3.0.0/node_modules/locate-path/index.js
var require_locate_path = __commonJS((exports2, module2) => {
  "use strict";
  const path9 = require("path");
  const pathExists = require_path_exists();
  const pLocate = require_p_locate();
  module2.exports = (iterable, options) => {
    options = Object.assign({
      cwd: process.cwd()
    }, options);
    return pLocate(iterable, (el) => pathExists(path9.resolve(options.cwd, el)), options);
  };
  module2.exports.sync = (iterable, options) => {
    options = Object.assign({
      cwd: process.cwd()
    }, options);
    for (const el of iterable) {
      if (pathExists.sync(path9.resolve(options.cwd, el))) {
        return el;
      }
    }
  };
});

// ../../node_modules/.pnpm/find-up@3.0.0/node_modules/find-up/index.js
var require_find_up = __commonJS((exports2, module2) => {
  "use strict";
  const path9 = require("path");
  const locatePath = require_locate_path();
  module2.exports = (filename, opts = {}) => {
    const startDir = path9.resolve(opts.cwd || "");
    const {root} = path9.parse(startDir);
    const filenames = [].concat(filename);
    return new Promise((resolve) => {
      (function find(dir) {
        locatePath(filenames, {cwd: dir}).then((file) => {
          if (file) {
            resolve(path9.join(dir, file));
          } else if (dir === root) {
            resolve(null);
          } else {
            find(path9.dirname(dir));
          }
        });
      })(startDir);
    });
  };
  module2.exports.sync = (filename, opts = {}) => {
    let dir = path9.resolve(opts.cwd || "");
    const {root} = path9.parse(dir);
    const filenames = [].concat(filename);
    while (true) {
      const file = locatePath.sync(filenames, {cwd: dir});
      if (file) {
        return path9.join(dir, file);
      }
      if (dir === root) {
        return null;
      }
      dir = path9.dirname(dir);
    }
  };
});

// ../../node_modules/.pnpm/pkg-up@3.1.0/node_modules/pkg-up/index.js
var require_pkg_up = __commonJS((exports2, module2) => {
  "use strict";
  const findUp = require_find_up();
  module2.exports = async ({cwd} = {}) => findUp("package.json", {cwd});
  module2.exports.sync = ({cwd} = {}) => findUp.sync("package.json", {cwd});
});

// package.json
var require_package = __commonJS((exports2, module2) => {
  module2.exports = {
    name: "@prisma/client",
    version: "2.7.1",
    description: "Prisma Client is an auto-generated, type-safe and modern JavaScript/TypeScript ORM for Node.js that's tailored to your data. Supports MySQL, PostgreSQL, MariaDB, SQLite databases.",
    keywords: [
      "orm",
      "prisma2",
      "prisma",
      "client",
      "query",
      "database",
      "sql",
      "postgres",
      "postgresql",
      "mysql",
      "sqlite",
      "mariadb",
      "typescript",
      "query-builder"
    ],
    main: "index.js",
    types: "index.d.ts",
    license: "Apache-2.0",
    engines: {
      node: ">=10"
    },
    homepage: "https://github.com/prisma/prisma-client-js",
    repository: {
      url: "git@github.com:prisma/prisma.git"
    },
    maintainers: [
      "Tim Suchanek <suchanek@prisma.io>",
      "Joël Galeran <galeran@prisma.io>"
    ],
    bugs: {
      email: "suchanek@prisma.io",
      url: "https://github.com/prisma/prisma-client-js/issues"
    },
    scripts: {
      build: "node helpers/build.js",
      test: "jest",
      format: "prettier --write .",
      lint: "eslint --fix --ext .js,.ts .",
      download: "node scripts/download.js",
      generate: "node scripts/postinstall.js",
      postinstall: "node scripts/postinstall.js",
      prepare: 'cp scripts/backup-index.js index.js && cp scripts/backup-index.d.ts index.d.ts && node scripts/download.js || echo ""',
      prepublishOnly: "pnpm run build"
    },
    prisma: {
      version: "latest"
    },
    files: [
      "runtime",
      "scripts",
      "generator-build",
      "index.js",
      "index.d.ts"
    ],
    devDependencies: {
      "@prisma/debug": "2.7.1",
      "@prisma/engine-core": "2.7.1",
      "@prisma/fetch-engine": "2.7.1",
      "@prisma/generator-helper": "2.7.1",
      "@prisma/get-platform": "2.7.1",
      "@prisma/sdk": "2.7.1",
      "@timsuchanek/copy": "^1.4.5",
      "@types/debug": "4.1.5",
      "@types/fs-extra": "9.0.1",
      "@types/jest": "26.0.13",
      "@types/js-levenshtein": "1.1.0",
      "@types/node": "12.12.58",
      "@types/node-fetch": "2.5.7",
      "@types/pg": "7.14.4",
      "@typescript-eslint/eslint-plugin": "4.1.0",
      "@typescript-eslint/parser": "4.1.0",
      arg: "4.1.3",
      benchmark: "2.1.4",
      chalk: "4.1.0",
      del: "5.1.0",
      dotenv: "8.2.0",
      "escape-string-regexp": "^4.0.0",
      eslint: "7.8.1",
      "eslint-config-prettier": "6.11.0",
      "eslint-plugin-eslint-comments": "3.2.0",
      "eslint-plugin-jest": "24.0.0",
      "eslint-plugin-prettier": "3.1.4",
      execa: "4.0.3",
      "fast-clone": "1.5.13",
      "fast-copy": "2.1.0",
      "flat-map-polyfill": "0.3.8",
      "fs-monkey": "1.0.1",
      "get-own-enumerable-property-symbols": "3.0.2",
      "get-port": "5.1.1",
      husky: "4.3.0",
      "indent-string": "4.0.0",
      "is-obj": "2.0.0",
      "is-regexp": "2.1.0",
      jest: "26.4.2",
      "jest-diff": "26.4.2",
      "js-levenshtein": "1.1.6",
      klona: "1.1.2",
      "lint-staged": "10.3.0",
      "make-dir": "3.1.0",
      "node-fetch": "2.6.1",
      "node-tcp-proxy": "0.0.15",
      packwatch: "2.0.0",
      pg: "8.3.3",
      pidtree: "0.5.0",
      pluralize: "8.0.0",
      prettier: "2.1.1",
      "replace-string": "3.1.0",
      rimraf: "3.0.2",
      rollup: "^2.26.11",
      "rollup-plugin-dts": "^1.4.13",
      "set-value": "3.0.2",
      "sql-template-tag": "3.4.0",
      "stacktrace-parser": "0.1.10",
      "stat-mode": "1.0.0",
      "strip-ansi": "6.0.0",
      "strip-indent": "3.0.0",
      "ts-jest": "26.3.0",
      "ts-loader": "8.0.3",
      "ts-node": "9.0.0",
      typescript: "4.0.2"
    },
    peerDependencies: {
      "@prisma/cli": "*"
    },
    peerDependenciesMeta: {
      "@prisma/cli": {
        optional: true
      }
    },
    husky: {
      hooks: {
        "pre-commit": "lint-staged"
      }
    },
    "lint-staged": {
      "*.{js,ts,css,json,md}": [
        "prettier --write",
        "git add"
      ],
      "*.{js,ts}": [
        "eslint"
      ]
    },
    dependencies: {
      "pkg-up": "^3.1.0"
    }
  };
});

// src/runtime/utils/common.ts
const chalk = __toModule(require_source());
const indent_string = __toModule(require_indent_string());
const js_levenshtein = __toModule(require_js_levenshtein());
const keyBy = (collection, prop) => {
  const acc = {};
  for (const obj of collection) {
    const key = obj[prop];
    acc[key] = obj;
  }
  return acc;
};
const keyBy2 = (collection1, collection2, prop) => {
  const acc = {};
  for (const obj of collection1) {
    const key = obj[prop];
    acc[key] = obj;
  }
  for (const obj of collection2) {
    const key = obj[prop];
    acc[key] = obj;
  }
  return acc;
};
const ScalarTypeTable = {
  String: true,
  Int: true,
  Float: true,
  Boolean: true,
  Long: true,
  DateTime: true,
  ID: true,
  UUID: true,
  Json: true
};
const GraphQLScalarToJSTypeTable = {
  String: "string",
  Int: "number",
  Float: "number",
  Boolean: "boolean",
  Long: "number",
  DateTime: ["Date", "string"],
  ID: "string",
  UUID: "string",
  Json: "JsonValue"
};
const JSOutputTypeToInputType = {
  JsonValue: "InputJsonValue"
};
function uniqBy(arr, iteratee) {
  const map = {};
  for (const element of arr) {
    map[iteratee(element)] = element;
  }
  return Object.values(map);
}
function capitalize(str) {
  return str[0].toUpperCase() + str.slice(1);
}
function lowerCase(name) {
  return name.substring(0, 1).toLowerCase() + name.substring(1);
}

// src/runtime/utils/uniqueBy.ts
function uniqueBy(arr, callee) {
  const result = {};
  for (const value of arr) {
    const hash = callee(value);
    if (!result[hash]) {
      result[hash] = value;
    }
  }
  return Object.values(result);
}

// src/runtime/externalToInternalDmmf.ts
const pluralize = __toModule(require_pluralize());
function transformFieldKind(model) {
  return {
    ...model,
    fields: model.fields.map((field) => ({
      ...field,
      kind: field.kind === "relation" ? "object" : field.kind
    }))
  };
}
function transformDatamodel(datamodel) {
  return {
    enums: datamodel.enums.map((enumValue) => ({
      ...enumValue,
      values: enumValue.values.map((v) => v.name)
    })),
    models: datamodel.models.map(transformFieldKind)
  };
}
function externalToInternalDmmf(document2) {
  const datamodel = transformDatamodel(document2.datamodel);
  return {
    datamodel,
    mappings: getMappings(document2.mappings, datamodel),
    schema: transformSchema(document2.schema)
  };
}
function transformSchema(schema) {
  return {
    enums: schema.enums,
    inputTypes: schema.inputTypes.map((t) => ({
      ...t,
      fields: uniqueBy(transformArgs(t.fields), (f) => f.name)
    })),
    outputTypes: schema.outputTypes.map((o) => ({
      ...o,
      fields: o.fields.map((f) => ({...f, args: transformArgs(f.args)}))
    }))
  };
}
function transformArgs(args) {
  return args.map(transformArg);
}
function transformArg(arg) {
  return {
    name: arg.name,
    inputType: [arg.inputType]
  };
}
function getMappings(mappings, datamodel) {
  return mappings.filter((mapping) => {
    const model = datamodel.models.find((m) => m.name === mapping.model);
    if (!model) {
      throw new Error(`Mapping without model ${mapping.model}`);
    }
    return model.fields.some((f) => f.kind !== "object");
  }).map((mapping) => ({
    model: mapping.model,
    plural: pluralize.default(lowerCase(mapping.model)),
    findOne: mapping.findSingle || mapping.findOne,
    findMany: mapping.findMany,
    create: mapping.createOne || mapping.createSingle || mapping.create,
    delete: mapping.deleteOne || mapping.deleteSingle || mapping.delete,
    update: mapping.updateOne || mapping.updateSingle || mapping.update,
    deleteMany: mapping.deleteMany,
    updateMany: mapping.updateMany,
    upsert: mapping.upsertOne || mapping.upsertSingle || mapping.upsert,
    aggregate: mapping.aggregate
  }));
}

// src/runtime/transformDmmf.ts
const klona = __toModule(require_dist4());
function transformDmmf(document2) {
  const doc = transformInputTypes(document2);
  return {
    datamodel: doc.datamodel,
    mappings: doc.mappings,
    schema: {
      enums: doc.schema.enums,
      rootMutationType: doc.schema.rootMutationType,
      rootQueryType: doc.schema.rootQueryType,
      outputTypes: filterOutputTypes(doc.schema.outputTypes),
      inputTypes: markOrderInputType(makeWhereUniqueInputsRequired(filterInputTypes(doc.schema.inputTypes)))
    }
  };
}
function markOrderInputType(inputTypes) {
  return inputTypes.map((t) => {
    if (t.name.endsWith("OrderByInput")) {
      t.isOrderType = true;
    }
    return t;
  });
}
function filterInputTypes(types) {
  return uniqBy(types, (o) => o.name);
}
function filterOutputTypes(types) {
  return uniqBy(types, (o) => o.name);
}
function makeWhereUniqueInputsRequired(inputTypes) {
  return inputTypes.map((inputType) => {
    if (inputType.name.endsWith("WhereUniqueInput")) {
      inputType.atLeastOne = true;
    }
    return inputType;
  });
}
function transformInputTypes(document2) {
  const inputTypeMap = Object.create(null);
  for (const inputType of document2.schema.inputTypes) {
    inputTypeMap[inputType.name] = inputType;
  }
  const inputTypeFieldLookupMap = Object.create(null);
  document2.schema.inputTypes = document2.schema.inputTypes.map((inputType) => {
    if (inputType.name.endsWith("Filter") && !inputType.name.endsWith("RelationFilter")) {
      const inFieldIndex = inputType.fields.findIndex((f) => f.name === "in");
      if (inFieldIndex > -1) {
        const inField = inputType.fields[inFieldIndex];
        const notInField = klona.default(inField);
        notInField.name = "notIn";
        inputType.fields.splice(inFieldIndex + 1, 0, notInField);
      }
    }
    if (inputType.name.endsWith("WhereInput")) {
      inputType.isWhereType = true;
      inputType.fields = inputType.fields.map((f) => {
        var _a;
        const inputTypeType = f.inputType[0];
        const inputTypeName = inputTypeType.type.toString();
        if (inputTypeName.endsWith("Filter")) {
          if (inputTypeName.endsWith("RelationFilter")) {
            const nestedInputType = inputTypeMap[inputTypeName];
            const isField = nestedInputType.fields.find((f2) => f2.name === "is");
            if (isField) {
              f.inputType[0] = isField.inputType[0];
            }
          }
          const filterType = inputTypeMap[inputTypeName];
          if (!filterType) {
            throw new Error(`Could not find filterType ${filterType}`);
          }
          let equalsField = (_a = inputTypeFieldLookupMap[inputTypeName]) == null ? void 0 : _a.equals;
          if (!equalsField) {
            equalsField = filterType.fields.find((field) => field.name === "equals");
            inputTypeFieldLookupMap[inputTypeName] = {
              equals: equalsField
            };
          }
          if (equalsField) {
            if (equalsField.inputType[0].type !== "Json") {
              f.inputType.unshift(equalsField.inputType[0]);
            }
            if (equalsField.inputType[0].isNullable) {
              f.inputType.push({
                isList: false,
                isNullable: true,
                isRequired: false,
                kind: "scalar",
                type: "null"
              });
            }
            if (!inputTypeFieldLookupMap[inputTypeName].not) {
              const notField = filterType.fields.find((field) => field.name === "not");
              if (notField && notField.inputType.length === 1) {
                if (equalsField.inputType[0].type === "Json") {
                  if (notField.inputType[0].type === "NestedJsonNullableFilter") {
                    notField.inputType = [];
                  }
                }
                notField.inputType.unshift(equalsField.inputType[0]);
              }
              inputTypeFieldLookupMap[inputTypeName].not = notField;
            }
          }
        }
        return f;
      });
    }
    if (inputType.name.endsWith("WhereUniqueInput")) {
      inputType.atLeastOne = true;
    }
    if (inputType.name.endsWith("UpdateInput") || inputType.name.endsWith("UpdateManyMutationInput") || inputType.name.includes("UpdateWithout") && inputType.name.endsWith("DataInput") || inputType.name.endsWith("UpdateManyDataInput")) {
      inputType.isUpdateType = true;
      for (const field of inputType.fields) {
        const fieldInputTypeName = field.inputType[0].type.toString();
        if (fieldInputTypeName.endsWith("FieldUpdateOperationsInput")) {
          const fieldInputType = inputTypeMap[fieldInputTypeName];
          if (!fieldInputType) {
            throw new Error(`Could not find field input type ${fieldInputTypeName}`);
          }
          fieldInputType.isUpdateOperationType = true;
          const setField = fieldInputType.fields.find((f) => f.name === "set");
          if (!setField) {
            continue;
          }
          if (fieldInputTypeName.endsWith("JsonFieldUpdateOperationsInput")) {
            field.inputType = [];
          }
          field.inputType.unshift(setField.inputType[0]);
        }
      }
    }
    return inputType;
  });
  return document2;
}

// src/generation/getDMMF.ts
const engineCommands = __toModule(require_engineCommands());
function getPrismaClientDMMF(dmmf2) {
  return transformDmmf(externalToInternalDmmf(dmmf2));
}
async function getDMMF(options) {
  const dmmf2 = await engineCommands.getDMMF(options);
  return getPrismaClientDMMF(dmmf2);
}

// src/utils/resolveDatasources.ts
const path = __toModule(require("path"));
function resolveDatasources(datasources, cwd, outputDir, absolutePaths) {
  return datasources.map((datasource) => {
    if (datasource.activeProvider === "sqlite") {
      if (datasource.url.fromEnvVar === null) {
        return {
          ...datasource,
          url: {
            fromEnvVar: null,
            value: absolutizeRelativePath(datasource.url.value, cwd, outputDir, absolutePaths)
          }
        };
      } else {
        return datasource;
      }
    }
    return datasource;
  });
}
function absolutizeRelativePath(url, cwd, outputDir, absolutePaths) {
  let filePath = url;
  if (filePath.startsWith("file:")) {
    filePath = filePath.slice(5);
  }
  const absoluteTarget = path.default.resolve(cwd, filePath);
  if (absolutePaths) {
    return absoluteTarget;
  }
  return `${path.default.relative(outputDir, absoluteTarget)}`;
}

// src/generation/extractSqliteSources.ts
function extractSqliteSources(datamodel, cwd, outputDir, absolutePaths) {
  const overrides = [];
  const lines = datamodel.split("\n").filter((l) => !l.trim().startsWith("//"));
  const lineRegex = /\s*url\s+=\s*"(file:[^\/].*)"/;
  const startRegex = /\s*datasource\s*(\w+)\s*{/;
  lines.forEach((line, index) => {
    const match = lineRegex.exec(line);
    if (match) {
      let startLine;
      let searchIndex = index - 1;
      while (!startLine && searchIndex >= 0) {
        const currentLine = lines[searchIndex];
        const commentIndex = currentLine.indexOf("//");
        const curlyIndex = currentLine.indexOf("{");
        if (curlyIndex > -1) {
          if (commentIndex === -1) {
            startLine = currentLine;
          }
          if (commentIndex > curlyIndex) {
            startLine = currentLine;
          }
        }
        searchIndex--;
      }
      if (!startLine) {
        throw new Error(`Could not parse datamodel, invalid datasource block without opening \`{\``);
      }
      const startMatch = startRegex.exec(startLine);
      if (startMatch) {
        overrides.push({
          name: startMatch[1],
          url: absolutizeRelativePath(match[1], cwd, outputDir, absolutePaths)
        });
      } else {
        throw new Error(`Could not parse datamodel, line ${searchIndex + 1}: \`${startLine}\` is not parseable`);
      }
    }
  });
  return overrides;
}

// ../../node_modules/.pnpm/flat-map-polyfill@0.3.8/node_modules/flat-map-polyfill/dist/cjs/index.js
"use strict";
require_flatten();
require_flat_map();

// src/runtime/dmmf.ts
class DMMFClass {
  constructor({datamodel, schema, mappings}) {
    this.outputTypeMap = {};
    this.outputTypeToMergedOutputType = (outputType) => {
      const model = this.modelMap[outputType.name];
      return {
        ...outputType,
        isEmbedded: model ? model.isEmbedded : false,
        fields: outputType.fields
      };
    };
    this.datamodel = datamodel;
    this.schema = schema;
    this.mappings = mappings;
    this.enumMap = this.getEnumMap();
    this.queryType = this.getQueryType();
    this.mutationType = this.getMutationType();
    this.modelMap = this.getModelMap();
    this.outputTypes = this.getOutputTypes();
    this.outputTypeMap = this.getMergedOutputTypeMap();
    this.resolveOutputTypes(this.outputTypes);
    this.inputTypes = this.schema.inputTypes;
    this.inputTypeMap = this.getInputTypeMap();
    this.resolveInputTypes(this.inputTypes);
    this.resolveFieldArgumentTypes(this.outputTypes, this.inputTypeMap);
    this.mappingsMap = this.getMappingsMap();
    this.queryType = this.outputTypeMap.Query;
    this.mutationType = this.outputTypeMap.Mutation;
    this.outputTypes = this.outputTypes;
    this.rootFieldMap = this.getRootFieldMap();
  }
  resolveOutputTypes(types) {
    for (const type of types) {
      for (const field of type.fields) {
        if (typeof field.outputType.type === "string" && !ScalarTypeTable[field.outputType.type]) {
          field.outputType.type = this.outputTypeMap[field.outputType.type] || this.enumMap[field.outputType.type] || field.outputType.type;
        }
      }
      type.fieldMap = keyBy(type.fields, "name");
    }
  }
  resolveInputTypes(types) {
    for (const type of types) {
      for (const field of type.fields) {
        const first = field.inputType[0].type;
        if (typeof first === "string" && !ScalarTypeTable[first] && (this.inputTypeMap[first] || this.enumMap[first])) {
          field.inputType[0].type = this.inputTypeMap[first] || this.enumMap[first] || field.inputType[0].type;
        }
        const second = field.inputType[1] && field.inputType[1].type;
        if (typeof second === "string" && !ScalarTypeTable[second] && (this.inputTypeMap[second] || this.enumMap[second])) {
          field.inputType[1].type = this.inputTypeMap[second] || this.enumMap[second] || field.inputType[1].type;
        }
      }
      type.fieldMap = keyBy(type.fields, "name");
    }
  }
  resolveFieldArgumentTypes(types, inputTypeMap) {
    for (const type of types) {
      for (const field of type.fields) {
        for (const arg of field.args) {
          const first = arg.inputType[0].type;
          if (typeof first === "string" && !ScalarTypeTable[first]) {
            arg.inputType[0].type = inputTypeMap[first] || this.enumMap[first] || arg.inputType[0].type;
          }
          const second = arg.inputType[1] && arg.inputType[1].type;
          if (second && typeof second === "string" && !ScalarTypeTable[second]) {
            arg.inputType[1].type = inputTypeMap[second] || this.enumMap[second] || arg.inputType[1].type;
          }
        }
      }
    }
  }
  getQueryType() {
    return this.schema.outputTypes.find((t) => t.name === "Query");
  }
  getMutationType() {
    return this.schema.outputTypes.find((t) => t.name === "Mutation");
  }
  getOutputTypes() {
    return this.schema.outputTypes.map(this.outputTypeToMergedOutputType);
  }
  getEnumMap() {
    return keyBy(this.schema.enums, "name");
  }
  getModelMap() {
    return keyBy(this.datamodel.models, "name");
  }
  getMergedOutputTypeMap() {
    return keyBy(this.outputTypes, "name");
  }
  getInputTypeMap() {
    return keyBy(this.schema.inputTypes, "name");
  }
  getMappingsMap() {
    return keyBy(this.mappings, "model");
  }
  getRootFieldMap() {
    return keyBy2(this.queryType.fields, this.mutationType.fields, "name");
  }
}

// src/runtime/dmmf-types.ts
var DMMF;
(function(DMMF2) {
  let ModelAction;
  (function(ModelAction2) {
    ModelAction2["findOne"] = "findOne";
    ModelAction2["findMany"] = "findMany";
    ModelAction2["create"] = "create";
    ModelAction2["update"] = "update";
    ModelAction2["updateMany"] = "updateMany";
    ModelAction2["upsert"] = "upsert";
    ModelAction2["delete"] = "delete";
    ModelAction2["deleteMany"] = "deleteMany";
  })(ModelAction = DMMF2.ModelAction || (DMMF2.ModelAction = {}));
})(DMMF || (DMMF = {}));

// src/generation/utils.ts
const indent_string2 = __toModule(require_indent_string());
const path3 = __toModule(require("path"));
var Projection;
(function(Projection2) {
  Projection2["select"] = "select";
  Projection2["include"] = "include";
})(Projection || (Projection = {}));
function getPayloadName(modelName) {
  return `${modelName}GetPayload`;
}
function getSelectName(modelName) {
  return `${modelName}Select`;
}
function getAggregateName(modelName) {
  return `Aggregate${capitalize2(modelName)}`;
}
function getAvgAggregateName(modelName) {
  return `${capitalize2(modelName)}AvgAggregateOutputType`;
}
function getSumAggregateName(modelName) {
  return `${capitalize2(modelName)}SumAggregateOutputType`;
}
function getMinAggregateName(modelName) {
  return `${capitalize2(modelName)}MinAggregateOutputType`;
}
function getMaxAggregateName(modelName) {
  return `${capitalize2(modelName)}MaxAggregateOutputType`;
}
function getAggregateInputType(aggregateOutputType) {
  return aggregateOutputType.replace(/OutputType$/, "InputType");
}
function getAggregateArgsName(modelName) {
  return `Aggregate${capitalize2(modelName)}Args`;
}
function getAggregateGetName(modelName) {
  return `Get${capitalize2(modelName)}AggregateType`;
}
function getAggregateScalarGetName(modelName) {
  return `Get${capitalize2(modelName)}AggregateScalarType`;
}
function getIncludeName(modelName) {
  return `${modelName}Include`;
}
function getFieldArgName(field) {
  return getArgName(field.outputType.type.name, field.outputType.isList);
}
function getArgName(name, isList) {
  if (!isList) {
    return `${name}Args`;
  }
  return `FindMany${name}Args`;
}
function getModelArgName(modelName, action) {
  if (!action) {
    return `${modelName}Args`;
  }
  switch (action) {
    case DMMF.ModelAction.findMany:
      return `FindMany${modelName}Args`;
    case DMMF.ModelAction.findOne:
      return `FindOne${modelName}Args`;
    case DMMF.ModelAction.upsert:
      return `${modelName}UpsertArgs`;
    case DMMF.ModelAction.update:
      return `${modelName}UpdateArgs`;
    case DMMF.ModelAction.updateMany:
      return `${modelName}UpdateManyArgs`;
    case DMMF.ModelAction.delete:
      return `${modelName}DeleteArgs`;
    case DMMF.ModelAction.create:
      return `${modelName}CreateArgs`;
    case DMMF.ModelAction.deleteMany:
      return `${modelName}DeleteManyArgs`;
  }
}
function getType(name, isList, isOptional) {
  return name + (isList ? "[]" : "") + (isOptional ? " | null" : "");
}
function getSelectReturnType({
  name,
  actionName,
  renderPromise = true,
  hideCondition = false,
  isField = false
}) {
  const isList = actionName === DMMF.ModelAction.findMany;
  if (actionName === "deleteMany" || actionName === "updateMany") {
    return `Promise<BatchPayload>`;
  }
  if (isList || hideCondition) {
    const listOpen = isList ? "Array<" : "";
    const listClose = isList ? ">" : "";
    const promiseOpen = renderPromise ? "Promise<" : "";
    const promiseClose = renderPromise ? ">" : "";
    return `CheckSelect<T, ${promiseOpen}${listOpen}${name}${listClose}${promiseClose}, ${promiseOpen}${listOpen}${getPayloadName(name)}<T>${listClose}${promiseClose}>`;
  }
  return `CheckSelect<T, Prisma__${name}Client<${getType(name, isList)}${actionName === "findOne" ? " | null" : ""}>, Prisma__${name}Client<${getType(getPayloadName(name) + "<T>", isList)}${actionName === "findOne" ? " | null" : ""}>>`;
}
function capitalize2(str) {
  return str[0].toUpperCase() + str.slice(1);
}
function flatten(array) {
  return Array.prototype.concat.apply([], array);
}
function flatMap(array, callbackFn, thisArg) {
  return flatten(array.map(callbackFn, thisArg));
}

// src/generation/TSClient.ts
const indent_string3 = __toModule(require_indent_string());
const path5 = __toModule(require("path"));
const pluralize3 = __toModule(require_pluralize());
const klona3 = __toModule(require_dist4());
const tab = 2;
function JS(gen) {
  if (gen.toJS) {
    return gen.toJS();
  }
  return "";
}
function TS(gen) {
  return gen.toTS();
}
const commonCodeJS = ({
  runtimePath,
  clientVersion: clientVersion2,
  engineVersion
}) => `
Object.defineProperty(exports, "__esModule", { value: true });

const {
  PrismaClientKnownRequestError,
  PrismaClientUnknownRequestError,
  PrismaClientRustPanicError,
  PrismaClientInitializationError,
  PrismaClientValidationError,
  getPrismaClient,
  debugLib,
  sqltag,
  sql,
  empty,
  join,
  raw
} = require('${runtimePath}')

const path = require('path')
const debug = debugLib('prisma-client')

/**
 * Prisma Client JS version: ${clientVersion2}
 * Query Engine version: ${engineVersion}
 */
exports.prismaVersion = {
  client: "${clientVersion2}",
  engine: "${engineVersion}"
}

exports.PrismaClientKnownRequestError = PrismaClientKnownRequestError;
exports.PrismaClientUnknownRequestError = PrismaClientUnknownRequestError;
exports.PrismaClientRustPanicError = PrismaClientRustPanicError;
exports.PrismaClientInitializationError = PrismaClientInitializationError;
exports.PrismaClientValidationError = PrismaClientValidationError;

/**
 * Re-export of sql-template-tag
 */

exports.sql = sqltag
exports.empty = empty
exports.join = join
exports.raw = raw
`;
const commonCodeTS = ({
  runtimePath,
  clientVersion: clientVersion2,
  engineVersion
}) => `import {
  DMMF,
  DMMFClass,
  Engine,
  PrismaClientKnownRequestError,
  PrismaClientUnknownRequestError,
  PrismaClientRustPanicError,
  PrismaClientInitializationError,
  PrismaClientValidationError,
  sqltag as sql,
  empty,
  join,
  raw,
} from '${runtimePath}';

export { PrismaClientKnownRequestError }
export { PrismaClientUnknownRequestError }
export { PrismaClientRustPanicError }
export { PrismaClientInitializationError }
export { PrismaClientValidationError }

/**
 * Re-export of sql-template-tag
 */
export { sql, empty, join, raw }

/**
 * Prisma Client JS version: ${clientVersion2}
 * Query Engine version: ${engineVersion}
 */
export declare type PrismaVersion = {
  client: string
}

export declare const prismaVersion: PrismaVersion 

/**
 * Utility Types
 */

/**
 * From https://github.com/sindresorhus/type-fest/
 * Matches a JSON object.
 * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
 */
export declare type JsonObject = {[Key in string]?: JsonValue}
 
/**
 * From https://github.com/sindresorhus/type-fest/
 * Matches a JSON array.
 */
export declare interface JsonArray extends Array<JsonValue> {}
 
/**
 * From https://github.com/sindresorhus/type-fest/
 * Matches any valid JSON value.
 */
export declare type JsonValue = string | number | boolean | null | JsonObject | JsonArray

/**
 * Same as JsonObject, but allows undefined
 */
export declare type InputJsonObject = {[Key in string]?: JsonValue}
 
export declare interface InputJsonArray extends Array<JsonValue> {}
 
export declare type InputJsonValue = undefined |  string | number | boolean | null | InputJsonObject | InputJsonArray

declare type SelectAndInclude = {
  select: any
  include: any
}

declare type HasSelect = {
  select: any
}

declare type HasInclude = {
  include: any
}

declare type CheckSelect<T, S, U> = T extends SelectAndInclude
  ? 'Please either choose \`select\` or \`include\`'
  : T extends HasSelect
  ? U
  : T extends HasInclude
  ? U
  : S

/**
 * Get the type of the value, that the Promise holds.
 */
export declare type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

/**
 * Get the return type of a function which returns a Promise.
 */
export declare type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>


export declare type Enumerable<T> = T | Array<T>;

export type RequiredKeys<T> = {
  [K in keyof T]-?: {} extends Pick<T, K> ? never : K
}[keyof T]

export declare type TruthyKeys<T> = {
  [key in keyof T]: T[key] extends false | undefined | null ? never : key
}[keyof T]

export declare type TrueKeys<T> = TruthyKeys<Pick<T, RequiredKeys<T>>>

/**
 * Subset
 * @desc From \`T\` pick properties that exist in \`U\`. Simple version of Intersection
 */
export declare type Subset<T, U> = {
  [key in keyof T]: key extends keyof U ? T[key] : never;
};
declare class PrismaClientFetcher {
  private readonly prisma;
  private readonly debug;
  private readonly hooks?;
  constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
  request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
  sanitizeMessage(message: string): string;
  protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
}
`;
class TSClient {
  constructor(options) {
    this.options = options;
    this.dmmfString = escapeJson(JSON.stringify(options.document));
    this.dmmf = new DMMFClass(klona3.default(options.document));
  }
  toJS() {
    const {
      generator,
      sqliteDatasourceOverrides,
      outputDir,
      schemaDir
    } = this.options;
    const config = {
      generator,
      sqliteDatasourceOverrides,
      relativePath: path5.default.relative(outputDir, schemaDir),
      clientVersion: this.options.clientVersion,
      engineVersion: this.options.engineVersion
    };
    return `${commonCodeJS(this.options)}

/**
 * Build tool annotations
 * In order to make \`ncc\` and \`node-file-trace\` happy.
**/

${this.options.platforms ? this.options.platforms.map((p) => `path.join(__dirname, 'query-engine-${p}');`).join("\n") : ""}

/**
 * Annotation for \`node-file-trace\`
**/
path.join(__dirname, 'schema.prisma');

/**
 * Enums
 */
// Based on
// https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275
function makeEnum(x) { return x; }

${this.dmmf.schema.enums.map((type) => new Enum(type).toJS()).join("\n\n")}


/**
 * DMMF
 */
const dmmfString = ${JSON.stringify(this.dmmfString)}

// We are parsing 2 times, as we want independent objects, because
// DMMFClass introduces circular references in the dmmf object
const dmmf = JSON.parse(dmmfString)
exports.dmmf = JSON.parse(dmmfString)

/**
 * Create the Client
 */

const config = ${JSON.stringify(config, null, 2)}
config.document = dmmf
config.dirname = __dirname

const PrismaClient = getPrismaClient(config)
exports.PrismaClient = PrismaClient`;
  }
  toTS() {
    return `${commonCodeTS(this.options)}

/**
 * Client
**/

export declare type Datasource = {
  url?: string
}
${new PrismaClientClass(this.dmmf, this.options.datasources, this.options.outputDir, this.options.browser, this.options.generator, this.options.sqliteDatasourceOverrides, this.options.schemaDir).toTS()}

${""}

/**
 * Enums
 */

// Based on
// https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

${this.dmmf.schema.enums.map((type) => new Enum(type).toTS()).join("\n\n")}

${Object.values(this.dmmf.modelMap).map((model) => new Model(model, this.dmmf, this.options.generator).toTS()).join("\n")}

/**
 * Deep Input Types
 */

${this.dmmf.inputTypes.map((inputType) => new InputType(inputType).toTS()).join("\n")}

/**
 * Batch Payload for updateMany & deleteMany
 */

export type BatchPayload = {
  count: number
}

/**
 * DMMF
 */
export declare const dmmf: DMMF.Document;
export {};
`;
  }
}
class Datasources {
  constructor(internalDatasources) {
    this.internalDatasources = internalDatasources;
  }
  toTS() {
    const sources = this.internalDatasources;
    return `export type Datasources = {
${indent_string3.default(sources.map((s) => `${s.name}?: Datasource`).join("\n"), 2)}
}`;
  }
}
class PrismaClientClass {
  constructor(dmmf2, internalDatasources, outputDir, browser, generator, sqliteDatasourceOverrides, cwd) {
    this.dmmf = dmmf2;
    this.internalDatasources = internalDatasources;
    this.outputDir = outputDir;
    this.browser = browser;
    this.generator = generator;
    this.sqliteDatasourceOverrides = sqliteDatasourceOverrides;
    this.cwd = cwd;
  }
  get jsDoc() {
    const {dmmf: dmmf2} = this;
    const example = dmmf2.mappings[0];
    return `/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js (ORM replacement)
 * @example
 * \`\`\`
 * const prisma = new PrismaClient()
 * // Fetch zero or more ${capitalize(example.plural)}
 * const ${lowerCase(example.plural)} = await prisma.${lowerCase(example.model)}.findMany()
 * \`\`\`
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */`;
  }
  toTS() {
    var _a, _b;
    const {dmmf: dmmf2} = this;
    return `
${new Datasources(this.internalDatasources).toTS()}

export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

export interface PrismaClientOptions {
  /**
   * Overwrites the datasource url from your prisma.schema file
   */
  datasources?: Datasources

  /**
   * @default "colorless"
   */
  errorFormat?: ErrorFormat

  /**
   * @example
   * \`\`\`
   * // Defaults to stdout
   * log: ['query', 'info', 'warn', 'error']
   * 
   * // Emit as events
   * log: [
   *  { emit: 'stdout', level: 'query' },
   *  { emit: 'stdout', level: 'info' },
   *  { emit: 'stdout', level: 'warn' }
   *  { emit: 'stdout', level: 'error' }
   * ]
   * \`\`\`
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
   */
  log?: Array<LogLevel | LogDefinition>
}

export type Hooks = {
  beforeRequest?: (options: {query: string, path: string[], rootField?: string, typeName?: string, document: any}) => any
}

/* Types for Logging */
export type LogLevel = 'info' | 'query' | 'warn' | 'error'
export type LogDefinition = {
  level: LogLevel
  emit: 'stdout' | 'event'
}

export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
  GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
  : never

export type QueryEvent = {
  timestamp: Date
  query: string
  params: string
  duration: number
  target: string
}

export type LogEvent = {
  timestamp: Date
  message: string
  target: string
}
/* End Types for Logging */


export type PrismaAction =
  | 'findOne'
  | 'findMany'
  | 'create'
  | 'update'
  | 'updateMany'
  | 'upsert'
  | 'delete'
  | 'deleteMany'
  | 'executeRaw'
  | 'queryRaw'
  | 'aggregate'

/**
 * These options are being passed in to the middleware as "params"
 */
export type MiddlewareParams = {
  model?: string
  action: PrismaAction
  args: any
  dataPath: string[]
  runInTransaction: boolean
}

/**
 * The \`T\` type makes sure, that the \`return proceed\` is not forgotten in the middleware implementation
 */
export type Middleware<T = any> = (
  params: MiddlewareParams,
  next: (params: MiddlewareParams) => Promise<T>,
) => Promise<T>

// tested in getLogLevel.test.ts
export declare function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

${this.jsDoc}
export declare class PrismaClient<
  T extends PrismaClientOptions = PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<LogLevel | LogDefinition> ? GetEvents<T['log']> : never : never
> {
  /**
   * @private
   */
  private fetcher;
  /**
   * @private
   */
  private readonly dmmf;
  /**
   * @private
   */
  private connectionPromise?;
  /**
   * @private
   */
  private disconnectionPromise?;
  /**
   * @private
   */
  private readonly engineConfig;
  /**
   * @private
   */
  private readonly measurePerformance;
  /**
   * @private
   */
  private engine: Engine;
  /**
   * @private
   */
  private errorFormat: ErrorFormat;

${indent_string3.default(this.jsDoc, tab)}
  constructor(optionsArg?: T);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? QueryEvent : LogEvent) => void): void;
  /**
   * @deprecated renamed to \`$on\`
   */
  on<V extends U>(eventType: V, callback: (event: V extends 'query' ? QueryEvent : LogEvent) => void): void;
  /**
   * Connect with the database
   */
  $connect(): Promise<void>;
  /**
   * @deprecated renamed to \`$connect\`
   */
  connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<any>;
  /**
   * @deprecated renamed to \`$disconnect\`
   */
  disconnect(): Promise<any>;

  /**
   * Add a middleware
   */
  $use(cb: Middleware): void

  /**
   * Executes a raw query and returns the number of affected rows
   * @example
   * \`\`\`
   * // With parameters use prisma.executeRaw\`\`, values will be escaped automatically
   * const result = await prisma.executeRaw\`UPDATE User SET cool = \${true} WHERE id = \${1};\`
   * // Or
   * const result = await prisma.executeRaw('UPDATE User SET cool = $1 WHERE id = $2 ;', true, 1)
  * \`\`\`
  * 
  * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
  */
  $executeRaw<T = any>(query: string | TemplateStringsArray, ...values: any[]): Promise<number>;

  /**
   * @deprecated renamed to \`$executeRaw\`
   */
  executeRaw<T = any>(query: string | TemplateStringsArray, ...values: any[]): Promise<number>;

  /**
   * Performs a raw query and returns the SELECT data
   * @example
   * \`\`\`
   * // With parameters use prisma.queryRaw\`\`, values will be escaped automatically
   * const result = await prisma.queryRaw\`SELECT * FROM User WHERE id = \${1} OR email = \${'ema.il'};\`
   * // Or
   * const result = await prisma.queryRaw('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'ema.il')
  * \`\`\`
  * 
  * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
  */
  $queryRaw<T = any>(query: string | TemplateStringsArray, ...values: any[]): Promise<T>;
 
  /**
   * @deprecated renamed to \`$queryRaw\`
   */
  queryRaw<T = any>(query: string | TemplateStringsArray, ...values: any[]): Promise<T>;
${((_b = (_a = this.generator) == null ? void 0 : _a.previewFeatures) == null ? void 0 : _b.includes("transactionApi")) ? `
  /**
   * Execute queries in a transaction
   * @example
   * \`\`\`
   * const [george, bob, alice] = await prisma.transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * \`\`\`
   */
  $transaction: PromiseConstructor['all']
  /**
   * @deprecated renamed to \`$transaction\`
   */
  transaction: PromiseConstructor['all']
` : ""}
${indent_string3.default(dmmf2.mappings.filter((m) => m.findMany).map((m) => {
      const methodName = lowerCase(m.model);
      return `/**
 * \`prisma.${methodName}\`: Exposes CRUD operations for the **${m.model}** model.
  * Example usage:
  * \`\`\`ts
  * // Fetch zero or more ${capitalize(m.plural)}
  * const ${lowerCase(m.plural)} = await prisma.${methodName}.findMany()
  * \`\`\`
  */
get ${methodName}(): ${m.model}Delegate;`;
    }).join("\n\n"), 2)}
}`;
  }
}
class PayloadType {
  constructor(type) {
    this.type = type;
  }
  toTS() {
    const {type} = this;
    const {name} = type;
    const argsName = getArgName(name, false);
    const include = this.renderRelations(Projection.include);
    const select = this.renderRelations(Projection.select);
    return `export type ${getPayloadName(name)}<
  S extends boolean | null | undefined | ${argsName},
  U = keyof S
> = S extends true
  ? ${name}
  : S extends undefined
  ? never
  : S extends ${argsName} | ${getModelArgName(name, DMMF.ModelAction.findMany)}
  ? 'include' extends U
    ? ${name} ${include.length > 0 ? ` & ${include}` : ""}
  : 'select' extends U
    ? ${select}
  : ${name}
: ${name}
`;
  }
  renderRelations(projection) {
    const {type} = this;
    const relations = type.fields.filter((f) => f.outputType.kind === "object");
    if (relations.length === 0 && projection === Projection.include) {
      return "";
    }
    const selectPrefix = projection === Projection.select ? `P extends keyof ${type.name} ? ${type.name}[P]
: ` : "";
    return `{
      [P in TrueKeys<S['${projection}']>]:${selectPrefix}
${indent_string3.default(relations.map((f) => `P extends '${f.name}'
? ${this.wrapType(f, `${getPayloadName(f.outputType.type.name)}<S['${projection}'][P]>`)} :`).join("\n"), 6)} never
    }`;
  }
  wrapType(field, str) {
    const {outputType} = field;
    if (outputType.isRequired && !outputType.isList) {
      return str;
    }
    if (outputType.isList) {
      return `Array<${str}>`;
    }
    if (!outputType.isRequired) {
      return `${str} | null`;
    }
    return str;
  }
}
class Model {
  constructor(model, dmmf2, generator) {
    this.model = model;
    this.dmmf = dmmf2;
    this.generator = generator;
    const outputType = dmmf2.outputTypeMap[model.name];
    this.outputType = new OutputType(outputType);
    this.mapping = dmmf2.mappings.find((m) => m.model === model.name);
  }
  get argsTypes() {
    const {mapping, model} = this;
    if (!mapping) {
      return [];
    }
    const argsTypes = [];
    for (const action in DMMF.ModelAction) {
      const fieldName = mapping[action];
      if (!fieldName) {
        continue;
      }
      const field = this.dmmf.rootFieldMap[fieldName];
      if (!field) {
        throw new Error(`Oops this must not happen. Could not find field ${fieldName} on either Query or Mutation`);
      }
      if (action === "updateMany" || action === "deleteMany") {
        argsTypes.push(new MinimalArgsType(field.args, model, action));
      } else {
        argsTypes.push(new ArgsType(field.args, model, action));
      }
    }
    argsTypes.push(new ArgsType([], model));
    return argsTypes;
  }
  getAggregationTypes() {
    const {model, mapping} = this;
    const aggregateType = this.dmmf.outputTypeMap[getAggregateName(model.name)];
    if (!aggregateType) {
      throw new Error(`Could not get aggregate type "${getAggregateName(model.name)}" for "${model.name}"`);
    }
    const aggregateTypes = [aggregateType];
    const avgType = this.dmmf.outputTypeMap[getAvgAggregateName(model.name)];
    const sumType = this.dmmf.outputTypeMap[getSumAggregateName(model.name)];
    const minType = this.dmmf.outputTypeMap[getMinAggregateName(model.name)];
    const maxType = this.dmmf.outputTypeMap[getMaxAggregateName(model.name)];
    if (avgType) {
      aggregateTypes.push(avgType);
    }
    if (sumType) {
      aggregateTypes.push(sumType);
    }
    if (minType) {
      aggregateTypes.push(minType);
    }
    if (maxType) {
      aggregateTypes.push(maxType);
    }
    const aggregateRootField = this.dmmf.rootFieldMap[mapping == null ? void 0 : mapping.aggregate];
    if (!aggregateRootField) {
      throw new Error(`Could not find aggregate root field for model ${model.name}. Mapping: ${mapping == null ? void 0 : mapping.aggregate}`);
    }
    return `${aggregateTypes.map((type) => new SchemaOutputType(type).toTS()).join("\n")}

${aggregateTypes.length > 1 ? aggregateTypes.slice(1).map((type) => {
      const newType = {
        name: getAggregateInputType(type.name),
        fields: type.fields.map((field) => ({
          ...field,
          name: field.name,
          inputType: [
            {
              isList: false,
              isNullable: false,
              isRequired: false,
              kind: "scalar",
              type: "true"
            }
          ]
        }))
      };
      return new InputType(newType).toTS();
    }).join("\n") : ""}

export type ${getAggregateArgsName(model.name)} = {
${indent_string3.default(aggregateRootField.args.map((arg) => new InputField(arg).toTS()).concat(aggregateType.fields.map((f) => {
      if (f.name === "count") {
        return `${f.name}?: true`;
      }
      return `${f.name}?: ${getAggregateInputType(f.outputType.type.name)}`;
    })).join("\n"), tab)}
}

export type ${getAggregateGetName(model.name)}<T extends ${getAggregateArgsName(model.name)}> = {
  [P in keyof T]: P extends 'count' ? number : ${aggregateTypes.length > 1 ? `${getAggregateScalarGetName(model.name)}<T[P]>` : "never"}
}

${aggregateTypes.length > 1 ? `export type ${getAggregateScalarGetName(model.name)}<T extends any> = {
  [P in keyof T]: P extends keyof ${getAvgAggregateName(model.name)} ? ${getAvgAggregateName(model.name)}[P] : never
}` : ""}
    
    `;
  }
  toTS() {
    const {model, outputType} = this;
    if (!outputType) {
      return "";
    }
    const hasRelationField = model.fields.some((f) => f.kind === "object");
    const includeType = hasRelationField ? `
export type ${getIncludeName(model.name)} = {
${indent_string3.default(outputType.fields.filter((f) => f.outputType.kind === "object").map((f) => `${f.name}?: boolean` + (f.outputType.kind === "object" ? ` | ${getFieldArgName(f)}` : "")).join("\n"), tab)}
}
` : "";
    return `
/**
 * Model ${model.name}
 */

export type ${model.name} = {
${indent_string3.default(model.fields.filter((f) => f.kind !== "object").map((field) => new OutputField(field).toTS()).join("\n"), tab)}
}

${this.getAggregationTypes()}

export type ${getSelectName(model.name)} = {
${indent_string3.default(outputType.fields.map((f) => `${f.name}?: boolean` + (f.outputType.kind === "object" ? ` | ${getFieldArgName(f)}` : "")).join("\n"), tab)}
}
${includeType}
${new PayloadType(this.outputType).toTS()}

${new ModelDelegate(this.outputType, this.dmmf, this.generator).toTS()}

// Custom InputTypes
${this.argsTypes.map(TS).join("\n")}
`;
  }
}
function getMethodJSDocBody(action, mapping, model) {
  const singular = capitalize(mapping.model);
  const plural = capitalize(mapping.plural);
  const firstScalar = model.fields.find((f) => f.kind === "scalar");
  const method = `prisma.${lowerCase(mapping.model)}.${action}`;
  switch (action) {
    case DMMF.ModelAction.create:
      return `Create a ${singular}.
@param {${getModelArgName(model.name, action)}} args - Arguments to create a ${singular}.
@example
// Create one ${singular}
const ${singular} = await ${method}({
  data: {
    // ... data to create a ${singular}
  }
})
`;
    case DMMF.ModelAction.delete:
      return `Delete a ${singular}.
@param {${getModelArgName(model.name, action)}} args - Arguments to delete one ${singular}.
@example
// Delete one ${singular}
const ${singular} = await ${method}({
  where: {
    // ... filter to delete one ${singular}
  }
})
`;
    case DMMF.ModelAction.deleteMany:
      return `Delete zero or more ${plural}.
@param {${getModelArgName(model.name, action)}} args - Arguments to filter ${plural} to delete.
@example
// Delete a few ${plural}
const { count } = await ${method}({
  where: {
    // ... provide filter here
  }
})
`;
    case DMMF.ModelAction.findMany: {
      const onlySelect = firstScalar ? `
// Only select the \`${firstScalar.name}\`
const ${lowerCase(mapping.model)}With${capitalize(firstScalar.name)}Only = await ${method}({ select: { ${firstScalar.name}: true } })` : "";
      return `Find zero or more ${plural}.
@param {${getModelArgName(model.name, action)}=} args - Arguments to filter and select certain fields only.
@example
// Get all ${plural}
const ${mapping.plural} = await ${method}()

// Get first 10 ${plural}
const ${mapping.plural} = await ${method}({ take: 10 })
${onlySelect}
`;
    }
    case DMMF.ModelAction.findOne: {
      return `Find zero or one ${singular}.
@param {${getModelArgName(model.name, action)}} args - Arguments to find a ${singular}
@example
// Get one ${singular}
const ${lowerCase(mapping.model)} = await ${method}({
  where: {
    // ... provide filter here
  }
})`;
    }
    case DMMF.ModelAction.update:
      return `Update one ${singular}.
@param {${getModelArgName(model.name, action)}} args - Arguments to update one ${singular}.
@example
// Update one ${singular}
const ${lowerCase(mapping.model)} = await ${method}({
  where: {
    // ... provide filter here
  },
  data: {
    // ... provide data here
  }
})
`;
    case DMMF.ModelAction.updateMany:
      return `Update zero or more ${plural}.
@param {${getModelArgName(model.name, action)}} args - Arguments to update one or more rows.
@example
// Update many ${plural}
const ${lowerCase(mapping.model)} = await ${method}({
  where: {
    // ... provide filter here
  },
  data: {
    // ... provide data here
  }
})
`;
    case DMMF.ModelAction.upsert:
      return `Create or update one ${singular}.
@param {${getModelArgName(model.name, action)}} args - Arguments to update or create a ${singular}.
@example
// Update or create a ${singular}
const ${lowerCase(mapping.model)} = await ${method}({
  create: {
    // ... data to create a ${singular}
  },
  update: {
    // ... in case it already exists, update
  },
  where: {
    // ... the filter for the ${singular} we want to update
  }
})`;
  }
}
function getMethodJSDoc(action, mapping, model) {
  return wrapComment(getMethodJSDocBody(action, mapping, model));
}
function wrapComment(str) {
  return `/**
${str.split("\n").map((l) => " * " + l).join("\n")}
**/`;
}
class ModelDelegate {
  constructor(outputType, dmmf2, generator) {
    this.outputType = outputType;
    this.dmmf = dmmf2;
    this.generator = generator;
  }
  toTS() {
    const {fields, name} = this.outputType;
    const mapping = this.dmmf.mappingsMap[name];
    if (!mapping) {
      return "";
    }
    const model = this.dmmf.modelMap[name];
    const actions = Object.entries(mapping).filter(([key, value]) => key !== "model" && key !== "plural" && key !== "aggregate" && value);
    return `export interface ${name}Delegate {
${indent_string3.default(actions.map(([actionName]) => `${getMethodJSDoc(actionName, mapping, model)}
${actionName}<T extends ${getModelArgName(name, actionName)}>(
  args${actionName === DMMF.ModelAction.findMany ? "?" : ""}: Subset<T, ${getModelArgName(name, actionName)}>
): ${getSelectReturnType({name, actionName, projection: Projection.select})}`).join("\n"), tab)}
  /**
   * Count
   */
  count(args?: Omit<${getModelArgName(name, DMMF.ModelAction.findMany)}, 'select' | 'include'>): Promise<number>

  /**
   * Aggregate
   */
  aggregate<T extends ${getAggregateArgsName(name)}>(args: Subset<T, ${getAggregateArgsName(name)}>): Promise<${getAggregateGetName(name)}<T>>
}

/**
 * The delegate class that acts as a "Promise-like" for ${name}.
 * Why is this prefixed with \`Prisma__\`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__${name}Client<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';
${indent_string3.default(fields.filter((f) => f.outputType.kind === "object").map((f) => {
      const fieldTypeName = f.outputType.type.name;
      return `
${f.name}<T extends ${getFieldArgName(f)} = {}>(args?: Subset<T, ${getFieldArgName(f)}>): ${getSelectReturnType({
        name: fieldTypeName,
        actionName: f.outputType.isList ? DMMF.ModelAction.findMany : DMMF.ModelAction.findOne,
        hideCondition: false,
        isField: true,
        renderPromise: true,
        fieldName: f.name,
        projection: Projection.select
      })};`;
    }).join("\n"), 2)}

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}`;
  }
}
class InputField {
  constructor(field, prefixFilter = false) {
    this.field = field;
    this.prefixFilter = prefixFilter;
  }
  toTS() {
    const {field} = this;
    let fieldType;
    let hasNull = false;
    if (Array.isArray(field.inputType)) {
      fieldType = flatMap(field.inputType, (t) => {
        var _a;
        let type = typeof t.type === "string" ? GraphQLScalarToJSTypeTable[t.type] || t.type : this.prefixFilter ? `Base${t.type.name}` : t.type.name;
        type = (_a = JSOutputTypeToInputType[type]) != null ? _a : type;
        if (type === "null") {
          hasNull = true;
        }
        return type;
      }).join(" | ");
    }
    const fieldInputType = field.inputType[0];
    const optionalStr = fieldInputType.isRequired ? "" : "?";
    if (fieldInputType.isList) {
      if (field.name === "OR") {
        fieldType = `Array<${fieldType}>`;
      } else {
        fieldType = `Enumerable<${fieldType}>`;
      }
    }
    const nullableStr = !fieldInputType.isRequired && !hasNull && fieldInputType.isNullable ? " | null" : "";
    const jsdoc = field.comment ? wrapComment(field.comment) + "\n" : "";
    return `${jsdoc}${field.name}${optionalStr}: ${fieldType}${nullableStr}`;
  }
}
class OutputField {
  constructor(field) {
    this.field = field;
  }
  toTS() {
    const {field} = this;
    let fieldType = typeof field.type === "string" ? GraphQLScalarToJSTypeTable[field.type] || field.type : field.type[0].name;
    if (Array.isArray(fieldType)) {
      fieldType = fieldType[0];
    }
    const arrayStr = field.isList ? `[]` : "";
    const nullableStr = !field.isRequired && !field.isList ? " | null" : "";
    return `${field.name}: ${fieldType}${arrayStr}${nullableStr}`;
  }
}
class SchemaOutputField {
  constructor(field) {
    this.field = field;
  }
  toTS() {
    const {field} = this;
    let fieldType = typeof field.outputType.type === "string" ? GraphQLScalarToJSTypeTable[field.outputType.type] || field.outputType.type : field.outputType.type.name;
    if (Array.isArray(fieldType)) {
      fieldType = fieldType[0];
    }
    const arrayStr = field.outputType.isList ? `[]` : "";
    const nullableStr = !field.outputType.isRequired && !field.outputType.isList ? " | null" : "";
    return `${field.name}: ${fieldType}${arrayStr}${nullableStr}`;
  }
}
class SchemaOutputType {
  constructor(type) {
    this.type = type;
    this.name = type.name;
    this.fields = type.fields;
  }
  toTS() {
    const {type} = this;
    return `
export type ${type.name} = {
${indent_string3.default(type.fields.map((field) => new SchemaOutputField({...field, ...field.outputType}).toTS()).join("\n"), tab)}
}`;
  }
}
class OutputType {
  constructor(type) {
    this.type = type;
    this.name = type.name;
    this.fields = type.fields;
  }
  toTS() {
    const {type} = this;
    return `
export type ${type.name} = {
${indent_string3.default(type.fields.map((field) => new OutputField({...field, ...field.outputType}).toTS()).join("\n"), tab)}
}`;
  }
}
class MinimalArgsType {
  constructor(args, model, action) {
    this.args = args;
    this.model = model;
    this.action = action;
  }
  toTS() {
    const {action, args} = this;
    const {name} = this.model;
    return `
/**
 * ${name} ${action ? action : "without action"}
 */
export type ${getModelArgName(name, action)} = {
${indent_string3.default(args.map((arg) => new InputField(arg).toTS()).join("\n"), tab)}
}
`;
  }
}
const topLevelArgsJsDocs = {
  findOne: {
    where: (singular, plural) => `Filter, which ${singular} to fetch.`
  },
  findMany: {
    where: (singular, plural) => `Filter, which ${plural} to fetch.`,
    orderBy: (singular, plural) => `Determine the order of the ${plural} to fetch.`,
    skip: (singular, plural) => `Skip the first \`n\` ${plural}.`,
    cursor: (singular, plural) => `Sets the position for listing ${plural}.`,
    take: (singular, plural) => `The number of ${plural} to fetch. If negative number, it will take ${plural} before the \`cursor\`.`
  },
  create: {
    data: (singular, plural) => `The data needed to create a ${singular}.`
  },
  update: {
    data: (singular, plural) => `The data needed to update a ${singular}.`,
    where: (singular, plural) => `Choose, which ${singular} to update.`
  },
  upsert: {
    where: (singular, plural) => `The filter to search for the ${singular} to update in case it exists.`,
    create: (singular, plural) => `In case the ${singular} found by the \`where\` argument doesn't exist, create a new ${singular} with this data.`,
    update: (singular, plural) => `In case the ${singular} was found with the provided \`where\` argument, update it with this data.`
  },
  delete: {
    where: (singular, plural) => `Filter which ${singular} to delete.`
  }
};
class ArgsType {
  constructor(args, model, action) {
    this.args = args;
    this.model = model;
    this.action = action;
  }
  toTS() {
    const {action, args} = this;
    const {name} = this.model;
    const singular = name;
    const plural = pluralize3.default(name);
    for (const arg of args) {
      if (action && topLevelArgsJsDocs[action][arg.name]) {
        const comment = topLevelArgsJsDocs[action][arg.name](singular, plural);
        arg.comment = comment;
      }
    }
    const bothArgsOptional = [
      {
        name: "select",
        inputType: [
          {
            type: getSelectName(name),
            kind: "object",
            isList: false,
            isRequired: false,
            isNullable: true
          }
        ],
        comment: `Select specific fields to fetch from the ${name}`
      }
    ];
    const hasRelationField = this.model.fields.some((f) => f.kind === "object");
    if (hasRelationField) {
      bothArgsOptional.push({
        name: "include",
        inputType: [
          {
            type: getIncludeName(name),
            kind: "object",
            isList: false,
            isRequired: false,
            isNullable: true
          }
        ],
        comment: `Choose, which related nodes to fetch as well.`
      });
    }
    bothArgsOptional.push(...args);
    return `
/**
 * ${name} ${action ? action : "without action"}
 */
export type ${getModelArgName(name, action)} = {
${indent_string3.default(bothArgsOptional.map((arg) => new InputField(arg).toTS()).join("\n"), tab)}
}
`;
  }
}
class InputType {
  constructor(type) {
    this.type = type;
  }
  toTS() {
    const {type} = this;
    const fields = uniqueBy(type.fields, (f) => f.name);
    const body = `{
${indent_string3.default(fields.map((arg) => new InputField(arg).toTS()).join("\n"), tab)}
}`;
    return `
export type ${type.name} = ${body}`;
  }
}
class Enum {
  constructor(type) {
    this.type = type;
  }
  toJS() {
    const {type} = this;
    return `exports.${type.name} = makeEnum({
${indent_string3.default(type.values.map((v) => `${v}: '${v}'`).join(",\n"), tab)}
});`;
  }
  toTS() {
    const {type} = this;
    return `export declare const ${type.name}: {
${indent_string3.default(type.values.map((v) => `${v}: '${v}'`).join(",\n"), tab)}
};

export declare type ${type.name} = (typeof ${type.name})[keyof typeof ${type.name}]
`;
  }
}
function escapeJson(str) {
  return str.replace(/\\n/g, "\\\\n").replace(/\\r/g, "\\\\r").replace(/\\t/g, "\\\\t");
}

// src/generation/generateClient.ts
const copy = __toModule(require_copy());
const fs = __toModule(require("fs"));
const make_dir = __toModule(require_make_dir());
const path7 = __toModule(require("path"));
const chalk3 = __toModule(require_source());
const util = __toModule(require("util"));
const engineCommands2 = __toModule(require_engineCommands());
const pkg_up = __toModule(require_pkg_up());
const remove = util.promisify(fs.default.unlink);
const writeFile = util.promisify(fs.default.writeFile);
const exists = util.promisify(fs.default.exists);
const copyFile = util.promisify(fs.default.copyFile);
const stat = util.promisify(fs.default.stat);
class DenylistError extends Error {
  constructor(message) {
    super(message);
    this.name = "DenylistError";
    this.stack = void 0;
  }
}
async function buildClient({
  datamodel,
  schemaDir = process.cwd(),
  runtimePath = "@prisma/client/runtime",
  browser = false,
  binaryPaths,
  outputDir,
  generator,
  dmmf: dmmf2,
  datasources,
  engineVersion,
  clientVersion: clientVersion2
}) {
  const document2 = getPrismaClientDMMF(dmmf2);
  const client = new TSClient({
    document: document2,
    runtimePath,
    browser,
    datasources: resolveDatasources(datasources, schemaDir, outputDir),
    sqliteDatasourceOverrides: extractSqliteSources(datamodel, schemaDir, outputDir),
    generator,
    platforms: Object.keys(binaryPaths.queryEngine),
    schemaDir,
    outputDir,
    clientVersion: clientVersion2,
    engineVersion
  });
  const fileMap = {
    "index.d.ts": TS(client),
    "index.js": JS(client)
  };
  return {
    fileMap,
    prismaClientDmmf: document2
  };
}
async function getDotPrismaDir(outputDir) {
  var _a;
  if (process.env.INIT_CWD && process.env.npm_lifecycle_event === "postinstall" && !((_a = process.env.PWD) == null ? void 0 : _a.includes(".pnpm"))) {
    if (fs.default.existsSync(path7.default.join(process.env.INIT_CWD, "package.json"))) {
      return path7.default.join(process.env.INIT_CWD, "node_modules/.prisma/client");
    }
    const packagePath = await pkg_up.default({cwd: process.env.INIT_CWD});
    if (packagePath) {
      return path7.default.join(path7.default.dirname(packagePath), "node_modules/.prisma/client");
    }
  }
  return path7.default.join(outputDir, "../../.prisma/client");
}
async function generateClient({
  datamodel,
  datamodelPath,
  schemaDir = datamodelPath ? path7.default.dirname(datamodelPath) : process.cwd(),
  outputDir,
  transpile,
  runtimePath,
  browser,
  generator,
  dmmf,
  datasources,
  binaryPaths,
  testMode,
  copyRuntime,
  clientVersion,
  engineVersion
}) {
  const useDotPrisma = testMode ? !runtimePath : !(generator == null ? void 0 : generator.isCustomOutput);
  runtimePath = runtimePath || (useDotPrisma ? "@prisma/client/runtime" : "./runtime");
  const finalOutputDir = useDotPrisma ? await getDotPrismaDir(outputDir) : outputDir;
  const {prismaClientDmmf, fileMap} = await buildClient({
    datamodel,
    datamodelPath,
    schemaDir,
    transpile,
    runtimePath,
    browser,
    outputDir: finalOutputDir,
    generator,
    dmmf,
    datasources,
    binaryPaths,
    clientVersion,
    engineVersion
  });
  const denylistsErrors = validateDmmfAgainstDenylists(prismaClientDmmf, generator == null ? void 0 : generator.previewFeatures);
  if (denylistsErrors) {
    let message = `${chalk3.default.redBright.bold("Error: ")}The schema at "${datamodelPath}" contains reserved keywords.
       Rename the following items:`;
    for (const error of denylistsErrors) {
      message += "\n         - " + error.message;
    }
    message += `
To learn more about how to rename models, check out https://pris.ly/d/naming-models`;
    throw new DenylistError(message);
  }
  await make_dir.default(finalOutputDir);
  await make_dir.default(path7.default.join(outputDir, "runtime"));
  await Promise.all(Object.entries(fileMap).map(async ([fileName, file]) => {
    const filePath = path7.default.join(finalOutputDir, fileName);
    if (await exists(filePath)) {
      await remove(filePath);
    }
    await writeFile(filePath, file);
  }));
  const runtimeSourceDir = testMode ? eval(`require('path').join(__dirname, '../../runtime')`) : eval(`require('path').join(__dirname, '../runtime')`);
  if (copyRuntime || !path7.default.resolve(outputDir).endsWith(`@prisma${path7.default.sep}client`)) {
    const copyTarget = path7.default.join(outputDir, "runtime");
    await make_dir.default(copyTarget);
    if (runtimeSourceDir !== copyTarget) {
      await copy.default({
        from: runtimeSourceDir,
        to: copyTarget,
        recursive: true,
        parallelJobs: process.platform === "win32" ? 1 : 20,
        overwrite: true
      });
    }
  }
  if (!binaryPaths.queryEngine) {
    throw new Error(`Prisma Client needs \`queryEngine\` in the \`binaryPaths\` object.`);
  }
  if (transpile) {
    for (const filePath of Object.values(binaryPaths.queryEngine)) {
      const fileName = path7.default.basename(filePath);
      const target = path7.default.join(finalOutputDir, fileName);
      const [sourceFileSize, targetFileSize] = await Promise.all([
        fileSize(filePath),
        fileSize(target)
      ]);
      if (!targetFileSize) {
        await copyFile(filePath, target);
        continue;
      }
      if (targetFileSize && sourceFileSize && targetFileSize !== sourceFileSize) {
        await copyFile(filePath, target);
        continue;
      }
      const [sourceVersion, targetVersion] = await Promise.all([
        engineCommands2.getVersion(filePath).catch(() => null),
        engineCommands2.getVersion(target).catch(() => null)
      ]);
      if (sourceVersion && targetVersion && sourceVersion === targetVersion) {
      } else {
        await copyFile(filePath, target);
      }
    }
  }
  const datamodelTargetPath = path7.default.join(finalOutputDir, "schema.prisma");
  if (datamodelPath !== datamodelTargetPath) {
    await copyFile(datamodelPath, datamodelTargetPath);
  }
  const packageJsonTargetPath = path7.default.join(finalOutputDir, "package.json");
  const pkgJson = JSON.stringify({
    name: ".prisma/client",
    main: "index.js",
    types: "index.d.ts"
  }, null, 2);
  await writeFile(packageJsonTargetPath, pkgJson);
  if (process.env.INIT_CWD) {
    const backupPath = path7.default.join(process.env.INIT_CWD, "node_modules/.prisma/client");
    if (finalOutputDir !== backupPath && !(generator == null ? void 0 : generator.isCustomOutput)) {
      await copy.default({
        from: finalOutputDir,
        to: backupPath,
        recursive: true,
        parallelJobs: process.platform === "win32" ? 1 : 20,
        overwrite: true
      });
    }
  }
  const proxyIndexJsPath = path7.default.join(outputDir, "index.js");
  const proxyIndexDTSPath = path7.default.join(outputDir, "index.d.ts");
  if (!fs.default.existsSync(proxyIndexJsPath)) {
    await copyFile(path7.default.join(__dirname, "../../index.js"), proxyIndexJsPath);
  }
  if (!fs.default.existsSync(proxyIndexDTSPath)) {
    await copyFile(path7.default.join(__dirname, "../../index.d.ts"), proxyIndexDTSPath);
  }
  return {prismaClientDmmf, fileMap};
}
async function fileSize(name) {
  try {
    const statResult = await stat(name);
    return statResult.size;
  } catch (e) {
    return null;
  }
}
function validateDmmfAgainstDenylists(prismaClientDmmf, previewFeatures = []) {
  const errorArray = [];
  const denylists = {
    models: [
      "Query",
      "Mutation",
      "Subscription",
      "dmmf",
      "PromiseType",
      "PromiseReturnType",
      "Enumerable",
      "MergeTruthyValues",
      "CleanupNever",
      "Subset",
      "AtLeastOne",
      "atMostOne",
      "OnlyOne",
      "StringFilter",
      "IDFilter",
      "FloatFilter",
      "IntFilter",
      "BooleanFilter",
      "DateTimeFilter",
      "NullableStringFilter",
      "NullableIDFilter",
      "NullableFloatFilter",
      "NullableIntFilter",
      "NullableBooleanFilter",
      "NullableDateTimeFilter",
      "PrismaClientFetcher",
      "PrismaClient",
      "Engine",
      "BatchPayload",
      "Datasources",
      "ErrorFormat",
      "Hooks",
      "LogLevel",
      "LogDefinition",
      "GetLogType",
      "GetEvents",
      "QueryEvent",
      "LogEvent",
      "ModelDelegate",
      "QueryDelegate",
      "missingArg",
      "ArgError",
      "InvalidFieldError",
      "InvalidFieldNameError",
      "InvalidFieldTypeError",
      "EmptySelectError",
      "NoTrueSelectError",
      "IncludeAndSelectError",
      "EmptyIncludeError",
      "InvalidArgError",
      "InvalidArgNameError",
      "MissingArgError",
      "InvalidArgTypeError",
      "AtLeastOneError",
      "AtMostOneError",
      "PrismaClientRequestError",
      "PrismaClientOptions",
      "PrismaClientKnownRequestError",
      "PrismaClientUnknownRequestError",
      "PrismaClientInitializationError",
      "PrismaClientRustPanicError",
      "PrismaVersion",
      "QueryMode",
      "SortOrder",
      "NestedIntFilter",
      "NestedIntNullableFilter",
      "IntNullableFilter",
      "NestedFloatFilter",
      "NestedFloatNullableFilter",
      "FloatNullableFilter",
      "NestedBoolFilter",
      "BoolFilter",
      "NestedBoolNullableFilter",
      "BoolNullableFilter",
      "NestedStringFilter",
      "NestedStringNullableFilter",
      "StringNullableFilter",
      "NestedDateTimeFilter",
      "NestedDateTimeNullableFilter",
      "DateTimeNullableFilter",
      "NestedJsonFilter",
      "JsonFilter",
      "NestedJsonNullableFilter",
      "JsonNullableFilter",
      "InputJsonValue",
      "IntFieldUpdateOperationsInput",
      "FloatFieldUpdateOperationsInput",
      "BoolFieldUpdateOperationsInput",
      "StringFieldUpdateOperationsInput",
      "DateTimeFieldUpdateOperationsInput",
      "JsonFieldUpdateOperationsInput",
      "NullableIntFieldUpdateOperationsInput",
      "NullableFloatFieldUpdateOperationsInput",
      "NullableBoolFieldUpdateOperationsInput",
      "NullableStringFieldUpdateOperationsInput",
      "NullableDateTimeFieldUpdateOperationsInput",
      "NullableJsonFieldUpdateOperationsInput",
      "NullableFloatFieldUpdateOperationsInput",
      "await",
      "async",
      "break",
      "case",
      "catch",
      "class",
      "const",
      "continue",
      "debugger",
      "default",
      "delete",
      "do",
      "else",
      "enum",
      "export",
      "extends",
      "false",
      "finally",
      "for",
      "function",
      "if",
      "implements",
      "import",
      "in",
      "instanceof",
      "interface",
      "let",
      "new",
      "null",
      "package",
      "private",
      "protected",
      "public",
      "return",
      "super",
      "switch",
      "this",
      "throw",
      "true",
      "try",
      "typeof",
      "var",
      "void",
      "while",
      "with",
      "yield"
    ],
    fields: ["AND", "OR", "NOT"],
    dynamic: []
  };
  for (const {name} of prismaClientDmmf.datamodel.models) {
    denylists.dynamic.push(...[
      `${name}Select`,
      `${name}Include`,
      `${name}Default`,
      `${name}Delegate`,
      `${name}GetPayload`,
      `${name}Filter`,
      `${name}Args`,
      `${name}ArgsFilter`,
      `${name}ArgsRequired`,
      `${name}WhereInput`,
      `${name}WhereUniqueInput`,
      `${name}CreateInput`,
      `${name}UpdateInput`,
      `${name}UpdateManyMutationInput`,
      `${name}OrderByInput`,
      `${name}CreateArgs`,
      `${name}UpsertArgs`,
      `${name}UpdateArgs`,
      `${name}UpdateManyArgs`,
      `${name}DeleteArgs`,
      `${name}DeleteManyArgs`,
      `Extract${name}SelectDeleteArgs`,
      `Extract${name}IncludeDeleteArgs`,
      `FindOne${name}Args`,
      `FindMany${name}Args`,
      `Aggregate${name}`,
      `${name}AvgAggregateOutputType`,
      `${name}SumAggregateOutputType`,
      `${name}MinAggregateOutputType`,
      `${name}MaxAggregateOutputType`,
      `${name}AvgAggregateInputType`,
      `${name}SumAggregateInputType`,
      `${name}MinAggregateInputType`,
      `${name}MaxAggregateInputType`,
      `Aggregate${name}Args`,
      `Get${name}AggregateType`,
      `Get${name}AggregateScalarType`
    ]);
  }
  if (prismaClientDmmf.datamodel.enums) {
    for (const it of prismaClientDmmf.datamodel.enums) {
      if (denylists.models.includes(it.name) || denylists.fields.includes(it.name) || denylists.dynamic.includes(it.name)) {
        errorArray.push(Error(`"enum ${it.name}"`));
      }
    }
  }
  if (prismaClientDmmf.datamodel.models) {
    for (const it of prismaClientDmmf.datamodel.models) {
      if (denylists.models.includes(it.name) || denylists.fields.includes(it.name) || denylists.dynamic.includes(it.name)) {
        errorArray.push(Error(`"model ${it.name}"`));
      }
    }
  }
  return errorArray.length > 0 ? errorArray : null;
}

// src/generator.ts
__export(exports, {
  getDMMF: () => getDMMF
});
const generator_helper = __toModule(require_dist());
const debug = __toModule(require_dist2());
const debugEnabled = debug.default.enabled("prisma-client:generator");
const clientVersion = require_package().version;
generator_helper.generatorHandler({
  onManifest() {
    return {
      defaultOutput: "@prisma/client",
      prettyName: "Prisma Client",
      requiresEngines: ["queryEngine"],
      version: clientVersion
    };
  },
  async onGenerate(options) {
    if (debugEnabled) {
      console.log("__dirname", __dirname);
      console.log(eval(`__dirname`));
    }
    return generateClient({
      datamodel: options.datamodel,
      datamodelPath: options.schemaPath,
      binaryPaths: options.binaryPaths,
      datasources: options.datasources,
      outputDir: options.generator.output,
      copyRuntime: Boolean(options.generator.config.copyRuntime),
      dmmf: options.dmmf,
      generator: options.generator,
      engineVersion: options.version,
      clientVersion,
      transpile: true
    });
  }
});
